{"meta":{"version":1,"warehouse":"5.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cat.png","path":"images/cat.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":1,"renderable":1},{"_id":"source/index.md.temp","path":"index.md.temp","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/.deleted/.OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/.obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570849},{"_id":"source/_posts/.deleted/Copy #1 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570849},{"_id":"source/_posts/.deleted/Copy #1 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #10 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #10 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #11 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #11 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570849},{"_id":"source/_posts/.deleted/Copy #12 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #2 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #2 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #3 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570849},{"_id":"source/_posts/.deleted/Copy #3 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #4 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #4 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #5 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #5 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #6 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #6 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570849},{"_id":"source/_posts/.deleted/Copy #7 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #7 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570849},{"_id":"source/_posts/.deleted/Copy #8 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #8 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #9 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #9 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/新建位图图像.bmp","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.trash/Untitled 26.png.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570829},{"_id":"source/_posts/.trash/未命名.canvas","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570829},{"_id":"source/index.md","hash":"7da1ea52c49d823317a8ac2f9ee86cf50df70707","modified":1686585754124},{"_id":"source/index.md.temp","hash":"839877999682b19d06d4377b064922eb58eef62d","modified":1686385398701},{"_id":"source/_posts/.obsidian/app.json","hash":"2c74662d62f84c5226ede5218af09a91ea5c5430","modified":1686668124614},{"_id":"source/_posts/.obsidian/appearance.json","hash":"63e8c7e4f0b8a4d5f2b86b7f70ea44d0de125a6d","modified":1686668124640},{"_id":"source/_posts/.obsidian/community-plugins.json","hash":"e41290de479820dd04d0db940aac4a55acbb8d20","modified":1686668126329},{"_id":"source/_posts/.obsidian/core-plugins-migration.json","hash":"2285eee1d1614df70edf233f27e7187947aea3d3","modified":1686668126063},{"_id":"source/_posts/.obsidian/core-plugins.json","hash":"54dc51687d814cb0d2011df3a2d9a6a37924af86","modified":1686668125992},{"_id":"source/_posts/.obsidian/hotkeys.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1686384570829},{"_id":"source/_posts/.obsidian/workspace.json","hash":"6dcdd656efea586925645549113967a92ba61f0e","modified":1686668141706},{"_id":"source/_posts/c_program/1.第一周.md","hash":"63a0ba97a05ef5349644d471e4062fca7dfa08bb","modified":1686384570859},{"_id":"source/_posts/linux_shell/1.Shell初识，编辑器使用.md","hash":"1e2adaac228c2103f56b9eb4849a931b3f7326cf","modified":1686660431977},{"_id":"source/_posts/linux_shell/10.text-processing-tools-awk.md","hash":"e83d0c8174c05a0f34f866d328e2828d0a720e0b","modified":1686384570859},{"_id":"source/_posts/linux_shell/2.构建基本脚本.md","hash":"9763ffd1c519423963c3132640db5d4ad00766ef","modified":1686668889617},{"_id":"source/_posts/linux_shell/3.Shell条件测试.md","hash":"dad294d0434fd221f61cc3c03704d059aa897156","modified":1686384570859},{"_id":"source/_posts/linux_shell/4.Shell循环.md","hash":"7a49090c9d942af0f09c138f606842d36c113e76","modified":1686384570859},{"_id":"source/_posts/linux_shell/5.处理用户输入.md","hash":"d13d57550626402292ac7dfa9bec4592127916cb","modified":1686384570859},{"_id":"source/_posts/linux_shell/6.使用重定向呈现数据.md","hash":"f3f0aef5f642f49a1568f1bb5c113bf699411d41","modified":1686384570859},{"_id":"source/_posts/linux_shell/7.Shell函数.md","hash":"ecb30be206e185ba9911a740d96eb02985abb505","modified":1686384570859},{"_id":"source/_posts/linux_shell/8.正则表达式.md","hash":"0d96ddbf5a3c244d9933cd2d317b3fb44e433740","modified":1686384570859},{"_id":"source/_posts/linux_shell/9.流编辑器sed.md","hash":"f1fd817fa25e590166a60a0496f2a734c9919bcb","modified":1686384570859},{"_id":"source/_posts/.obsidian/plugins/dataview/manifest.json","hash":"ddd9ed4be8f9d6bff39d58a3a663cca36e900c84","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/dataview/styles.css","hash":"d8705550409b8cbaec842e3f98efedcdadbe2b32","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/obsidian-linter/data.json","hash":"82358df459eb7332bb7933ee351acb6ed2fd3909","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/obsidian-linter/manifest.json","hash":"761287e28e70cc91877dc532dd8472613124f192","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/obsidian-linter/styles.css","hash":"369c7b06e650354d20bcc91f7c3d678084fc5fc8","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/obsidian-quiet-outline/manifest.json","hash":"a678e7a044c709d129582e1bf9d01e9db7e09ad5","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/obsidian-quiet-outline/styles.css","hash":"788e109fa45cb3de19be58193443d44d1854451b","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/table-editor-obsidian/data.json","hash":"94c879cd5c6a819bd39c4de9d25919dcf08764a0","modified":1686668124121},{"_id":"source/_posts/.obsidian/plugins/table-editor-obsidian/manifest.json","hash":"d63fff649e6fcd9fd5b8eada80b6414feddad7de","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/table-editor-obsidian/styles.css","hash":"a03f657e10903825a3c4b2c2ff67b378b33df136","modified":1686384570829},{"_id":"source/_posts/.obsidian/themes/Blue Topaz/manifest.json","hash":"e1ce1badf6cd4436b7754cfeb0e07532607e7f75","modified":1686384570849},{"_id":"source/_posts/.obsidian/themes/Obsidian Nord/manifest.json","hash":"8bf923f083d545ff9f64afdc7695e47b56ec32ee","modified":1686384570849},{"_id":"source/_posts/.obsidian/themes/Obsidian Nord/theme.css","hash":"3afc5c4a854a0038054912a468c92fd7442ebb46","modified":1686384570849},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1686405503987},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1686405503987},{"_id":"themes/next/.stylelintrc","hash":"dedb8dd4d454cb1bb6aba594ef2cbd05ec2427d8","modified":1686405503997},{"_id":"themes/next/_vendors.yml","hash":"94f2df79d55bf83cb8cc5e27de4588c209c207c8","modified":1686405544467},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1686405544467},{"_id":"themes/next/package.json","hash":"23dc7478ce212975bae15b9758f3b92c93a378b8","modified":1686405544497},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1686405544497},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1686405544467},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1686405544477},{"_id":"themes/next/README.md","hash":"36c4b25587ca494102323dab5a38de5490451a64","modified":1686405544467},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1686405544477},{"_id":"themes/next/_config.yml","hash":"f2afef5ffd2ba06bbbbe0db74d845bc2d884bc8a","modified":1686405544467},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1686405544477},{"_id":"themes/next/languages/ar.yml","hash":"7d0f39e8684284a04bb9808521c87fecda8bd131","modified":1686405544477},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1686405544467},{"_id":"themes/next/languages/bn.yml","hash":"9f791494afa263c3e31f14b8a5fa2996dfc834c0","modified":1686405544477},{"_id":"themes/next/languages/de.yml","hash":"79b37df731c29665dee6cd7c90d278e1edfb6e24","modified":1686405544477},{"_id":"themes/next/languages/default.yml","hash":"ba0fd79a2b1d8db01a034180556061745965ff05","modified":1686405544477},{"_id":"themes/next/languages/en.yml","hash":"ba0fd79a2b1d8db01a034180556061745965ff05","modified":1686405544477},{"_id":"themes/next/languages/fa.yml","hash":"f3ffc444599f4ac92d62e9ed00a1490ebc277d70","modified":1686405544477},{"_id":"themes/next/languages/es.yml","hash":"dffc63ef42e1266b88e0acf08994fd17a9908d53","modified":1686405544477},{"_id":"themes/next/languages/fr.yml","hash":"44cd26479f503751329f6da2ed80cce1bbf18117","modified":1686405544477},{"_id":"themes/next/languages/it.yml","hash":"16d716ecfd748def2f6486ef5a82d0ab7ceb4890","modified":1686405544477},{"_id":"themes/next/languages/id.yml","hash":"929df147f4f17d638b07de5fe52ca13e2549ab1c","modified":1686405544477},{"_id":"themes/next/languages/ja.yml","hash":"543222bfc516aab6c33e8534f807972ecb8943a9","modified":1686405544477},{"_id":"themes/next/languages/nl.yml","hash":"3cb3687696635ec71b4ca40c5fc43b56acc8843e","modified":1686405544477},{"_id":"themes/next/languages/ko.yml","hash":"d345a303310c8a5f4836c3683f3580f861ebd1b4","modified":1686405544477},{"_id":"themes/next/languages/pt-BR.yml","hash":"76b8576ce228d540a16b1f0af5af2cce20923194","modified":1686405544477},{"_id":"themes/next/languages/pt.yml","hash":"70de366e10ea584ba039d40d6b35ac97f93454ad","modified":1686405544477},{"_id":"themes/next/languages/si.yml","hash":"2d712eedf3f60d04d36c3108cf5a12e2a52e875c","modified":1686405544477},{"_id":"themes/next/languages/ru.yml","hash":"c6d8de0ff7d8148d09993257cfd3b7aca755696c","modified":1686405544477},{"_id":"themes/next/languages/th.yml","hash":"6829e998b39f8f143e20b276bb1f62d95a29de58","modified":1686405544477},{"_id":"themes/next/languages/tk.yml","hash":"511726054873f6f8d7ce0d2e803f6731de0ddbe7","modified":1686405544477},{"_id":"themes/next/languages/tr.yml","hash":"a57e4ed089b893a95f5e1ecff17ce625165f4d46","modified":1686405544477},{"_id":"themes/next/languages/vi.yml","hash":"7ebcba5e1128784195e4681dffc9d34c4e873fec","modified":1686405544477},{"_id":"themes/next/languages/zh-CN.yml","hash":"741d7efe0262c9cdc2c648014b55599665d90f6b","modified":1686405544477},{"_id":"themes/next/languages/zh-HK.yml","hash":"88ea50eeb9097ab4a87a44981a102d8594feb064","modified":1686405544477},{"_id":"themes/next/layout/_layout.njk","hash":"fc0a45112f2dcfc2642404e8934ea32a793c3bd7","modified":1686405544477},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1686405544477},{"_id":"themes/next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1686405544477},{"_id":"themes/next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1686405544477},{"_id":"themes/next/layout/page.njk","hash":"b0660b2af0ac7d3fda14ca4d9f2c9e79ef06c6f9","modified":1686405544477},{"_id":"themes/next/layout/post.njk","hash":"0bfce9f133f501a9a4837257e3b862b3bbca15be","modified":1686405544477},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1686405544477},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1686405544517},{"_id":"themes/next/languages/zh-TW.yml","hash":"4695c87d6b81b3a23d16ad6513d9eaa925f8d8ad","modified":1686405544477},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1686405544477},{"_id":"themes/next/docs/ru/README.md","hash":"ac3c4a7616ea80f0d32d68d6e53233952ba756dc","modified":1686405544467},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1686405544477},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1686405544477},{"_id":"themes/next/docs/zh-CN/README.md","hash":"9bbdbb0656505acceef9b9895a576164175fe888","modified":1686405544467},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1686405544477},{"_id":"themes/next/layout/_macro/post.njk","hash":"7e8268fd5cbd552322b276f52459fd187c2453d2","modified":1686405544477},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1686405544477},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"bc719473ed5948ab6859449d60b8d36cfc1542b4","modified":1686405544477},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"547c62ab14d9e05d2d9116db9048a677fbe1fb6d","modified":1686405544477},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1686405544477},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1686405544477},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1686405544477},{"_id":"themes/next/layout/_third-party/index.njk","hash":"aa37f8e98208177b63e3328d6e53b022c6edf3b2","modified":1686405544477},{"_id":"themes/next/layout/_partials/footer.njk","hash":"c40760b559c516677c8b11a00ba50c011f2079fd","modified":1686405544477},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1686405544477},{"_id":"themes/next/scripts/events/index.js","hash":"bd9ea82376cd87df611ea3ae077875c7c595a3df","modified":1686405544497},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1686405544507},{"_id":"themes/next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1686405544497},{"_id":"themes/next/scripts/filters/minify.js","hash":"ce8477e7fb226525bae5872cd68a1c2c23ad50c8","modified":1686405544507},{"_id":"themes/next/scripts/filters/post.js","hash":"fdc8a0af90035e89c3fcb754a0eb189b8951a2bc","modified":1686405544507},{"_id":"themes/next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":1686405544507},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1686405544507},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1686405544507},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"226fccbe9c93265e65a300e3cb4bf6f9065cfdd7","modified":1686405544507},{"_id":"themes/next/scripts/helpers/next-paginator.js","hash":"e86c764b546e4fbb87970cabc4135a56f9ef9fe1","modified":1686405544507},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"fd24abfaba4d91923ddb6aecf0268b216678c8bd","modified":1686405544507},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1686405544507},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1686405544497},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1686405544497},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1686405544497},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":1686405544497},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1686405544497},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1686405544497},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1686405544497},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1686405544497},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1686405544497},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1686405544497},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1686405544497},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1686405544497},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"e7f988ecddb2159313699a00827a45eca5622bd4","modified":1686405544477},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1686405544477},{"_id":"themes/next/source/css/main.styl","hash":"f08dc859180f258bde852e724dbc5e2f54bec073","modified":1686406219988},{"_id":"themes/next/source/css/noscript.styl","hash":"dadc81256afb127b77eac6763d5ee0ec9c77f0a3","modified":1686405544507},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1686405544507},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1686405544507},{"_id":"themes/next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1686405544507},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1686405544507},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1686405544507},{"_id":"themes/next/source/css/_mixins.styl","hash":"83647a6207333b9609ba90b0946b3fa9548e6381","modified":1686405544507},{"_id":"themes/next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1686405544507},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1686405544507},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1686405544507},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1686405544507},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1686405544507},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1686405544507},{"_id":"themes/next/source/js/motion.js","hash":"770d63c26f22705311028a36b52e999cc8a2da82","modified":1686405544507},{"_id":"themes/next/source/js/pjax.js","hash":"b03ba78c6916ad2f390d55bc1bc18fafb64b0ebf","modified":1686405544507},{"_id":"themes/next/source/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1686405544507},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1686405544517},{"_id":"themes/next/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1686405544517},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1686405544517},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1686405544517},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1686405544517},{"_id":"themes/next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1686405544507},{"_id":"themes/next/source/js/utils.js","hash":"5e1cf39de050964e97fb3ba0825aeec7f4bc36dd","modified":1686405544507},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1686405544517},{"_id":"themes/next/test/tags/group-pictures.js","hash":"5c68ae0184f9da6e00ba199f2554d503d8e6da71","modified":1686405544517},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1686405544517},{"_id":"themes/next/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1686405544517},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1686405544517},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1686405544517},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1686405544517},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1686405544517},{"_id":"themes/next/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1686405544517},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1686405544477},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1686405544517},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"dd9c4c03e99dfde0dfb8edefcb2c933f2f560efc","modified":1686405544477},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1686405544477},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1686405544477},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1686405544477},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1686405544477},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1686405544477},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1686405544477},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"5388b157bba4a40b9312f4a45c6678974ccf0837","modified":1686405544477},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1686405544477},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1686405544477},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"79667fd0be85ee0e0c69e542e4f870b114c96c33","modified":1686405544477},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"c1e33b4889f75acc490af3c8bde0ec56c518ff41","modified":1686405544477},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1686405544477},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1686405544477},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"e8b8a7c41e9ec612d0c0c73419529d55d1c16256","modified":1686405544477},{"_id":"themes/next/layout/_partials/post/post-share.njk","hash":"3f28cc4411c0ffc0e41b7970d5ab329c7e46f497","modified":1686405544477},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1686405544477},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1686405544477},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1686405544477},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"e0986db00a0201dd3c60570f964829c84ba5bc68","modified":1686405544477},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1686405544477},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1686405544477},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1686405544477},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1686405544477},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"f900306497b133e8b098bd9f4b96b93d1d96c185","modified":1686405544477},{"_id":"themes/next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1686405544477},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1686405544477},{"_id":"themes/next/layout/_third-party/analytics/plausible.njk","hash":"ef9f2bb7110507f1c4336800af9157d5fa9765bd","modified":1686405544477},{"_id":"themes/next/layout/_third-party/analytics/umami.njk","hash":"181f69b6718c7a8642a88652260cc0a26084a3ee","modified":1686405544477},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1686405544477},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1686405544477},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"70342218473a6e6aa9148de06bfffe121afb8548","modified":1686405544477},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1686405544477},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1686405544477},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1686405544477},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1686405544477},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1686405544477},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1686405544477},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1686405544477},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1686405544477},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1686405544477},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1686405544477},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1686405544477},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1686405544477},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1686405544477},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1686405544477},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1686405544477},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1686405544477},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1686405544477},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1686405544477},{"_id":"themes/next/scripts/events/lib/config.js","hash":"9ec51eb61f7fee612ffc5252f489003a0fa301fc","modified":1686405544497},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1686405544497},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1686405544497},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1686405544497},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":1686405544497},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"64e4024376b51fe81be7ad80235abdf0a83853bd","modified":1686405544497},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1686405544507},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1686405544507},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1686405544507},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1686405544507},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"a600a98e7436edeb31e291abca359885567df3c9","modified":1686405544507},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1686405544507},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1686405544507},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1686405544507},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1686405544507},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"c7791eb0e38e07d8ce3a06cd2e84007c904ebe86","modified":1686405544517},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a1418c9dc8c0f1a0ad4ded0f4627c45bf0db1a10","modified":1686405544507},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1686405544517},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1686405544477},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1686405544517},{"_id":"themes/next/languages/uk.yml","hash":"ff537047b4b4c3ca9a7b64fa7f428a9942751eeb","modified":1686405544477},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1686405544507},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1686405544507},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"7664491542046df9a3887cf40a06e00c0b4086a9","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"2298e521253b3bf376a2412271bc2a7d305051f3","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1686405544507},{"_id":"themes/next/source/js/schemes/muse.js","hash":"ba7ba2c129d1f240c6a22cec3e53f3f22af64b6b","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"f4228c759db4a650c8d38745c2edd1dc83c45687","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"782ee1fc5e669d3ddbfeb82b73ad7fe561f1a4fb","modified":1686405544507},{"_id":"themes/next/source/css/_variables/base.styl","hash":"c4fc4e862d09221265ab1466085f057be2ad2e4d","modified":1686405544517},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"dafc6d23c80d6fe3e55a7711e94210d2479b629a","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"fa4fd8f76464e214fb7318f325b13c2b62f4b478","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"485d23ccb42c0d0c8ead7ea8930dd3e06d79a285","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"3fbfab591f280e2e7f3b0265901c93bc4bd137ed","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6569a6640f79d247a8235b3914772c0e2f99ead2","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1686405544507},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"48f4f277946a168d0db1ea02804e85c22ca2c7db","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"ac2dc0ce9c775a83ef7132ae957b54539366ac9c","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"26a0cba1eee5de45a45a5e14e17707f905390512","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"91dbf3ca5c3a613d4e30618c120da535bf2d0336","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1686405544507},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1686405544507},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1686405544507},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1686405544507},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1686405544507},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1686405544507},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"547c0b5cd5e7ea10d21863d13a6b16579a49396c","modified":1686405544507},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1686405544507},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1686405544507},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1686405544507},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1686405544507},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1686405544507},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1686405544507},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1686405544507},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"9dfe853c901bdc52fc950bacdf15484dbb9bf140","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":1686405544507},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1686405544507},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1686405544507},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1686405544507},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"098d4bd034e986fcf7e443eac4fc2193935461b7","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":1686405544507},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1ecfd64507954810b07a9d21fb5305b5378feda0","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"11497388f124bfbb4001495a67d3629a9f618405","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1686405544507},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"04cf4a69537fc14d3b8904f965d283356853847f","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"40c9839d3288c3b7de0bf38ac2e18f6c8eba6227","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"877a537d5b95beb048142e4fdee6f17e6ef9c7bb","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8f094c4ac17e2ab45569b12d157747f9c7333c12","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"77550e0d3e029b7458e35d8c5ae1fbd612c9673b","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":1686405544507},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"4e967702cf4c637132346bc74ec8854426f1a68c","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"6e0d0796ef7fbbb62ffdfb448753a850de82c74f","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"b750af2fb833c10c4313b5a4258237161a7833d7","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a851e9d5aefcd027c95eeb323860b6da70f202d1","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"da5e88f8debd5ac8d7af5c6ba6240df66104955f","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b05908f04ef95f2d91e6eba89b12411c378d050f","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"c6a27beb3f741211a14576026f3b4cfc44cc6407","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"c2e354a565c8c1b32bd0ceacc972b17982758b67","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"9a7c71560fbdc936ad4e736fe15063ea3e8a644b","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"670fc109b56a010b166b86b616823a1aae97a738","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1686405544507},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"24752d145c6fb8f5344dca9c7b9640839c02e009","modified":1686405544507},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"9056be572ec1cfa429abb22be4b45a662d5b0fb1","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"98d4c20aff0f0fcfe1824017fb06ab21ef0d218e","modified":1686405544507},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1686405544507},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1686405544507},{"_id":"themes/next/source/images/cat.png","hash":"e7fd992e7aaf6e091b819e68d3adf8622c99663a","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1686405544507},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":1686405544507},{"_id":"source/_posts/.obsidian/plugins/obsidian-quiet-outline/main.js","hash":"d114c38a0835ece26be946b7b6a17e2f216c9cc0","modified":1686384570829},{"_id":"source/_posts/.obsidian/themes/Blue Topaz/theme.css","hash":"9d8342c74c678bab55b339d2b2ba76db853438e4","modified":1686384570849},{"_id":"source/_posts/.obsidian/plugins/obsidian-linter/main.js","hash":"1fbdc9e2bab546bd115ace9f8c987327a1c9e43b","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/dataview/main.js","hash":"551153e308a7a463ed841905ce3e4ef0fc59d1af","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/table-editor-obsidian/main.js","hash":"ad3a3ce7b72c396c15c638c1e4e835fe2a4951ba","modified":1686384570829},{"_id":"public/index.html","hash":"7f27979e9e47ed799f6183159e2386202fb82aac","modified":1686669036749},{"_id":"public/archives/index.html","hash":"0e83b5bde9b72e490ce13510ea6a4a83fe0ff6ab","modified":1686669036749},{"_id":"public/archives/page/2/index.html","hash":"06d67c648349829c7ef920fe1a7d285938a90345","modified":1686669036749},{"_id":"public/archives/2023/index.html","hash":"41bf43f2c90f23a3f3104c936e7ad4ca478dba0a","modified":1686669036749},{"_id":"public/archives/2023/page/2/index.html","hash":"ad2291e1bbdb629d4d53bf8426eff9b3e09144aa","modified":1686669036749},{"_id":"public/archives/2023/04/index.html","hash":"4944534af79a6936633cb10cfa4acdc1add40f9d","modified":1686669036749},{"_id":"public/archives/2023/06/index.html","hash":"4bc18ed5ee91f8ffbbd61991d2fd43d21a0fe440","modified":1686669036749},{"_id":"public/2023/06/09/c_program/1.第一周/index.html","hash":"f99b208b46b45475f87b5cbf77661c693483e690","modified":1686669036749},{"_id":"public/2023/04/23/linux_shell/10.text-processing-tools-awk/index.html","hash":"9c92fe82a6a8d9b031a6e3528f63433ba1acff8d","modified":1686669036749},{"_id":"public/2023/04/18/linux_shell/1.Shell初识，编辑器使用/index.html","hash":"f5758a105283ea8a1d9b303369b1ec2110683d39","modified":1686669036749},{"_id":"public/2023/04/18/linux_shell/2.构建基本脚本/index.html","hash":"4323ad5c40d3c9eaca36aeb9f5e5ccdd55fee7e2","modified":1686669036749},{"_id":"public/2023/04/18/linux_shell/3.Shell条件测试/index.html","hash":"7e5e35fa6a7868ed56b901b41f249cc5dc8df194","modified":1686669036749},{"_id":"public/2023/04/18/linux_shell/4.Shell循环/index.html","hash":"d0aba4f5a24800323df84f36e8a8e7c848bb14cd","modified":1686669036749},{"_id":"public/2023/04/18/linux_shell/5.处理用户输入/index.html","hash":"c52e3943a56ae6a403f6770ddf6359b28ec744d3","modified":1686669036749},{"_id":"public/2023/04/18/linux_shell/6.使用重定向呈现数据/index.html","hash":"9f36bdb0d9802436279f04a040757385194e8eac","modified":1686669036749},{"_id":"public/2023/04/18/linux_shell/7.Shell函数/index.html","hash":"14f0e25e6cc8b5932d0c9897dd588b653febcf0d","modified":1686669036749},{"_id":"public/2023/04/18/linux_shell/8.正则表达式/index.html","hash":"3c23628664e5dc44723078380d1c3904af3cfd90","modified":1686669036749},{"_id":"public/2023/04/18/linux_shell/9.流编辑器sed/index.html","hash":"2e4ebb338136ddf06ac63b6f2a70b84f31229e75","modified":1686669036749},{"_id":"public/source/index.md/index.html","hash":"55f5dacbe40914e7d4d7779a2211ee90b77a68db","modified":1686669036749},{"_id":"public/source/index.md/page/2/index.html","hash":"95c926a91e98296a1dff7cb80884e421aab7ebfe","modified":1686669036749},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1686669036749},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1686669036749},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1686669036749},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1686669036749},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1686669036749},{"_id":"public/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1686669036749},{"_id":"public/index.md.temp","hash":"839877999682b19d06d4377b064922eb58eef62d","modified":1686669036749},{"_id":"public/images/cat.png","hash":"e7fd992e7aaf6e091b819e68d3adf8622c99663a","modified":1686669036749},{"_id":"public/css/noscript.css","hash":"4cd5301e478e0e0d4b176740ec314087ec5cb707","modified":1686669036749},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1686669036749},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1686669036749},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1686669036749},{"_id":"public/js/motion.js","hash":"770d63c26f22705311028a36b52e999cc8a2da82","modified":1686669036749},{"_id":"public/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1686669036749},{"_id":"public/js/pjax.js","hash":"b03ba78c6916ad2f390d55bc1bc18fafb64b0ebf","modified":1686669036749},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1686669036749},{"_id":"public/js/schemes/muse.js","hash":"ba7ba2c129d1f240c6a22cec3e53f3f22af64b6b","modified":1686669036749},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1686669036749},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1686669036749},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1686669036749},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1686669036749},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1686669036749},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1686669036749},{"_id":"public/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1686669036749},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1686669036749},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1686669036749},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1686669036749},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1686669036749},{"_id":"public/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1686669036749},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1686669036749},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1686669036749},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1686669036749},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1686669036749},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1686669036749},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1686669036749},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1686669036749},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1686669036749},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1686669036749},{"_id":"public/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1686669036749},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1686669036749},{"_id":"public/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1686669036749},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1686669036749},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1686669036749},{"_id":"public/css/main.css","hash":"b9e815dfd57ad1151e5cc4695393eac8687dfbb8","modified":1686669036749},{"_id":"public/js/utils.js","hash":"5e1cf39de050964e97fb3ba0825aeec7f4bc36dd","modified":1686669036749}],"Category":[],"Data":[],"Page":[{"layout":"page","title":"Home Page","date":"2023-04-17T16:00:00.000Z","tags":null,"_content":"\n## Linux Shell编程-64课时\n\n1. {% post_link linux_shell/1.Shell初识，编辑器使用 %}  \n1. {% post_link linux_shell/2.构建基本脚本 %}  \n1. {% post_link linux_shell/3.Shell条件测试 %}  \n1. {% post_link linux_shell/4.Shell循环 %}  \n1. {% post_link linux_shell/5.处理用户输入 %}  \n1. {% post_link linux_shell/6.使用重定向呈现数据 %}  \n1. {% post_link linux_shell/7.Shell函数 %}  \n1. {% post_link linux_shell/8.正则表达式 %}  \n1. {% post_link linux_shell/9.流编辑器sed %}  \n\n## c语言程序设计转本-16课时\n\n1. {% post_link c_program/1.第一周 %}\n2.\n","source":"index.md","raw":"---\nlayout: page\ntitle: Home Page\ndate: 2023-04-18\ntags: \n---\n\n## Linux Shell编程-64课时\n\n1. {% post_link linux_shell/1.Shell初识，编辑器使用 %}  \n1. {% post_link linux_shell/2.构建基本脚本 %}  \n1. {% post_link linux_shell/3.Shell条件测试 %}  \n1. {% post_link linux_shell/4.Shell循环 %}  \n1. {% post_link linux_shell/5.处理用户输入 %}  \n1. {% post_link linux_shell/6.使用重定向呈现数据 %}  \n1. {% post_link linux_shell/7.Shell函数 %}  \n1. {% post_link linux_shell/8.正则表达式 %}  \n1. {% post_link linux_shell/9.流编辑器sed %}  \n\n## c语言程序设计转本-16课时\n\n1. {% post_link c_program/1.第一周 %}\n2.\n","updated":"2023-06-12T16:02:34.124Z","path":"index.html","comments":1,"_id":"cliuf72w40000j1nza7n4d7zd","content":"<h2 id=\"Linux-Shell编程-64课时\"><a href=\"#Linux-Shell编程-64课时\" class=\"headerlink\" title=\"Linux Shell编程-64课时\"></a>Linux Shell编程-64课时</h2><ol>\n<li><a href=\"/2023/04/18/linux_shell/1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/\" title=\"Shell初始,编辑器使用\">Shell初始,编辑器使用</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/2.%E6%9E%84%E5%BB%BA%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC/\" title=\"构建基本脚本\">构建基本脚本</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95/\" title=\"Shell条件测试\">Shell条件测试</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/4.Shell%E5%BE%AA%E7%8E%AF/\" title=\"Shell循环\">Shell循环</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/5.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/\" title=\"处理用户输入\">处理用户输入</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/6.%E4%BD%BF%E7%94%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE/\" title=\"使用重定向呈现数据\">使用重定向呈现数据</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/7.Shell%E5%87%BD%E6%95%B0/\" title=\"Shell函数\">Shell函数</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/8.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/\" title=\"正则表达式\">正则表达式</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/9.%E6%B5%81%E7%BC%96%E8%BE%91%E5%99%A8sed/\" title=\"流编辑器sed\">流编辑器sed</a></li>\n</ol>\n<h2 id=\"c语言程序设计转本-16课时\"><a href=\"#c语言程序设计转本-16课时\" class=\"headerlink\" title=\"c语言程序设计转本-16课时\"></a>c语言程序设计转本-16课时</h2><ol>\n<li><a href=\"/2023/06/09/c_program/1.%E7%AC%AC%E4%B8%80%E5%91%A8/\" title=\"第一周\">第一周</a></li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Linux-Shell编程-64课时\"><a href=\"#Linux-Shell编程-64课时\" class=\"headerlink\" title=\"Linux Shell编程-64课时\"></a>Linux Shell编程-64课时</h2><ol>\n<li><a href=\"/2023/04/18/linux_shell/1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/\" title=\"Shell初始,编辑器使用\">Shell初始,编辑器使用</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/2.%E6%9E%84%E5%BB%BA%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC/\" title=\"构建基本脚本\">构建基本脚本</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95/\" title=\"Shell条件测试\">Shell条件测试</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/4.Shell%E5%BE%AA%E7%8E%AF/\" title=\"Shell循环\">Shell循环</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/5.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/\" title=\"处理用户输入\">处理用户输入</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/6.%E4%BD%BF%E7%94%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE/\" title=\"使用重定向呈现数据\">使用重定向呈现数据</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/7.Shell%E5%87%BD%E6%95%B0/\" title=\"Shell函数\">Shell函数</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/8.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/\" title=\"正则表达式\">正则表达式</a>  </li>\n<li><a href=\"/2023/04/18/linux_shell/9.%E6%B5%81%E7%BC%96%E8%BE%91%E5%99%A8sed/\" title=\"流编辑器sed\">流编辑器sed</a></li>\n</ol>\n<h2 id=\"c语言程序设计转本-16课时\"><a href=\"#c语言程序设计转本-16课时\" class=\"headerlink\" title=\"c语言程序设计转本-16课时\"></a>c语言程序设计转本-16课时</h2><ol>\n<li><a href=\"/2023/06/09/c_program/1.%E7%AC%AC%E4%B8%80%E5%91%A8/\" title=\"第一周\">第一周</a></li>\n<li></li>\n</ol>\n"}],"Post":[{"title":"Shell初始,编辑器使用","date":"2023-04-18T03:31:25.000Z","_content":"\n```text\n虚拟机：ubuntu14045\n登录账号：llx\n密码：ubuntu\n```\n\n1. 什么是Shell\n    现在人们使用的操作系统（Windows、Android、iOS等）都带有图形界面，简单直观，容易上手。然而早期的计算机并没有图形界面，人们只能使用烦琐的命令来控制计算机。其实，真正能够控制计算机硬件（CPU、内存、显示器）的只有操作系统内核（Kernel），图形界面和命令行都是架设在用户和内核之间的桥梁，是为了方便用户控制计算机而存在的。由于安全等原因，用户不能直接接触内核，因此需要在用户和内核之间增加“命令解释器”，既能简化用户的操作，又能保障内核的安全。在Linux下的命令解释器叫作“Shell”，它能让用户更加高效、安全、低成本地使用Linux内核。\n    ![1.Shell初识，编辑器使用-2023-04-19-18-53-43](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-18-53-43.png)\n\n2. Shell的各种版本：\n    1. Bourne shell（sh）是Unix系统中最古老的shell，也是现在大多数shell的基础。它的命令行语法较为简单，缺乏一些高级特性，但是在大多数Unix系统中都内置了这个shell，因此可以保证可移植性。尽管Bourne shell已经被多种先进的shell所取代，但它作为shell编程的鼻祖，仍然具有重要的历史和学习价值。\n    2. Bourne Again Shell （bash）是Linux操作系统所使用的Shell，它是Bourne Shell的扩展，简称bash。bash与Bourne Shell完全向下兼容，也就是说bash可以兼容相同版本的Bourne Shell。bash在Bourne Shell的基础上增加、增强了很多特性，所以它比Bourne Shell能力更强。\n    3. zsh（Z shell）是Bourne shell（sh）的一个增强版本。与bash相比，zsh具有更好的命令补全功能、更好的主题和插件支持、更好的脚本语言、更好的历史命令管理和更好的可定制性。它还有许多其他功能，如自动提示，文件名扩展，别名扩展等。zsh是一种功能强大、易于使用和高度可定制的Shell，适用于任何需要使用命令行的用户。\n    4. 练习：查看Shell版本、更换默认Shell\n\n    ```bash\n\n    ##查看当前Shell版本\n    echo $SHELL\n    \n    ##查看系统当前可用Shell\n    cat /etc/shells\n    \n    ##更换默认Shell\n    chsh -s /bin/zsh\n    \n    ##退出当前登录状态重新登录\n    ```\n\n3. Shell的启动方式和提示符\n    1. 终端上启动\n        Shell会以交互模式启动，提示符会显示在屏幕上，等待用户输入命令。  \n        用户输入命令后，Shell会解释和执行这些命令，并将执行结果输出到终端上。  \n        在终端启动模式下，Shell会自动设置一些环境变量，如PATH等，以便用户可以方便地执行命令。\n\n    2. 脚本启动\n        脚本启动是将Shell命令写入一个脚本文件中，然后通过执行这个脚本文件来启动Shell。它的基本过程如下：\n        （1）创建一个包含Shell命令的脚本文件（通常以.sh作为扩展名）。\n        （2）将脚本文件保存到磁盘上，并赋予执行权限。\n        （3）在终端中输入脚本文件的路径，并按下回车键。\n        （4）Shell会读取脚本文件中的命令，并依次执行这些命令。\n        脚本启动模式适用于需要重复执行的一系列命令，可以将这些命令写入脚本文件中，并通过脚本文件来执行这些命令。此外，脚本启动模式还支持各种Shell的内置命令和选项。\n\n    3. 练习修改系统提示符: `vim ~/.bashrc` 中的PS1变量\n        ![1.Shell初识，编辑器使用-2023-04-19-19-21-30](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-19-21-30.png)\n\n4. Linux的文件系统结构\n    - Linux和Windows文件目录的比较\n    - Linux各目录的作用\n    - 遍历目录\n5. 文件目录相关命令\n    1. 文件权限\n        ![1.Shell初识，编辑器使用-2023-04-19-23-41-03](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-03.png)\n\n    2. **Linux基本文件和目录命令使用综合练习题**\n        1. 新建一个名为`test`的目录，进入该目录并新建一个名为`file.txt`的文件。\n        2. 将`file.txt`复制到`test`目录下，并将其重命名为`file2.txt`。\n        3. 在当前目录下，新建一个名为`newdir`的目录。\n        4. 将`file2.txt`移动到`newdir`目录下。\n        5. 在当前目录下，使用`touch`命令创建一个名为`empty.txt`的空文件。\n        6. 在`newdir`目录下，使用`find`命令查找以`.txt`结尾的文件，并将结果输出到名为`result.txt`的文件中。\n        7. 在`newdir`目录下，使用`chmod`命令将`file2.txt`的权限设置为只读。\n        8. 在当前目录下，使用`mkdir`命令递归创建一个名为`parent/child/grandchild`的目录树。\n\n        答案：\n\n        ```bash\n        #1\n        mkdir test\n        cd test\n        touch file.txt\n        \n        #2\n        cp file.txt file2.txt\n        \n        #3\n        mkdir newdir\n        \n        #4\n        mv file2.txt newdir/\n        \n        #5\n        touch empty.txt\n        \n        #6\n        cd newdir\n        find . -name \"*.txt\" -type f > result.txt\n        \n        #7\n        chmod 444 file2.txt\n        \n        #8\n        mkdir -p parent/child/grandchild\n        \n        ```\n\n6. VIM使用\n    1. 学习平台：\n\n        [VIM官方文档](https://yianwillis.github.io/vimcdoc/doc/intro.html#intro.txt)\n\n        [VIM基础练习平台](https://command-lab.com/cat-vim-ch-s/)\n\n        [VIM进阶](https://github.com/MeiTianT/vim-galore-zh_cn#%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84)\n\n        [vimgolf：国外VIM进阶练习](https://www.vimgolf.com/)\n\n    2. vim常用命令\n\n        ![1.Shell初识，编辑器使用-2023-04-19-23-41-33](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-33.png)\n","source":"_posts/linux_shell/1.Shell初识，编辑器使用.md","raw":"---\ntitle: Shell初始,编辑器使用\ndate: 2023-04-18 11:31:25\ntags: \n---\n\n```text\n虚拟机：ubuntu14045\n登录账号：llx\n密码：ubuntu\n```\n\n1. 什么是Shell\n    现在人们使用的操作系统（Windows、Android、iOS等）都带有图形界面，简单直观，容易上手。然而早期的计算机并没有图形界面，人们只能使用烦琐的命令来控制计算机。其实，真正能够控制计算机硬件（CPU、内存、显示器）的只有操作系统内核（Kernel），图形界面和命令行都是架设在用户和内核之间的桥梁，是为了方便用户控制计算机而存在的。由于安全等原因，用户不能直接接触内核，因此需要在用户和内核之间增加“命令解释器”，既能简化用户的操作，又能保障内核的安全。在Linux下的命令解释器叫作“Shell”，它能让用户更加高效、安全、低成本地使用Linux内核。\n    ![1.Shell初识，编辑器使用-2023-04-19-18-53-43](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-18-53-43.png)\n\n2. Shell的各种版本：\n    1. Bourne shell（sh）是Unix系统中最古老的shell，也是现在大多数shell的基础。它的命令行语法较为简单，缺乏一些高级特性，但是在大多数Unix系统中都内置了这个shell，因此可以保证可移植性。尽管Bourne shell已经被多种先进的shell所取代，但它作为shell编程的鼻祖，仍然具有重要的历史和学习价值。\n    2. Bourne Again Shell （bash）是Linux操作系统所使用的Shell，它是Bourne Shell的扩展，简称bash。bash与Bourne Shell完全向下兼容，也就是说bash可以兼容相同版本的Bourne Shell。bash在Bourne Shell的基础上增加、增强了很多特性，所以它比Bourne Shell能力更强。\n    3. zsh（Z shell）是Bourne shell（sh）的一个增强版本。与bash相比，zsh具有更好的命令补全功能、更好的主题和插件支持、更好的脚本语言、更好的历史命令管理和更好的可定制性。它还有许多其他功能，如自动提示，文件名扩展，别名扩展等。zsh是一种功能强大、易于使用和高度可定制的Shell，适用于任何需要使用命令行的用户。\n    4. 练习：查看Shell版本、更换默认Shell\n\n    ```bash\n\n    ##查看当前Shell版本\n    echo $SHELL\n    \n    ##查看系统当前可用Shell\n    cat /etc/shells\n    \n    ##更换默认Shell\n    chsh -s /bin/zsh\n    \n    ##退出当前登录状态重新登录\n    ```\n\n3. Shell的启动方式和提示符\n    1. 终端上启动\n        Shell会以交互模式启动，提示符会显示在屏幕上，等待用户输入命令。  \n        用户输入命令后，Shell会解释和执行这些命令，并将执行结果输出到终端上。  \n        在终端启动模式下，Shell会自动设置一些环境变量，如PATH等，以便用户可以方便地执行命令。\n\n    2. 脚本启动\n        脚本启动是将Shell命令写入一个脚本文件中，然后通过执行这个脚本文件来启动Shell。它的基本过程如下：\n        （1）创建一个包含Shell命令的脚本文件（通常以.sh作为扩展名）。\n        （2）将脚本文件保存到磁盘上，并赋予执行权限。\n        （3）在终端中输入脚本文件的路径，并按下回车键。\n        （4）Shell会读取脚本文件中的命令，并依次执行这些命令。\n        脚本启动模式适用于需要重复执行的一系列命令，可以将这些命令写入脚本文件中，并通过脚本文件来执行这些命令。此外，脚本启动模式还支持各种Shell的内置命令和选项。\n\n    3. 练习修改系统提示符: `vim ~/.bashrc` 中的PS1变量\n        ![1.Shell初识，编辑器使用-2023-04-19-19-21-30](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-19-21-30.png)\n\n4. Linux的文件系统结构\n    - Linux和Windows文件目录的比较\n    - Linux各目录的作用\n    - 遍历目录\n5. 文件目录相关命令\n    1. 文件权限\n        ![1.Shell初识，编辑器使用-2023-04-19-23-41-03](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-03.png)\n\n    2. **Linux基本文件和目录命令使用综合练习题**\n        1. 新建一个名为`test`的目录，进入该目录并新建一个名为`file.txt`的文件。\n        2. 将`file.txt`复制到`test`目录下，并将其重命名为`file2.txt`。\n        3. 在当前目录下，新建一个名为`newdir`的目录。\n        4. 将`file2.txt`移动到`newdir`目录下。\n        5. 在当前目录下，使用`touch`命令创建一个名为`empty.txt`的空文件。\n        6. 在`newdir`目录下，使用`find`命令查找以`.txt`结尾的文件，并将结果输出到名为`result.txt`的文件中。\n        7. 在`newdir`目录下，使用`chmod`命令将`file2.txt`的权限设置为只读。\n        8. 在当前目录下，使用`mkdir`命令递归创建一个名为`parent/child/grandchild`的目录树。\n\n        答案：\n\n        ```bash\n        #1\n        mkdir test\n        cd test\n        touch file.txt\n        \n        #2\n        cp file.txt file2.txt\n        \n        #3\n        mkdir newdir\n        \n        #4\n        mv file2.txt newdir/\n        \n        #5\n        touch empty.txt\n        \n        #6\n        cd newdir\n        find . -name \"*.txt\" -type f > result.txt\n        \n        #7\n        chmod 444 file2.txt\n        \n        #8\n        mkdir -p parent/child/grandchild\n        \n        ```\n\n6. VIM使用\n    1. 学习平台：\n\n        [VIM官方文档](https://yianwillis.github.io/vimcdoc/doc/intro.html#intro.txt)\n\n        [VIM基础练习平台](https://command-lab.com/cat-vim-ch-s/)\n\n        [VIM进阶](https://github.com/MeiTianT/vim-galore-zh_cn#%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84)\n\n        [vimgolf：国外VIM进阶练习](https://www.vimgolf.com/)\n\n    2. vim常用命令\n\n        ![1.Shell初识，编辑器使用-2023-04-19-23-41-33](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-33.png)\n","slug":"linux_shell/1.Shell初识，编辑器使用","published":1,"updated":"2023-06-13T12:47:11.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cliuf72w60001j1nz6tmn3imv","content":"<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">虚拟机：ubuntu14045</span><br><span class=\"line\">登录账号：llx</span><br><span class=\"line\">密码：ubuntu</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>什么是Shell<br> 现在人们使用的操作系统（Windows、Android、iOS等）都带有图形界面，简单直观，容易上手。然而早期的计算机并没有图形界面，人们只能使用烦琐的命令来控制计算机。其实，真正能够控制计算机硬件（CPU、内存、显示器）的只有操作系统内核（Kernel），图形界面和命令行都是架设在用户和内核之间的桥梁，是为了方便用户控制计算机而存在的。由于安全等原因，用户不能直接接触内核，因此需要在用户和内核之间增加“命令解释器”，既能简化用户的操作，又能保障内核的安全。在Linux下的命令解释器叫作“Shell”，它能让用户更加高效、安全、低成本地使用Linux内核。<br> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-18-53-43.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-18-53-43\"></p>\n</li>\n<li><p>Shell的各种版本：</p>\n<ol>\n<li>Bourne shell（sh）是Unix系统中最古老的shell，也是现在大多数shell的基础。它的命令行语法较为简单，缺乏一些高级特性，但是在大多数Unix系统中都内置了这个shell，因此可以保证可移植性。尽管Bourne shell已经被多种先进的shell所取代，但它作为shell编程的鼻祖，仍然具有重要的历史和学习价值。</li>\n<li>Bourne Again Shell （bash）是Linux操作系统所使用的Shell，它是Bourne Shell的扩展，简称bash。bash与Bourne Shell完全向下兼容，也就是说bash可以兼容相同版本的Bourne Shell。bash在Bourne Shell的基础上增加、增强了很多特性，所以它比Bourne Shell能力更强。</li>\n<li>zsh（Z shell）是Bourne shell（sh）的一个增强版本。与bash相比，zsh具有更好的命令补全功能、更好的主题和插件支持、更好的脚本语言、更好的历史命令管理和更好的可定制性。它还有许多其他功能，如自动提示，文件名扩展，别名扩展等。zsh是一种功能强大、易于使用和高度可定制的Shell，适用于任何需要使用命令行的用户。</li>\n<li>练习：查看Shell版本、更换默认Shell</li>\n</ol>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##查看当前Shell版本</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$SHELL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##查看系统当前可用Shell</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> /etc/shells</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##更换默认Shell</span></span><br><span class=\"line\">chsh -s /bin/zsh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##退出当前登录状态重新登录</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Shell的启动方式和提示符</p>\n<ol>\n<li><p>终端上启动<br> Shell会以交互模式启动，提示符会显示在屏幕上，等待用户输入命令。<br> 用户输入命令后，Shell会解释和执行这些命令，并将执行结果输出到终端上。<br> 在终端启动模式下，Shell会自动设置一些环境变量，如PATH等，以便用户可以方便地执行命令。</p>\n</li>\n<li><p>脚本启动<br> 脚本启动是将Shell命令写入一个脚本文件中，然后通过执行这个脚本文件来启动Shell。它的基本过程如下：<br> （1）创建一个包含Shell命令的脚本文件（通常以.sh作为扩展名）。<br> （2）将脚本文件保存到磁盘上，并赋予执行权限。<br> （3）在终端中输入脚本文件的路径，并按下回车键。<br> （4）Shell会读取脚本文件中的命令，并依次执行这些命令。<br> 脚本启动模式适用于需要重复执行的一系列命令，可以将这些命令写入脚本文件中，并通过脚本文件来执行这些命令。此外，脚本启动模式还支持各种Shell的内置命令和选项。</p>\n</li>\n<li><p>练习修改系统提示符: <code>vim ~/.bashrc</code> 中的PS1变量<br> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-19-21-30.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-19-21-30\"></p>\n</li>\n</ol>\n</li>\n<li><p>Linux的文件系统结构</p>\n<ul>\n<li>Linux和Windows文件目录的比较</li>\n<li>Linux各目录的作用</li>\n<li>遍历目录</li>\n</ul>\n</li>\n<li><p>文件目录相关命令</p>\n<ol>\n<li><p>文件权限<br> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-03.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-23-41-03\"></p>\n</li>\n<li><p><strong>Linux基本文件和目录命令使用综合练习题</strong></p>\n<ol>\n<li>新建一个名为<code>test</code>的目录，进入该目录并新建一个名为<code>file.txt</code>的文件。</li>\n<li>将<code>file.txt</code>复制到<code>test</code>目录下，并将其重命名为<code>file2.txt</code>。</li>\n<li>在当前目录下，新建一个名为<code>newdir</code>的目录。</li>\n<li>将<code>file2.txt</code>移动到<code>newdir</code>目录下。</li>\n<li>在当前目录下，使用<code>touch</code>命令创建一个名为<code>empty.txt</code>的空文件。</li>\n<li>在<code>newdir</code>目录下，使用<code>find</code>命令查找以<code>.txt</code>结尾的文件，并将结果输出到名为<code>result.txt</code>的文件中。</li>\n<li>在<code>newdir</code>目录下，使用<code>chmod</code>命令将<code>file2.txt</code>的权限设置为只读。</li>\n<li>在当前目录下，使用<code>mkdir</code>命令递归创建一个名为<code>parent/child/grandchild</code>的目录树。</li>\n</ol>\n<p> 答案：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#1</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"built_in\">touch</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> file.txt file2.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> newdir</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#4</span></span><br><span class=\"line\"><span class=\"built_in\">mv</span> file2.txt newdir/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#5</span></span><br><span class=\"line\"><span class=\"built_in\">touch</span> empty.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#6</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> newdir</span><br><span class=\"line\">find . -name <span class=\"string\">&quot;*.txt&quot;</span> -<span class=\"built_in\">type</span> f &gt; result.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#7</span></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> 444 file2.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#8</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p parent/child/grandchild</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>VIM使用</p>\n<ol>\n<li><p>学习平台：</p>\n<p> <a href=\"https://yianwillis.github.io/vimcdoc/doc/intro.html#intro.txt\">VIM官方文档</a></p>\n<p> <a href=\"https://command-lab.com/cat-vim-ch-s/\">VIM基础练习平台</a></p>\n<p> <a href=\"https://github.com/MeiTianT/vim-galore-zh_cn#%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84\">VIM进阶</a></p>\n<p> <a href=\"https://www.vimgolf.com/\">vimgolf：国外VIM进阶练习</a></p>\n</li>\n<li><p>vim常用命令</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-33.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-23-41-33\"></p>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">虚拟机：ubuntu14045</span><br><span class=\"line\">登录账号：llx</span><br><span class=\"line\">密码：ubuntu</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>什么是Shell<br> 现在人们使用的操作系统（Windows、Android、iOS等）都带有图形界面，简单直观，容易上手。然而早期的计算机并没有图形界面，人们只能使用烦琐的命令来控制计算机。其实，真正能够控制计算机硬件（CPU、内存、显示器）的只有操作系统内核（Kernel），图形界面和命令行都是架设在用户和内核之间的桥梁，是为了方便用户控制计算机而存在的。由于安全等原因，用户不能直接接触内核，因此需要在用户和内核之间增加“命令解释器”，既能简化用户的操作，又能保障内核的安全。在Linux下的命令解释器叫作“Shell”，它能让用户更加高效、安全、低成本地使用Linux内核。<br> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-18-53-43.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-18-53-43\"></p>\n</li>\n<li><p>Shell的各种版本：</p>\n<ol>\n<li>Bourne shell（sh）是Unix系统中最古老的shell，也是现在大多数shell的基础。它的命令行语法较为简单，缺乏一些高级特性，但是在大多数Unix系统中都内置了这个shell，因此可以保证可移植性。尽管Bourne shell已经被多种先进的shell所取代，但它作为shell编程的鼻祖，仍然具有重要的历史和学习价值。</li>\n<li>Bourne Again Shell （bash）是Linux操作系统所使用的Shell，它是Bourne Shell的扩展，简称bash。bash与Bourne Shell完全向下兼容，也就是说bash可以兼容相同版本的Bourne Shell。bash在Bourne Shell的基础上增加、增强了很多特性，所以它比Bourne Shell能力更强。</li>\n<li>zsh（Z shell）是Bourne shell（sh）的一个增强版本。与bash相比，zsh具有更好的命令补全功能、更好的主题和插件支持、更好的脚本语言、更好的历史命令管理和更好的可定制性。它还有许多其他功能，如自动提示，文件名扩展，别名扩展等。zsh是一种功能强大、易于使用和高度可定制的Shell，适用于任何需要使用命令行的用户。</li>\n<li>练习：查看Shell版本、更换默认Shell</li>\n</ol>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##查看当前Shell版本</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$SHELL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##查看系统当前可用Shell</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> /etc/shells</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##更换默认Shell</span></span><br><span class=\"line\">chsh -s /bin/zsh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##退出当前登录状态重新登录</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Shell的启动方式和提示符</p>\n<ol>\n<li><p>终端上启动<br> Shell会以交互模式启动，提示符会显示在屏幕上，等待用户输入命令。<br> 用户输入命令后，Shell会解释和执行这些命令，并将执行结果输出到终端上。<br> 在终端启动模式下，Shell会自动设置一些环境变量，如PATH等，以便用户可以方便地执行命令。</p>\n</li>\n<li><p>脚本启动<br> 脚本启动是将Shell命令写入一个脚本文件中，然后通过执行这个脚本文件来启动Shell。它的基本过程如下：<br> （1）创建一个包含Shell命令的脚本文件（通常以.sh作为扩展名）。<br> （2）将脚本文件保存到磁盘上，并赋予执行权限。<br> （3）在终端中输入脚本文件的路径，并按下回车键。<br> （4）Shell会读取脚本文件中的命令，并依次执行这些命令。<br> 脚本启动模式适用于需要重复执行的一系列命令，可以将这些命令写入脚本文件中，并通过脚本文件来执行这些命令。此外，脚本启动模式还支持各种Shell的内置命令和选项。</p>\n</li>\n<li><p>练习修改系统提示符: <code>vim ~/.bashrc</code> 中的PS1变量<br> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-19-21-30.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-19-21-30\"></p>\n</li>\n</ol>\n</li>\n<li><p>Linux的文件系统结构</p>\n<ul>\n<li>Linux和Windows文件目录的比较</li>\n<li>Linux各目录的作用</li>\n<li>遍历目录</li>\n</ul>\n</li>\n<li><p>文件目录相关命令</p>\n<ol>\n<li><p>文件权限<br> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-03.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-23-41-03\"></p>\n</li>\n<li><p><strong>Linux基本文件和目录命令使用综合练习题</strong></p>\n<ol>\n<li>新建一个名为<code>test</code>的目录，进入该目录并新建一个名为<code>file.txt</code>的文件。</li>\n<li>将<code>file.txt</code>复制到<code>test</code>目录下，并将其重命名为<code>file2.txt</code>。</li>\n<li>在当前目录下，新建一个名为<code>newdir</code>的目录。</li>\n<li>将<code>file2.txt</code>移动到<code>newdir</code>目录下。</li>\n<li>在当前目录下，使用<code>touch</code>命令创建一个名为<code>empty.txt</code>的空文件。</li>\n<li>在<code>newdir</code>目录下，使用<code>find</code>命令查找以<code>.txt</code>结尾的文件，并将结果输出到名为<code>result.txt</code>的文件中。</li>\n<li>在<code>newdir</code>目录下，使用<code>chmod</code>命令将<code>file2.txt</code>的权限设置为只读。</li>\n<li>在当前目录下，使用<code>mkdir</code>命令递归创建一个名为<code>parent/child/grandchild</code>的目录树。</li>\n</ol>\n<p> 答案：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#1</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"built_in\">touch</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> file.txt file2.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> newdir</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#4</span></span><br><span class=\"line\"><span class=\"built_in\">mv</span> file2.txt newdir/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#5</span></span><br><span class=\"line\"><span class=\"built_in\">touch</span> empty.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#6</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> newdir</span><br><span class=\"line\">find . -name <span class=\"string\">&quot;*.txt&quot;</span> -<span class=\"built_in\">type</span> f &gt; result.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#7</span></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> 444 file2.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#8</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p parent/child/grandchild</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>VIM使用</p>\n<ol>\n<li><p>学习平台：</p>\n<p> <a href=\"https://yianwillis.github.io/vimcdoc/doc/intro.html#intro.txt\">VIM官方文档</a></p>\n<p> <a href=\"https://command-lab.com/cat-vim-ch-s/\">VIM基础练习平台</a></p>\n<p> <a href=\"https://github.com/MeiTianT/vim-galore-zh_cn#%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84\">VIM进阶</a></p>\n<p> <a href=\"https://www.vimgolf.com/\">vimgolf：国外VIM进阶练习</a></p>\n</li>\n<li><p>vim常用命令</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-33.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-23-41-33\"></p>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"文本处理工具awk","date":"2023-04-23T05:26:57.000Z","_content":"\n## awk简介\n\nawk是一种用于处理文本数据的工具，可以从文本文件或者标准输入、一个或多个文件中提取和处理数据。\nawk以逐行扫描方式处理数据，从第一行到最后一行以查找匹配某个特定模式的文本行，并且对这些文本行执行指定动作。\n\n## awk版本\n\nawk有众多版本包括传统awk、新版awk、gawk等，其中gawk是GNU组织开发的版本，也是目前最流行和最广泛使用的awk版本。gawk在传统awk和nawk的基础上添加了许多新功能和改进，例如更丰富的正则表达式支持、高级的数学和字符串处理函数、用户自定义函数等。gawk通常作为`/bin/gawk`或`/usr/bin/gawk`提供，是GNU工具集中的一部分，可以在多个平台上使用。\n不同的awk可能在语法、功能和性能方面略有不同，在使用awk时应注意选择合适的版本，根据具体需求和系统环境来决定使用哪个版本。\n\n## awk格式\n\nawk基本格式如下：\n\n```text\nawk 'pattern { action }' file\nawk '{ action }' file\nawk 'pattern' file\n```\n\n* `pattern`: 可以是一个正则表达式，也可以是一个字符串或数字，用于匹配文本中的某个字段或整行\n* `action`: 是在匹配到的文本上执行的操作，可以是一个或多个命令，多个命令之间用换行或分号 `;` 分隔\n* `file`: 是输入文件的名称，没有`file`参数时从标准输入读取数据\n\n在awk命令中，`pattern`和`action`之间通过大括号 `{}` 进行分隔，`pattern`用于匹配文本行，当匹配成功时，对应的`action`将被执行。\n\nawk还支持在处理数据前和处理数据后运行命令，完整格式如下：\n\n```text\nawk 'BEGIN {command} pattern { action } END {command}' file\n```\n\n```sh\necho \"10 20 30 40 50\" | awk 'BEGIN {sum = 0; print \"sum:\", sum} {sum += $1} END {print \"Sum:\", sum}'\n```\n\n![10.text-processing-tools-awk-2023-04-24-09-42-32](https://raw.githubusercontent.com/yefreee/picture/main/note10.text-processing-tools-awk-2023-04-24-09-42-32.png)\n\n## 从标准输入读取数据\n\n### 从命令行读取数据\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Hello World\"}'\ntest\nHello World\nabc\nHello World\n```\n\n以上awk命令没有指定`file`参数，awk不会直接给出运行结果，它会等待标准输入的数据，当用户输入字符后awk会执行相应的命令并产生输出。如果要终止awk程序需要使用`Ctrl+D`产生一个EOF字符，此时会返回到命令行下。\n\n### 通过管道符号从命令读取数据\n\n```sh\nubuntu@6e455ed15da7:~$ ps -aux|awk '/bash/'\nroot           1  0.0  0.0  18228  3012 pts/0    Ss+  Apr22   0:00 /bin/bash\nroot          11  0.0  0.0  18232  3240 pts/1    Ss   13:36   0:00 /bin/bash\nubuntu       269  0.0  0.0  18228  3144 pts/1    S    13:39   0:00 bash\n```\n\n以上awk命令通过管道符号`|`从前面一个命令的输出结果从读取数据进行处理。\n\n## 从文件中读取数据和命令\n\n```sh\nubuntu@6e455ed15da7:~$ awk '/Alice/' example.txt\nAlice,25,Female,New York\nubuntu@6e455ed15da7:~$ awk '/Male/' example.txt\nBob,30,Male,Los Angeles\nCharlie,22,Male,Chicago\nDavid,35,Male,Houston\n```\n\n以上awk命令指定了`file`参数，awk会从文件中以行为单位读取数据并且使用`pattern`所表示的匹配模式进行数据匹配，由于没有指定`action`参数，awk将匹配到的数据直接输出到标准输出。\n\nawk和sed一样可以从文件中读取命令：\n\n```sh\nawk -f script_file.awk example.txt\n```\n\n## awk工作原理\n\n1. awk对文件或者标准输入的内容一次只处理一行，将获取到的这一行数据赋给变量$0\n2. 这一行的内容按awk内部变量FS定义的分隔符（缺省为空格，包括制表符tab）分解成多个字段，每一个字段存储在从$1开始的变量中。\n\n以以下数据为例：\n\n```text\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\n```\n\n以下awk命令的运行结果：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print $1,$3}' example.txt\nName Gender\nAlice Female\nBob Male\nCharlie Male\nDavid Male\nEve Female\n```\n\n1. awk首先将第一行数据存放在变量$0中进行处理。\n2. 将`$0`中的数据以空格为分隔符（内部变量`FS`所定义）进行分解，分别存放在从`$1`开始的内部变量中。\n3. 在输出结果的每一行中第一个字段是存放在`$1`中的数据，第二个字段是存放在`$3`中的数据。\n4. awk命令中的逗号映射为一个内部变量-输出字段分隔符`OFS`（默认为空格）两个字段之间由空格间隔。\n5. 处理完一行数据后读取下一行数据到`$0`中进行处理直到所以数据处理完毕。\n\n## 格式化输出\n\n### print函数\n\nprint函数用于打印不需要特别编排格式的简单输出。\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1 \"Age:\" $2}' example.txt\nName:NameAge:Age\nName:AliceAge:25\nName:BobAge:30\nName:CharlieAge:22\nName:DavidAge:35\nName:EveAge:28\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1, \"Age:\" $2}' example.txt\nName:Name Age:Age\nName:Alice Age:25\nName:Bob Age:30\nName:Charlie Age:22\nName:David Age:35\nName:Eve Age:28\n```\n\n逗号`,`表示内部变量`OFS`（用来表示输出字段的分隔符，默认为空格）。\nprint还支持以下转义序列：\n\n```text\n\\b：退格符（ASCII 008）\n\\t：制表符（ASCII 009）\n\\n：换行符（ASCII 010）\n\\f：换页符（ASCII 012）\n\\r：回车符（ASCII 013）\n```\n\nprint中使用转义序列进行数据输出：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1 \"\\tAge:\" $2}' example.txt\nName:Name       Age:Age\nName:Alice      Age:25\nName:Bob        Age:30\nName:Charlie    Age:22\nName:David      Age:35\nName:Eve        Age:28\n```\n\n### printf函数\n\n`printf`函数能够进行更加精细的格式化输出，用法和C语言中`printf`函数的用法一样。语句中包含一个加引号的控制串，控制串中包含若干格式说明和修饰符。控制串后面跟一个逗号，之后是一列由逗号分隔的表达式。`printf`会根据控制串来编排表达式的格式。\n`printf`和`print`不同的是printf在行尾不会自动换行，如果要换行必须使用转义字符`\\n`\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{printf \"[Name:%-10s]\\tAge:%s\", $1, $2}' example.txt\n[Name:Name      ]       Age:Age[Name:Alice     ]        Age:25[Name:Bob       ] Age:30[Name:Charlie   ]      Age:22[Name:David     ] Age:35[Name:Eve       ] Age:28ubuntu@6e455ed15da7:~$ awk '{printf \"[Name:%-10s]\\tAge:%s\\n\", $1, $2}' example.txt\n[Name:Name      ]       Age:Age\n[Name:Alice     ]       Age:25\n[Name:Bob       ]       Age:30\n[Name:Charlie   ]       Age:22\n[Name:David     ]       Age:35\n[Name:Eve       ]       Age:28\n```\n\n## 记录与字段\n\n### 记录\n\n在awk中每一行数据称为一条记录，以换行符结束。\n\n* 记录分隔符：默认情况下，输入和输出记录的分隔符都是回车符，分别保存在内部变量`ORS`和`RS`中。\n* 变量`$0`表示当前整条记录，变量NR表示当前记录的记录号，每处理一条记录，NR值加一。\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print NR,$0}' example.txt\n1 Name Age Gender City\n2 Alice 25 Female New York\n3 Bob 30 Male Los Angeles\n4 Charlie 22 Male Chicago\n5 David 35 Male Houston\n6 Eve 28 Female Miami\n```\n\n### 字段\n\n每一条记录都是由称为字段的词组成，默认情况下字段之间用空白符（空格或者制表符）分隔。`NF`变量保存每个记录的字段数量。\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print NF,$0}' example.txt\n4 Name Age Gender City\n5 Alice 25 Female New York\n5 Bob 30 Male Los Angeles\n4 Charlie 22 Male Chicago\n4 David 35 Male Houston\n4 Eve 28 Female Miami\n```\n\n### 字段分隔符\n\n字段分隔符由内部变量`FS`保存，可以在命令中通过`-F`选项修改`FS`的值。\n先使用`sed`命令将`example.txt`文件中的空格替换为逗号：\n\n```sh\nubuntu@6e455ed15da7:~$ sed -i 's/ /,/g' example.txt\nubuntu@6e455ed15da7:~$ cat example.txt\nName,Age,Gender,City\nAlice,25,Female,New,York\nBob,30,Male,Los,Angeles\nCharlie,22,Male,Chicago\nDavid,35,Male,Houston\nEve,28,Female,Miami\n```\n\n然后使用awk并通过`-F`选项替换分隔符进行输出：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1, \"Age:\" $2}' example.txt\nName:Name,Age,Gender,City Age:\nName:Alice,25,Female,New,York Age:\nName:Bob,30,Male,Los,Angeles Age:\nName:Charlie,22,Male,Chicago Age:\nName:David,35,Male,Houston Age:\nName:Eve,28,Female,Miami Age:\nubuntu@6e455ed15da7:~$ awk -F, '{print \"Name:\" $1, \"Age:\" $2}' example.txt\nName:Name Age:Age\nName:Alice Age:25\nName:Bob Age:30\nName:Charlie Age:22\nName:David Age:35\nName:Eve Age:28\n```\n\n## 匹配模式与正则表达式\n\n### 匹配模式\n\nawk中的模式可以是一个正则表达式或者用来判定条件真伪的表达式。\n\n使用`Alice`进行数据匹配：\n```sh\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '/Alice/' example.txt\nAlice 25 Female New York\n```\n\n使用条件表达式进行数据匹配：\n\n```sh\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '$2 < 25' example.txt\nCharlie 22 Male Chicago\n```\n\n### 正则表达式模式与操作\n\n使用正则表达式模式`Alice`进行数据匹配，然后通过`print`函数进行格式化输出：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '/Alice/{print \"Name:\" $1}' example.txt\nName:Alice\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '/Alice/{print \"Name:\" $1}' example.txt\nName:Alice\n```\n\n格式化输出`example.txt`文件中所有以大写字母`A-C`开头的行：\n\n```sh\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '/^[A-C]+.*/{print \"Name:\" $1}' example.txt\nName:Alice\nName:Bob\nName:Charlie\n```\n\n## 练习\n\n### 显示系统下各用户所使用的shell\n\n查看当前`/etc/passwd`格式：\n\n```sh\nubuntu@6e455ed15da7:~$ cat /etc/passwd|head\nroot:x:0:0:root:/root:/bin/bash\n```\n\n使用awk显示各用户使用的shell:\n\n```sh\nUser:root Shell:/bin/bash\nUser:daemon Shell:/usr/sbin/nologin\nUser:bin Shell:/usr/sbin/nologin\nUser:sys Shell:/usr/sbin/nologin\nUser:sync Shell:/bin/sync\nUser:games Shell:/usr/sbin/nologin\nUser:man Shell:/usr/sbin/nologin\nUser:lp Shell:/usr/sbin/nologin\nUser:mail Shell:/usr/sbin/nologin\nUser:news Shell:/usr/sbin/nologin\n```","source":"_posts/linux_shell/10.text-processing-tools-awk.md","raw":"---\ntitle: 文本处理工具awk \ndate: 2023-04-23 13:26:57\ntags:\n---\n\n## awk简介\n\nawk是一种用于处理文本数据的工具，可以从文本文件或者标准输入、一个或多个文件中提取和处理数据。\nawk以逐行扫描方式处理数据，从第一行到最后一行以查找匹配某个特定模式的文本行，并且对这些文本行执行指定动作。\n\n## awk版本\n\nawk有众多版本包括传统awk、新版awk、gawk等，其中gawk是GNU组织开发的版本，也是目前最流行和最广泛使用的awk版本。gawk在传统awk和nawk的基础上添加了许多新功能和改进，例如更丰富的正则表达式支持、高级的数学和字符串处理函数、用户自定义函数等。gawk通常作为`/bin/gawk`或`/usr/bin/gawk`提供，是GNU工具集中的一部分，可以在多个平台上使用。\n不同的awk可能在语法、功能和性能方面略有不同，在使用awk时应注意选择合适的版本，根据具体需求和系统环境来决定使用哪个版本。\n\n## awk格式\n\nawk基本格式如下：\n\n```text\nawk 'pattern { action }' file\nawk '{ action }' file\nawk 'pattern' file\n```\n\n* `pattern`: 可以是一个正则表达式，也可以是一个字符串或数字，用于匹配文本中的某个字段或整行\n* `action`: 是在匹配到的文本上执行的操作，可以是一个或多个命令，多个命令之间用换行或分号 `;` 分隔\n* `file`: 是输入文件的名称，没有`file`参数时从标准输入读取数据\n\n在awk命令中，`pattern`和`action`之间通过大括号 `{}` 进行分隔，`pattern`用于匹配文本行，当匹配成功时，对应的`action`将被执行。\n\nawk还支持在处理数据前和处理数据后运行命令，完整格式如下：\n\n```text\nawk 'BEGIN {command} pattern { action } END {command}' file\n```\n\n```sh\necho \"10 20 30 40 50\" | awk 'BEGIN {sum = 0; print \"sum:\", sum} {sum += $1} END {print \"Sum:\", sum}'\n```\n\n![10.text-processing-tools-awk-2023-04-24-09-42-32](https://raw.githubusercontent.com/yefreee/picture/main/note10.text-processing-tools-awk-2023-04-24-09-42-32.png)\n\n## 从标准输入读取数据\n\n### 从命令行读取数据\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Hello World\"}'\ntest\nHello World\nabc\nHello World\n```\n\n以上awk命令没有指定`file`参数，awk不会直接给出运行结果，它会等待标准输入的数据，当用户输入字符后awk会执行相应的命令并产生输出。如果要终止awk程序需要使用`Ctrl+D`产生一个EOF字符，此时会返回到命令行下。\n\n### 通过管道符号从命令读取数据\n\n```sh\nubuntu@6e455ed15da7:~$ ps -aux|awk '/bash/'\nroot           1  0.0  0.0  18228  3012 pts/0    Ss+  Apr22   0:00 /bin/bash\nroot          11  0.0  0.0  18232  3240 pts/1    Ss   13:36   0:00 /bin/bash\nubuntu       269  0.0  0.0  18228  3144 pts/1    S    13:39   0:00 bash\n```\n\n以上awk命令通过管道符号`|`从前面一个命令的输出结果从读取数据进行处理。\n\n## 从文件中读取数据和命令\n\n```sh\nubuntu@6e455ed15da7:~$ awk '/Alice/' example.txt\nAlice,25,Female,New York\nubuntu@6e455ed15da7:~$ awk '/Male/' example.txt\nBob,30,Male,Los Angeles\nCharlie,22,Male,Chicago\nDavid,35,Male,Houston\n```\n\n以上awk命令指定了`file`参数，awk会从文件中以行为单位读取数据并且使用`pattern`所表示的匹配模式进行数据匹配，由于没有指定`action`参数，awk将匹配到的数据直接输出到标准输出。\n\nawk和sed一样可以从文件中读取命令：\n\n```sh\nawk -f script_file.awk example.txt\n```\n\n## awk工作原理\n\n1. awk对文件或者标准输入的内容一次只处理一行，将获取到的这一行数据赋给变量$0\n2. 这一行的内容按awk内部变量FS定义的分隔符（缺省为空格，包括制表符tab）分解成多个字段，每一个字段存储在从$1开始的变量中。\n\n以以下数据为例：\n\n```text\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\n```\n\n以下awk命令的运行结果：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print $1,$3}' example.txt\nName Gender\nAlice Female\nBob Male\nCharlie Male\nDavid Male\nEve Female\n```\n\n1. awk首先将第一行数据存放在变量$0中进行处理。\n2. 将`$0`中的数据以空格为分隔符（内部变量`FS`所定义）进行分解，分别存放在从`$1`开始的内部变量中。\n3. 在输出结果的每一行中第一个字段是存放在`$1`中的数据，第二个字段是存放在`$3`中的数据。\n4. awk命令中的逗号映射为一个内部变量-输出字段分隔符`OFS`（默认为空格）两个字段之间由空格间隔。\n5. 处理完一行数据后读取下一行数据到`$0`中进行处理直到所以数据处理完毕。\n\n## 格式化输出\n\n### print函数\n\nprint函数用于打印不需要特别编排格式的简单输出。\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1 \"Age:\" $2}' example.txt\nName:NameAge:Age\nName:AliceAge:25\nName:BobAge:30\nName:CharlieAge:22\nName:DavidAge:35\nName:EveAge:28\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1, \"Age:\" $2}' example.txt\nName:Name Age:Age\nName:Alice Age:25\nName:Bob Age:30\nName:Charlie Age:22\nName:David Age:35\nName:Eve Age:28\n```\n\n逗号`,`表示内部变量`OFS`（用来表示输出字段的分隔符，默认为空格）。\nprint还支持以下转义序列：\n\n```text\n\\b：退格符（ASCII 008）\n\\t：制表符（ASCII 009）\n\\n：换行符（ASCII 010）\n\\f：换页符（ASCII 012）\n\\r：回车符（ASCII 013）\n```\n\nprint中使用转义序列进行数据输出：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1 \"\\tAge:\" $2}' example.txt\nName:Name       Age:Age\nName:Alice      Age:25\nName:Bob        Age:30\nName:Charlie    Age:22\nName:David      Age:35\nName:Eve        Age:28\n```\n\n### printf函数\n\n`printf`函数能够进行更加精细的格式化输出，用法和C语言中`printf`函数的用法一样。语句中包含一个加引号的控制串，控制串中包含若干格式说明和修饰符。控制串后面跟一个逗号，之后是一列由逗号分隔的表达式。`printf`会根据控制串来编排表达式的格式。\n`printf`和`print`不同的是printf在行尾不会自动换行，如果要换行必须使用转义字符`\\n`\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{printf \"[Name:%-10s]\\tAge:%s\", $1, $2}' example.txt\n[Name:Name      ]       Age:Age[Name:Alice     ]        Age:25[Name:Bob       ] Age:30[Name:Charlie   ]      Age:22[Name:David     ] Age:35[Name:Eve       ] Age:28ubuntu@6e455ed15da7:~$ awk '{printf \"[Name:%-10s]\\tAge:%s\\n\", $1, $2}' example.txt\n[Name:Name      ]       Age:Age\n[Name:Alice     ]       Age:25\n[Name:Bob       ]       Age:30\n[Name:Charlie   ]       Age:22\n[Name:David     ]       Age:35\n[Name:Eve       ]       Age:28\n```\n\n## 记录与字段\n\n### 记录\n\n在awk中每一行数据称为一条记录，以换行符结束。\n\n* 记录分隔符：默认情况下，输入和输出记录的分隔符都是回车符，分别保存在内部变量`ORS`和`RS`中。\n* 变量`$0`表示当前整条记录，变量NR表示当前记录的记录号，每处理一条记录，NR值加一。\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print NR,$0}' example.txt\n1 Name Age Gender City\n2 Alice 25 Female New York\n3 Bob 30 Male Los Angeles\n4 Charlie 22 Male Chicago\n5 David 35 Male Houston\n6 Eve 28 Female Miami\n```\n\n### 字段\n\n每一条记录都是由称为字段的词组成，默认情况下字段之间用空白符（空格或者制表符）分隔。`NF`变量保存每个记录的字段数量。\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print NF,$0}' example.txt\n4 Name Age Gender City\n5 Alice 25 Female New York\n5 Bob 30 Male Los Angeles\n4 Charlie 22 Male Chicago\n4 David 35 Male Houston\n4 Eve 28 Female Miami\n```\n\n### 字段分隔符\n\n字段分隔符由内部变量`FS`保存，可以在命令中通过`-F`选项修改`FS`的值。\n先使用`sed`命令将`example.txt`文件中的空格替换为逗号：\n\n```sh\nubuntu@6e455ed15da7:~$ sed -i 's/ /,/g' example.txt\nubuntu@6e455ed15da7:~$ cat example.txt\nName,Age,Gender,City\nAlice,25,Female,New,York\nBob,30,Male,Los,Angeles\nCharlie,22,Male,Chicago\nDavid,35,Male,Houston\nEve,28,Female,Miami\n```\n\n然后使用awk并通过`-F`选项替换分隔符进行输出：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1, \"Age:\" $2}' example.txt\nName:Name,Age,Gender,City Age:\nName:Alice,25,Female,New,York Age:\nName:Bob,30,Male,Los,Angeles Age:\nName:Charlie,22,Male,Chicago Age:\nName:David,35,Male,Houston Age:\nName:Eve,28,Female,Miami Age:\nubuntu@6e455ed15da7:~$ awk -F, '{print \"Name:\" $1, \"Age:\" $2}' example.txt\nName:Name Age:Age\nName:Alice Age:25\nName:Bob Age:30\nName:Charlie Age:22\nName:David Age:35\nName:Eve Age:28\n```\n\n## 匹配模式与正则表达式\n\n### 匹配模式\n\nawk中的模式可以是一个正则表达式或者用来判定条件真伪的表达式。\n\n使用`Alice`进行数据匹配：\n```sh\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '/Alice/' example.txt\nAlice 25 Female New York\n```\n\n使用条件表达式进行数据匹配：\n\n```sh\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '$2 < 25' example.txt\nCharlie 22 Male Chicago\n```\n\n### 正则表达式模式与操作\n\n使用正则表达式模式`Alice`进行数据匹配，然后通过`print`函数进行格式化输出：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '/Alice/{print \"Name:\" $1}' example.txt\nName:Alice\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '/Alice/{print \"Name:\" $1}' example.txt\nName:Alice\n```\n\n格式化输出`example.txt`文件中所有以大写字母`A-C`开头的行：\n\n```sh\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '/^[A-C]+.*/{print \"Name:\" $1}' example.txt\nName:Alice\nName:Bob\nName:Charlie\n```\n\n## 练习\n\n### 显示系统下各用户所使用的shell\n\n查看当前`/etc/passwd`格式：\n\n```sh\nubuntu@6e455ed15da7:~$ cat /etc/passwd|head\nroot:x:0:0:root:/root:/bin/bash\n```\n\n使用awk显示各用户使用的shell:\n\n```sh\nUser:root Shell:/bin/bash\nUser:daemon Shell:/usr/sbin/nologin\nUser:bin Shell:/usr/sbin/nologin\nUser:sys Shell:/usr/sbin/nologin\nUser:sync Shell:/bin/sync\nUser:games Shell:/usr/sbin/nologin\nUser:man Shell:/usr/sbin/nologin\nUser:lp Shell:/usr/sbin/nologin\nUser:mail Shell:/usr/sbin/nologin\nUser:news Shell:/usr/sbin/nologin\n```","slug":"linux_shell/10.text-processing-tools-awk","published":1,"updated":"2023-06-10T08:09:30.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cliuf72w90002j1nzemc8g1b3","content":"<h2 id=\"awk简介\"><a href=\"#awk简介\" class=\"headerlink\" title=\"awk简介\"></a>awk简介</h2><p>awk是一种用于处理文本数据的工具，可以从文本文件或者标准输入、一个或多个文件中提取和处理数据。<br>awk以逐行扫描方式处理数据，从第一行到最后一行以查找匹配某个特定模式的文本行，并且对这些文本行执行指定动作。</p>\n<h2 id=\"awk版本\"><a href=\"#awk版本\" class=\"headerlink\" title=\"awk版本\"></a>awk版本</h2><p>awk有众多版本包括传统awk、新版awk、gawk等，其中gawk是GNU组织开发的版本，也是目前最流行和最广泛使用的awk版本。gawk在传统awk和nawk的基础上添加了许多新功能和改进，例如更丰富的正则表达式支持、高级的数学和字符串处理函数、用户自定义函数等。gawk通常作为<code>/bin/gawk</code>或<code>/usr/bin/gawk</code>提供，是GNU工具集中的一部分，可以在多个平台上使用。<br>不同的awk可能在语法、功能和性能方面略有不同，在使用awk时应注意选择合适的版本，根据具体需求和系统环境来决定使用哪个版本。</p>\n<h2 id=\"awk格式\"><a href=\"#awk格式\" class=\"headerlink\" title=\"awk格式\"></a>awk格式</h2><p>awk基本格式如下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;pattern &#123; action &#125;&#x27; file</span><br><span class=\"line\">awk &#x27;&#123; action &#125;&#x27; file</span><br><span class=\"line\">awk &#x27;pattern&#x27; file</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>pattern</code>: 可以是一个正则表达式，也可以是一个字符串或数字，用于匹配文本中的某个字段或整行</li>\n<li><code>action</code>: 是在匹配到的文本上执行的操作，可以是一个或多个命令，多个命令之间用换行或分号 <code>;</code> 分隔</li>\n<li><code>file</code>: 是输入文件的名称，没有<code>file</code>参数时从标准输入读取数据</li>\n</ul>\n<p>在awk命令中，<code>pattern</code>和<code>action</code>之间通过大括号 <code>&#123;&#125;</code> 进行分隔，<code>pattern</code>用于匹配文本行，当匹配成功时，对应的<code>action</code>将被执行。</p>\n<p>awk还支持在处理数据前和处理数据后运行命令，完整格式如下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;BEGIN &#123;command&#125; pattern &#123; action &#125; END &#123;command&#125;&#x27; file</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;10 20 30 40 50&quot;</span> | awk <span class=\"string\">&#x27;BEGIN &#123;sum = 0; print &quot;sum:&quot;, sum&#125; &#123;sum += $1&#125; END &#123;print &quot;Sum:&quot;, sum&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note10.text-processing-tools-awk-2023-04-24-09-42-32.png\" alt=\"10.text-processing-tools-awk-2023-04-24-09-42-32\"></p>\n<h2 id=\"从标准输入读取数据\"><a href=\"#从标准输入读取数据\" class=\"headerlink\" title=\"从标准输入读取数据\"></a>从标准输入读取数据</h2><h3 id=\"从命令行读取数据\"><a href=\"#从命令行读取数据\" class=\"headerlink\" title=\"从命令行读取数据\"></a>从命令行读取数据</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print &quot;Hello World&quot;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">test</span></span><br><span class=\"line\">Hello World</span><br><span class=\"line\">abc</span><br><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n\n<p>以上awk命令没有指定<code>file</code>参数，awk不会直接给出运行结果，它会等待标准输入的数据，当用户输入字符后awk会执行相应的命令并产生输出。如果要终止awk程序需要使用<code>Ctrl+D</code>产生一个EOF字符，此时会返回到命令行下。</p>\n<h3 id=\"通过管道符号从命令读取数据\"><a href=\"#通过管道符号从命令读取数据\" class=\"headerlink\" title=\"通过管道符号从命令读取数据\"></a>通过管道符号从命令读取数据</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ ps -aux|awk <span class=\"string\">&#x27;/bash/&#x27;</span></span><br><span class=\"line\">root           1  0.0  0.0  18228  3012 pts/0    Ss+  Apr22   0:00 /bin/bash</span><br><span class=\"line\">root          11  0.0  0.0  18232  3240 pts/1    Ss   13:36   0:00 /bin/bash</span><br><span class=\"line\">ubuntu       269  0.0  0.0  18228  3144 pts/1    S    13:39   0:00 bash</span><br></pre></td></tr></table></figure>\n\n<p>以上awk命令通过管道符号<code>|</code>从前面一个命令的输出结果从读取数据进行处理。</p>\n<h2 id=\"从文件中读取数据和命令\"><a href=\"#从文件中读取数据和命令\" class=\"headerlink\" title=\"从文件中读取数据和命令\"></a>从文件中读取数据和命令</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;/Alice/&#x27;</span> example.txt</span><br><span class=\"line\">Alice,25,Female,New York</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;/Male/&#x27;</span> example.txt</span><br><span class=\"line\">Bob,30,Male,Los Angeles</span><br><span class=\"line\">Charlie,22,Male,Chicago</span><br><span class=\"line\">David,35,Male,Houston</span><br></pre></td></tr></table></figure>\n\n<p>以上awk命令指定了<code>file</code>参数，awk会从文件中以行为单位读取数据并且使用<code>pattern</code>所表示的匹配模式进行数据匹配，由于没有指定<code>action</code>参数，awk将匹配到的数据直接输出到标准输出。</p>\n<p>awk和sed一样可以从文件中读取命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk -f script_file.awk example.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"awk工作原理\"><a href=\"#awk工作原理\" class=\"headerlink\" title=\"awk工作原理\"></a>awk工作原理</h2><ol>\n<li>awk对文件或者标准输入的内容一次只处理一行，将获取到的这一行数据赋给变量$0</li>\n<li>这一行的内容按awk内部变量FS定义的分隔符（缺省为空格，包括制表符tab）分解成多个字段，每一个字段存储在从$1开始的变量中。</li>\n</ol>\n<p>以以下数据为例：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Name Age Gender City</span><br><span class=\"line\">Alice 25 Female New York</span><br><span class=\"line\">Bob 30 Male Los Angeles</span><br><span class=\"line\">Charlie 22 Male Chicago</span><br><span class=\"line\">David 35 Male Houston</span><br><span class=\"line\">Eve 28 Female Miami</span><br></pre></td></tr></table></figure>\n\n<p>以下awk命令的运行结果：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print $1,$3&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name Gender</span><br><span class=\"line\">Alice Female</span><br><span class=\"line\">Bob Male</span><br><span class=\"line\">Charlie Male</span><br><span class=\"line\">David Male</span><br><span class=\"line\">Eve Female</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>awk首先将第一行数据存放在变量$0中进行处理。</li>\n<li>将<code>$0</code>中的数据以空格为分隔符（内部变量<code>FS</code>所定义）进行分解，分别存放在从<code>$1</code>开始的内部变量中。</li>\n<li>在输出结果的每一行中第一个字段是存放在<code>$1</code>中的数据，第二个字段是存放在<code>$3</code>中的数据。</li>\n<li>awk命令中的逗号映射为一个内部变量-输出字段分隔符<code>OFS</code>（默认为空格）两个字段之间由空格间隔。</li>\n<li>处理完一行数据后读取下一行数据到<code>$0</code>中进行处理直到所以数据处理完毕。</li>\n</ol>\n<h2 id=\"格式化输出\"><a href=\"#格式化输出\" class=\"headerlink\" title=\"格式化输出\"></a>格式化输出</h2><h3 id=\"print函数\"><a href=\"#print函数\" class=\"headerlink\" title=\"print函数\"></a>print函数</h3><p>print函数用于打印不需要特别编排格式的简单输出。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print &quot;Name:&quot; $1 &quot;Age:&quot; $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:NameAge:Age</span><br><span class=\"line\">Name:AliceAge:25</span><br><span class=\"line\">Name:BobAge:30</span><br><span class=\"line\">Name:CharlieAge:22</span><br><span class=\"line\">Name:DavidAge:35</span><br><span class=\"line\">Name:EveAge:28</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print &quot;Name:&quot; $1, &quot;Age:&quot; $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Name Age:Age</span><br><span class=\"line\">Name:Alice Age:25</span><br><span class=\"line\">Name:Bob Age:30</span><br><span class=\"line\">Name:Charlie Age:22</span><br><span class=\"line\">Name:David Age:35</span><br><span class=\"line\">Name:Eve Age:28</span><br></pre></td></tr></table></figure>\n\n<p>逗号<code>,</code>表示内部变量<code>OFS</code>（用来表示输出字段的分隔符，默认为空格）。<br>print还支持以下转义序列：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\b：退格符（ASCII 008）</span><br><span class=\"line\">\\t：制表符（ASCII 009）</span><br><span class=\"line\">\\n：换行符（ASCII 010）</span><br><span class=\"line\">\\f：换页符（ASCII 012）</span><br><span class=\"line\">\\r：回车符（ASCII 013）</span><br></pre></td></tr></table></figure>\n\n<p>print中使用转义序列进行数据输出：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print &quot;Name:&quot; $1 &quot;\\tAge:&quot; $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Name       Age:Age</span><br><span class=\"line\">Name:Alice      Age:25</span><br><span class=\"line\">Name:Bob        Age:30</span><br><span class=\"line\">Name:Charlie    Age:22</span><br><span class=\"line\">Name:David      Age:35</span><br><span class=\"line\">Name:Eve        Age:28</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"printf函数\"><a href=\"#printf函数\" class=\"headerlink\" title=\"printf函数\"></a>printf函数</h3><p><code>printf</code>函数能够进行更加精细的格式化输出，用法和C语言中<code>printf</code>函数的用法一样。语句中包含一个加引号的控制串，控制串中包含若干格式说明和修饰符。控制串后面跟一个逗号，之后是一列由逗号分隔的表达式。<code>printf</code>会根据控制串来编排表达式的格式。<br><code>printf</code>和<code>print</code>不同的是printf在行尾不会自动换行，如果要换行必须使用转义字符<code>\\n</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;printf &quot;[Name:%-10s]\\tAge:%s&quot;, $1, $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">[Name:Name      ]       Age:Age[Name:Alice     ]        Age:25[Name:Bob       ] Age:30[Name:Charlie   ]      Age:22[Name:David     ] Age:35[Name:Eve       ] Age:28ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;printf &quot;[Name:%-10s]\\tAge:%s\\n&quot;, $1, $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">[Name:Name      ]       Age:Age</span><br><span class=\"line\">[Name:Alice     ]       Age:25</span><br><span class=\"line\">[Name:Bob       ]       Age:30</span><br><span class=\"line\">[Name:Charlie   ]       Age:22</span><br><span class=\"line\">[Name:David     ]       Age:35</span><br><span class=\"line\">[Name:Eve       ]       Age:28</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"记录与字段\"><a href=\"#记录与字段\" class=\"headerlink\" title=\"记录与字段\"></a>记录与字段</h2><h3 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h3><p>在awk中每一行数据称为一条记录，以换行符结束。</p>\n<ul>\n<li>记录分隔符：默认情况下，输入和输出记录的分隔符都是回车符，分别保存在内部变量<code>ORS</code>和<code>RS</code>中。</li>\n<li>变量<code>$0</code>表示当前整条记录，变量NR表示当前记录的记录号，每处理一条记录，NR值加一。</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print NR,$0&#125;&#x27;</span> example.txt</span><br><span class=\"line\">1 Name Age Gender City</span><br><span class=\"line\">2 Alice 25 Female New York</span><br><span class=\"line\">3 Bob 30 Male Los Angeles</span><br><span class=\"line\">4 Charlie 22 Male Chicago</span><br><span class=\"line\">5 David 35 Male Houston</span><br><span class=\"line\">6 Eve 28 Female Miami</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字段\"><a href=\"#字段\" class=\"headerlink\" title=\"字段\"></a>字段</h3><p>每一条记录都是由称为字段的词组成，默认情况下字段之间用空白符（空格或者制表符）分隔。<code>NF</code>变量保存每个记录的字段数量。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print NF,$0&#125;&#x27;</span> example.txt</span><br><span class=\"line\">4 Name Age Gender City</span><br><span class=\"line\">5 Alice 25 Female New York</span><br><span class=\"line\">5 Bob 30 Male Los Angeles</span><br><span class=\"line\">4 Charlie 22 Male Chicago</span><br><span class=\"line\">4 David 35 Male Houston</span><br><span class=\"line\">4 Eve 28 Female Miami</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字段分隔符\"><a href=\"#字段分隔符\" class=\"headerlink\" title=\"字段分隔符\"></a>字段分隔符</h3><p>字段分隔符由内部变量<code>FS</code>保存，可以在命令中通过<code>-F</code>选项修改<code>FS</code>的值。<br>先使用<code>sed</code>命令将<code>example.txt</code>文件中的空格替换为逗号：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ sed -i <span class=\"string\">&#x27;s/ /,/g&#x27;</span> example.txt</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ <span class=\"built_in\">cat</span> example.txt</span><br><span class=\"line\">Name,Age,Gender,City</span><br><span class=\"line\">Alice,25,Female,New,York</span><br><span class=\"line\">Bob,30,Male,Los,Angeles</span><br><span class=\"line\">Charlie,22,Male,Chicago</span><br><span class=\"line\">David,35,Male,Houston</span><br><span class=\"line\">Eve,28,Female,Miami</span><br></pre></td></tr></table></figure>\n\n<p>然后使用awk并通过<code>-F</code>选项替换分隔符进行输出：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print &quot;Name:&quot; $1, &quot;Age:&quot; $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Name,Age,Gender,City Age:</span><br><span class=\"line\">Name:Alice,25,Female,New,York Age:</span><br><span class=\"line\">Name:Bob,30,Male,Los,Angeles Age:</span><br><span class=\"line\">Name:Charlie,22,Male,Chicago Age:</span><br><span class=\"line\">Name:David,35,Male,Houston Age:</span><br><span class=\"line\">Name:Eve,28,Female,Miami Age:</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk -F, <span class=\"string\">&#x27;&#123;print &quot;Name:&quot; $1, &quot;Age:&quot; $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Name Age:Age</span><br><span class=\"line\">Name:Alice Age:25</span><br><span class=\"line\">Name:Bob Age:30</span><br><span class=\"line\">Name:Charlie Age:22</span><br><span class=\"line\">Name:David Age:35</span><br><span class=\"line\">Name:Eve Age:28</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"匹配模式与正则表达式\"><a href=\"#匹配模式与正则表达式\" class=\"headerlink\" title=\"匹配模式与正则表达式\"></a>匹配模式与正则表达式</h2><h3 id=\"匹配模式\"><a href=\"#匹配模式\" class=\"headerlink\" title=\"匹配模式\"></a>匹配模式</h3><p>awk中的模式可以是一个正则表达式或者用来判定条件真伪的表达式。</p>\n<p>使用<code>Alice</code>进行数据匹配：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ <span class=\"built_in\">cat</span> example.txt</span><br><span class=\"line\">Name Age Gender City</span><br><span class=\"line\">Alice 25 Female New York</span><br><span class=\"line\">Bob 30 Male Los Angeles</span><br><span class=\"line\">Charlie 22 Male Chicago</span><br><span class=\"line\">David 35 Male Houston</span><br><span class=\"line\">Eve 28 Female Miami</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;/Alice/&#x27;</span> example.txt</span><br><span class=\"line\">Alice 25 Female New York</span><br></pre></td></tr></table></figure>\n\n<p>使用条件表达式进行数据匹配：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ <span class=\"built_in\">cat</span> example.txt</span><br><span class=\"line\">Name Age Gender City</span><br><span class=\"line\">Alice 25 Female New York</span><br><span class=\"line\">Bob 30 Male Los Angeles</span><br><span class=\"line\">Charlie 22 Male Chicago</span><br><span class=\"line\">David 35 Male Houston</span><br><span class=\"line\">Eve 28 Female Miami</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;$2 &lt; 25&#x27;</span> example.txt</span><br><span class=\"line\">Charlie 22 Male Chicago</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正则表达式模式与操作\"><a href=\"#正则表达式模式与操作\" class=\"headerlink\" title=\"正则表达式模式与操作\"></a>正则表达式模式与操作</h3><p>使用正则表达式模式<code>Alice</code>进行数据匹配，然后通过<code>print</code>函数进行格式化输出：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;/Alice/&#123;print &quot;Name:&quot; $1&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Alice</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ <span class=\"built_in\">cat</span> example.txt</span><br><span class=\"line\">Name Age Gender City</span><br><span class=\"line\">Alice 25 Female New York</span><br><span class=\"line\">Bob 30 Male Los Angeles</span><br><span class=\"line\">Charlie 22 Male Chicago</span><br><span class=\"line\">David 35 Male Houston</span><br><span class=\"line\">Eve 28 Female Miami</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;/Alice/&#123;print &quot;Name:&quot; $1&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Alice</span><br></pre></td></tr></table></figure>\n\n<p>格式化输出<code>example.txt</code>文件中所有以大写字母<code>A-C</code>开头的行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ <span class=\"built_in\">cat</span> example.txt</span><br><span class=\"line\">Name Age Gender City</span><br><span class=\"line\">Alice 25 Female New York</span><br><span class=\"line\">Bob 30 Male Los Angeles</span><br><span class=\"line\">Charlie 22 Male Chicago</span><br><span class=\"line\">David 35 Male Houston</span><br><span class=\"line\">Eve 28 Female Miami</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;/^[A-C]+.*/&#123;print &quot;Name:&quot; $1&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Alice</span><br><span class=\"line\">Name:Bob</span><br><span class=\"line\">Name:Charlie</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><h3 id=\"显示系统下各用户所使用的shell\"><a href=\"#显示系统下各用户所使用的shell\" class=\"headerlink\" title=\"显示系统下各用户所使用的shell\"></a>显示系统下各用户所使用的shell</h3><p>查看当前<code>/etc/passwd</code>格式：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ <span class=\"built_in\">cat</span> /etc/passwd|<span class=\"built_in\">head</span></span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>\n\n<p>使用awk显示各用户使用的shell:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User:root Shell:/bin/bash</span><br><span class=\"line\">User:daemon Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:bin Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:sys Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:<span class=\"built_in\">sync</span> Shell:/bin/sync</span><br><span class=\"line\">User:games Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:man Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:lp Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:mail Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:news Shell:/usr/sbin/nologin</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"awk简介\"><a href=\"#awk简介\" class=\"headerlink\" title=\"awk简介\"></a>awk简介</h2><p>awk是一种用于处理文本数据的工具，可以从文本文件或者标准输入、一个或多个文件中提取和处理数据。<br>awk以逐行扫描方式处理数据，从第一行到最后一行以查找匹配某个特定模式的文本行，并且对这些文本行执行指定动作。</p>\n<h2 id=\"awk版本\"><a href=\"#awk版本\" class=\"headerlink\" title=\"awk版本\"></a>awk版本</h2><p>awk有众多版本包括传统awk、新版awk、gawk等，其中gawk是GNU组织开发的版本，也是目前最流行和最广泛使用的awk版本。gawk在传统awk和nawk的基础上添加了许多新功能和改进，例如更丰富的正则表达式支持、高级的数学和字符串处理函数、用户自定义函数等。gawk通常作为<code>/bin/gawk</code>或<code>/usr/bin/gawk</code>提供，是GNU工具集中的一部分，可以在多个平台上使用。<br>不同的awk可能在语法、功能和性能方面略有不同，在使用awk时应注意选择合适的版本，根据具体需求和系统环境来决定使用哪个版本。</p>\n<h2 id=\"awk格式\"><a href=\"#awk格式\" class=\"headerlink\" title=\"awk格式\"></a>awk格式</h2><p>awk基本格式如下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;pattern &#123; action &#125;&#x27; file</span><br><span class=\"line\">awk &#x27;&#123; action &#125;&#x27; file</span><br><span class=\"line\">awk &#x27;pattern&#x27; file</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>pattern</code>: 可以是一个正则表达式，也可以是一个字符串或数字，用于匹配文本中的某个字段或整行</li>\n<li><code>action</code>: 是在匹配到的文本上执行的操作，可以是一个或多个命令，多个命令之间用换行或分号 <code>;</code> 分隔</li>\n<li><code>file</code>: 是输入文件的名称，没有<code>file</code>参数时从标准输入读取数据</li>\n</ul>\n<p>在awk命令中，<code>pattern</code>和<code>action</code>之间通过大括号 <code>&#123;&#125;</code> 进行分隔，<code>pattern</code>用于匹配文本行，当匹配成功时，对应的<code>action</code>将被执行。</p>\n<p>awk还支持在处理数据前和处理数据后运行命令，完整格式如下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;BEGIN &#123;command&#125; pattern &#123; action &#125; END &#123;command&#125;&#x27; file</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;10 20 30 40 50&quot;</span> | awk <span class=\"string\">&#x27;BEGIN &#123;sum = 0; print &quot;sum:&quot;, sum&#125; &#123;sum += $1&#125; END &#123;print &quot;Sum:&quot;, sum&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note10.text-processing-tools-awk-2023-04-24-09-42-32.png\" alt=\"10.text-processing-tools-awk-2023-04-24-09-42-32\"></p>\n<h2 id=\"从标准输入读取数据\"><a href=\"#从标准输入读取数据\" class=\"headerlink\" title=\"从标准输入读取数据\"></a>从标准输入读取数据</h2><h3 id=\"从命令行读取数据\"><a href=\"#从命令行读取数据\" class=\"headerlink\" title=\"从命令行读取数据\"></a>从命令行读取数据</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print &quot;Hello World&quot;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">test</span></span><br><span class=\"line\">Hello World</span><br><span class=\"line\">abc</span><br><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n\n<p>以上awk命令没有指定<code>file</code>参数，awk不会直接给出运行结果，它会等待标准输入的数据，当用户输入字符后awk会执行相应的命令并产生输出。如果要终止awk程序需要使用<code>Ctrl+D</code>产生一个EOF字符，此时会返回到命令行下。</p>\n<h3 id=\"通过管道符号从命令读取数据\"><a href=\"#通过管道符号从命令读取数据\" class=\"headerlink\" title=\"通过管道符号从命令读取数据\"></a>通过管道符号从命令读取数据</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ ps -aux|awk <span class=\"string\">&#x27;/bash/&#x27;</span></span><br><span class=\"line\">root           1  0.0  0.0  18228  3012 pts/0    Ss+  Apr22   0:00 /bin/bash</span><br><span class=\"line\">root          11  0.0  0.0  18232  3240 pts/1    Ss   13:36   0:00 /bin/bash</span><br><span class=\"line\">ubuntu       269  0.0  0.0  18228  3144 pts/1    S    13:39   0:00 bash</span><br></pre></td></tr></table></figure>\n\n<p>以上awk命令通过管道符号<code>|</code>从前面一个命令的输出结果从读取数据进行处理。</p>\n<h2 id=\"从文件中读取数据和命令\"><a href=\"#从文件中读取数据和命令\" class=\"headerlink\" title=\"从文件中读取数据和命令\"></a>从文件中读取数据和命令</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;/Alice/&#x27;</span> example.txt</span><br><span class=\"line\">Alice,25,Female,New York</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;/Male/&#x27;</span> example.txt</span><br><span class=\"line\">Bob,30,Male,Los Angeles</span><br><span class=\"line\">Charlie,22,Male,Chicago</span><br><span class=\"line\">David,35,Male,Houston</span><br></pre></td></tr></table></figure>\n\n<p>以上awk命令指定了<code>file</code>参数，awk会从文件中以行为单位读取数据并且使用<code>pattern</code>所表示的匹配模式进行数据匹配，由于没有指定<code>action</code>参数，awk将匹配到的数据直接输出到标准输出。</p>\n<p>awk和sed一样可以从文件中读取命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk -f script_file.awk example.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"awk工作原理\"><a href=\"#awk工作原理\" class=\"headerlink\" title=\"awk工作原理\"></a>awk工作原理</h2><ol>\n<li>awk对文件或者标准输入的内容一次只处理一行，将获取到的这一行数据赋给变量$0</li>\n<li>这一行的内容按awk内部变量FS定义的分隔符（缺省为空格，包括制表符tab）分解成多个字段，每一个字段存储在从$1开始的变量中。</li>\n</ol>\n<p>以以下数据为例：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Name Age Gender City</span><br><span class=\"line\">Alice 25 Female New York</span><br><span class=\"line\">Bob 30 Male Los Angeles</span><br><span class=\"line\">Charlie 22 Male Chicago</span><br><span class=\"line\">David 35 Male Houston</span><br><span class=\"line\">Eve 28 Female Miami</span><br></pre></td></tr></table></figure>\n\n<p>以下awk命令的运行结果：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print $1,$3&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name Gender</span><br><span class=\"line\">Alice Female</span><br><span class=\"line\">Bob Male</span><br><span class=\"line\">Charlie Male</span><br><span class=\"line\">David Male</span><br><span class=\"line\">Eve Female</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>awk首先将第一行数据存放在变量$0中进行处理。</li>\n<li>将<code>$0</code>中的数据以空格为分隔符（内部变量<code>FS</code>所定义）进行分解，分别存放在从<code>$1</code>开始的内部变量中。</li>\n<li>在输出结果的每一行中第一个字段是存放在<code>$1</code>中的数据，第二个字段是存放在<code>$3</code>中的数据。</li>\n<li>awk命令中的逗号映射为一个内部变量-输出字段分隔符<code>OFS</code>（默认为空格）两个字段之间由空格间隔。</li>\n<li>处理完一行数据后读取下一行数据到<code>$0</code>中进行处理直到所以数据处理完毕。</li>\n</ol>\n<h2 id=\"格式化输出\"><a href=\"#格式化输出\" class=\"headerlink\" title=\"格式化输出\"></a>格式化输出</h2><h3 id=\"print函数\"><a href=\"#print函数\" class=\"headerlink\" title=\"print函数\"></a>print函数</h3><p>print函数用于打印不需要特别编排格式的简单输出。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print &quot;Name:&quot; $1 &quot;Age:&quot; $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:NameAge:Age</span><br><span class=\"line\">Name:AliceAge:25</span><br><span class=\"line\">Name:BobAge:30</span><br><span class=\"line\">Name:CharlieAge:22</span><br><span class=\"line\">Name:DavidAge:35</span><br><span class=\"line\">Name:EveAge:28</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print &quot;Name:&quot; $1, &quot;Age:&quot; $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Name Age:Age</span><br><span class=\"line\">Name:Alice Age:25</span><br><span class=\"line\">Name:Bob Age:30</span><br><span class=\"line\">Name:Charlie Age:22</span><br><span class=\"line\">Name:David Age:35</span><br><span class=\"line\">Name:Eve Age:28</span><br></pre></td></tr></table></figure>\n\n<p>逗号<code>,</code>表示内部变量<code>OFS</code>（用来表示输出字段的分隔符，默认为空格）。<br>print还支持以下转义序列：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\b：退格符（ASCII 008）</span><br><span class=\"line\">\\t：制表符（ASCII 009）</span><br><span class=\"line\">\\n：换行符（ASCII 010）</span><br><span class=\"line\">\\f：换页符（ASCII 012）</span><br><span class=\"line\">\\r：回车符（ASCII 013）</span><br></pre></td></tr></table></figure>\n\n<p>print中使用转义序列进行数据输出：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print &quot;Name:&quot; $1 &quot;\\tAge:&quot; $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Name       Age:Age</span><br><span class=\"line\">Name:Alice      Age:25</span><br><span class=\"line\">Name:Bob        Age:30</span><br><span class=\"line\">Name:Charlie    Age:22</span><br><span class=\"line\">Name:David      Age:35</span><br><span class=\"line\">Name:Eve        Age:28</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"printf函数\"><a href=\"#printf函数\" class=\"headerlink\" title=\"printf函数\"></a>printf函数</h3><p><code>printf</code>函数能够进行更加精细的格式化输出，用法和C语言中<code>printf</code>函数的用法一样。语句中包含一个加引号的控制串，控制串中包含若干格式说明和修饰符。控制串后面跟一个逗号，之后是一列由逗号分隔的表达式。<code>printf</code>会根据控制串来编排表达式的格式。<br><code>printf</code>和<code>print</code>不同的是printf在行尾不会自动换行，如果要换行必须使用转义字符<code>\\n</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;printf &quot;[Name:%-10s]\\tAge:%s&quot;, $1, $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">[Name:Name      ]       Age:Age[Name:Alice     ]        Age:25[Name:Bob       ] Age:30[Name:Charlie   ]      Age:22[Name:David     ] Age:35[Name:Eve       ] Age:28ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;printf &quot;[Name:%-10s]\\tAge:%s\\n&quot;, $1, $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">[Name:Name      ]       Age:Age</span><br><span class=\"line\">[Name:Alice     ]       Age:25</span><br><span class=\"line\">[Name:Bob       ]       Age:30</span><br><span class=\"line\">[Name:Charlie   ]       Age:22</span><br><span class=\"line\">[Name:David     ]       Age:35</span><br><span class=\"line\">[Name:Eve       ]       Age:28</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"记录与字段\"><a href=\"#记录与字段\" class=\"headerlink\" title=\"记录与字段\"></a>记录与字段</h2><h3 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h3><p>在awk中每一行数据称为一条记录，以换行符结束。</p>\n<ul>\n<li>记录分隔符：默认情况下，输入和输出记录的分隔符都是回车符，分别保存在内部变量<code>ORS</code>和<code>RS</code>中。</li>\n<li>变量<code>$0</code>表示当前整条记录，变量NR表示当前记录的记录号，每处理一条记录，NR值加一。</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print NR,$0&#125;&#x27;</span> example.txt</span><br><span class=\"line\">1 Name Age Gender City</span><br><span class=\"line\">2 Alice 25 Female New York</span><br><span class=\"line\">3 Bob 30 Male Los Angeles</span><br><span class=\"line\">4 Charlie 22 Male Chicago</span><br><span class=\"line\">5 David 35 Male Houston</span><br><span class=\"line\">6 Eve 28 Female Miami</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字段\"><a href=\"#字段\" class=\"headerlink\" title=\"字段\"></a>字段</h3><p>每一条记录都是由称为字段的词组成，默认情况下字段之间用空白符（空格或者制表符）分隔。<code>NF</code>变量保存每个记录的字段数量。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print NF,$0&#125;&#x27;</span> example.txt</span><br><span class=\"line\">4 Name Age Gender City</span><br><span class=\"line\">5 Alice 25 Female New York</span><br><span class=\"line\">5 Bob 30 Male Los Angeles</span><br><span class=\"line\">4 Charlie 22 Male Chicago</span><br><span class=\"line\">4 David 35 Male Houston</span><br><span class=\"line\">4 Eve 28 Female Miami</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字段分隔符\"><a href=\"#字段分隔符\" class=\"headerlink\" title=\"字段分隔符\"></a>字段分隔符</h3><p>字段分隔符由内部变量<code>FS</code>保存，可以在命令中通过<code>-F</code>选项修改<code>FS</code>的值。<br>先使用<code>sed</code>命令将<code>example.txt</code>文件中的空格替换为逗号：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ sed -i <span class=\"string\">&#x27;s/ /,/g&#x27;</span> example.txt</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ <span class=\"built_in\">cat</span> example.txt</span><br><span class=\"line\">Name,Age,Gender,City</span><br><span class=\"line\">Alice,25,Female,New,York</span><br><span class=\"line\">Bob,30,Male,Los,Angeles</span><br><span class=\"line\">Charlie,22,Male,Chicago</span><br><span class=\"line\">David,35,Male,Houston</span><br><span class=\"line\">Eve,28,Female,Miami</span><br></pre></td></tr></table></figure>\n\n<p>然后使用awk并通过<code>-F</code>选项替换分隔符进行输出：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;&#123;print &quot;Name:&quot; $1, &quot;Age:&quot; $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Name,Age,Gender,City Age:</span><br><span class=\"line\">Name:Alice,25,Female,New,York Age:</span><br><span class=\"line\">Name:Bob,30,Male,Los,Angeles Age:</span><br><span class=\"line\">Name:Charlie,22,Male,Chicago Age:</span><br><span class=\"line\">Name:David,35,Male,Houston Age:</span><br><span class=\"line\">Name:Eve,28,Female,Miami Age:</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk -F, <span class=\"string\">&#x27;&#123;print &quot;Name:&quot; $1, &quot;Age:&quot; $2&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Name Age:Age</span><br><span class=\"line\">Name:Alice Age:25</span><br><span class=\"line\">Name:Bob Age:30</span><br><span class=\"line\">Name:Charlie Age:22</span><br><span class=\"line\">Name:David Age:35</span><br><span class=\"line\">Name:Eve Age:28</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"匹配模式与正则表达式\"><a href=\"#匹配模式与正则表达式\" class=\"headerlink\" title=\"匹配模式与正则表达式\"></a>匹配模式与正则表达式</h2><h3 id=\"匹配模式\"><a href=\"#匹配模式\" class=\"headerlink\" title=\"匹配模式\"></a>匹配模式</h3><p>awk中的模式可以是一个正则表达式或者用来判定条件真伪的表达式。</p>\n<p>使用<code>Alice</code>进行数据匹配：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ <span class=\"built_in\">cat</span> example.txt</span><br><span class=\"line\">Name Age Gender City</span><br><span class=\"line\">Alice 25 Female New York</span><br><span class=\"line\">Bob 30 Male Los Angeles</span><br><span class=\"line\">Charlie 22 Male Chicago</span><br><span class=\"line\">David 35 Male Houston</span><br><span class=\"line\">Eve 28 Female Miami</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;/Alice/&#x27;</span> example.txt</span><br><span class=\"line\">Alice 25 Female New York</span><br></pre></td></tr></table></figure>\n\n<p>使用条件表达式进行数据匹配：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ <span class=\"built_in\">cat</span> example.txt</span><br><span class=\"line\">Name Age Gender City</span><br><span class=\"line\">Alice 25 Female New York</span><br><span class=\"line\">Bob 30 Male Los Angeles</span><br><span class=\"line\">Charlie 22 Male Chicago</span><br><span class=\"line\">David 35 Male Houston</span><br><span class=\"line\">Eve 28 Female Miami</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;$2 &lt; 25&#x27;</span> example.txt</span><br><span class=\"line\">Charlie 22 Male Chicago</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正则表达式模式与操作\"><a href=\"#正则表达式模式与操作\" class=\"headerlink\" title=\"正则表达式模式与操作\"></a>正则表达式模式与操作</h3><p>使用正则表达式模式<code>Alice</code>进行数据匹配，然后通过<code>print</code>函数进行格式化输出：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;/Alice/&#123;print &quot;Name:&quot; $1&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Alice</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ <span class=\"built_in\">cat</span> example.txt</span><br><span class=\"line\">Name Age Gender City</span><br><span class=\"line\">Alice 25 Female New York</span><br><span class=\"line\">Bob 30 Male Los Angeles</span><br><span class=\"line\">Charlie 22 Male Chicago</span><br><span class=\"line\">David 35 Male Houston</span><br><span class=\"line\">Eve 28 Female Miami</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;/Alice/&#123;print &quot;Name:&quot; $1&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Alice</span><br></pre></td></tr></table></figure>\n\n<p>格式化输出<code>example.txt</code>文件中所有以大写字母<code>A-C</code>开头的行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ <span class=\"built_in\">cat</span> example.txt</span><br><span class=\"line\">Name Age Gender City</span><br><span class=\"line\">Alice 25 Female New York</span><br><span class=\"line\">Bob 30 Male Los Angeles</span><br><span class=\"line\">Charlie 22 Male Chicago</span><br><span class=\"line\">David 35 Male Houston</span><br><span class=\"line\">Eve 28 Female Miami</span><br><span class=\"line\">ubuntu@6e455ed15da7:~$ awk <span class=\"string\">&#x27;/^[A-C]+.*/&#123;print &quot;Name:&quot; $1&#125;&#x27;</span> example.txt</span><br><span class=\"line\">Name:Alice</span><br><span class=\"line\">Name:Bob</span><br><span class=\"line\">Name:Charlie</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><h3 id=\"显示系统下各用户所使用的shell\"><a href=\"#显示系统下各用户所使用的shell\" class=\"headerlink\" title=\"显示系统下各用户所使用的shell\"></a>显示系统下各用户所使用的shell</h3><p>查看当前<code>/etc/passwd</code>格式：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@6e455ed15da7:~$ <span class=\"built_in\">cat</span> /etc/passwd|<span class=\"built_in\">head</span></span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>\n\n<p>使用awk显示各用户使用的shell:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User:root Shell:/bin/bash</span><br><span class=\"line\">User:daemon Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:bin Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:sys Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:<span class=\"built_in\">sync</span> Shell:/bin/sync</span><br><span class=\"line\">User:games Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:man Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:lp Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:mail Shell:/usr/sbin/nologin</span><br><span class=\"line\">User:news Shell:/usr/sbin/nologin</span><br></pre></td></tr></table></figure>"},{"title":"构建基本脚本","date":"2023-04-18T03:31:23.000Z","_content":"\n- `~/.vimrc` 内添加以下内容，实现在Vim内显示行号并且按 `F5` 一键运行Shell脚本\n\n    ```text\n    set nu\n    \n    nnoremap <F5> :call CompileRunGcc()<cr>\n    \n    func! CompileRunGcc()\n              exec \"w\"\n              if &filetype == 'sh'\n                      exec \"!clear;bash %\"\n              endif\n    endfunc\n    ```\n\n## 构建基本脚本\n\n- 在命令行中使用分号组织命令  \n    Shell脚本的关键在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给另一个命令。Shell可以让你将多个命令串起来，一次执行完成。如果要两个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开。\n\n    ```Shell 使用分号一次执行两个命令\n    [centos@host1 /]$ date;date\n    Tue Jun 13 14:16:40 UTC 2023\n    Tue Jun 13 14:16:40 UTC 2023\n    [centos@host1 /]$ date;whoami\n    Tue Jun 13 14:16:44 UTC 2023\n    centos\n    ```\n\n- 创建Shell脚本文件  \n    1. 在Shell脚本中，井号`#`用作注释行，Shell并不会处理Shell脚本中的注释行。但是Shell脚本文件的第一行是个例外，`#!`符号是一个特殊的标记，它会告诉系统用哪个Shell来运行脚本。  \n    2. 在Shell脚本中，你可以在独立的行中书写命令，Shell会按根据命令在文件中出现的顺序进行处理。  \n\n    ```bash 第一个Shell脚本\n    #!/bin/bash\n\n    # 这是一行注释，下面两行代码通过echo命令向标准输出发送指定字符\n    echo \"Hello World!\"\n    echo \"Hello World!\"\n    ```\n\n## 执行脚本文件的方式\n\n在执行脚本时先确认脚本是否有执行权限\n\n```shell\n[centos@host1 ~]$ ls -l test.sh\n-rwxrwxr-x 1 centos centos 124 Jun 13 14:51 test.sh\n```\n\n- 第一种方式：在提示符中使用绝对或者相对文件路径来引用脚本文件\n- 第二种方式：将Shell脚本文件所处目录添加到PATH变量中\n\n    ```shell\n    [centos@host1 ~]$ echo $PATH\n    /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n    ```\n\n- 第三种方式：使用 `bash + 脚本名` 或者 `source + 脚本名` 进行调用\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    Hello World!\n    Hello World!\n    [centos@host1 ~]$ source test.sh\n    Hello World!\n    Hello World!\n    ```\n\n## Shell变量概念\n\n- 变量定义\n\n    Shell变量是一种用于存储数据的容器。在Shell脚本中，变量用于存储各种类型的数据，例如数字、字符、字符串等。变量名通常是由一个字母、数字或下划线组成的字符串，并且不能以数字开头。\n\n- 变量分类\n\n    Shell中主要有两种类型的变量：环境变量和自定义变量。环境变量是在系统中定义的，可以由所有进程和用户访问。常见的环境变量包括PATH、HOME和USER等。自定义变量是在脚本中定义的，只能在脚本中使用，不能在脚本外部访问。\n\n- 定义变量的语法格式： `varName=varValue`\n\n    ![Untitled](Untitled%208.png)\n\n## Shell环境变量\n\n- 环境变量定义\n\n    bash Shell用环境变量（environment variable）来存储有关Shell会话和工作环\n    境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或Shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。\n\n- 环境变量分类\n  - 全局环境变量\n  - 局部环境变量\n- 全局环境变量\n\n    全局环境变量对于Shell会话和所有生成的子Shell都是可见的。局部变量则只对创建它们的Shell可见。这让全局环境变量对那些所创建的子Shell需要获取父Shell信息的程序来说非常有用。\n\n    Linux系统在你开始bash会话时就设置了一些全局环境变量。系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。\n\n- 查看全局环境变量\n  - `printenv` 、 `env`\n  - `printenv HOME`\n  - `echo $HOME`\n\n    ![Untitled](Untitled%209.png)\n\n  - 全局环境变量可以用于所有子Shell\n\n        ![Untitled](Untitled%2010.png)\n\n- 局部环境变量\n\n    局部环境变量只能在定义它们的进程中可见。查看局部环境变量的列表有点复杂。在Linux系统并没有一个只显示局部环境变量的命令。set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。\n\n- 局部用户定义变量，区别于系统环境变量使用小写字符\n\n    ![Untitled](Untitled%2011.png)\n\n    局部变量在子Shell中不可用，同样子Shell中定义的局部变量在父Shell中不可用\n\n    ![Untitled](Untitled%2012.png)\n\n- 设置全局环境变量\n\n    在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再使用 `export`把它导出到全局环境中。\n\n    ![Untitled](Untitled%2013.png)\n\n- bash默认的环境变量\n    1. HOME：当前用户的家目录\n    2. PATH：系统执行命令的路径\n    3. USER：当前登录的用户名\n    4. Shell：当前用户使用的默认Shell程序\n    5. PWD：当前工作目录\n    6. LANG：当前语言环境\n    7. TERM：当前终端的类型\n    8. PS1：命令提示符的格式\n    9. HISTSIZE：命令历史记录的长度限制\n    10. HISTFILESIZE：命令历史记录文件的大小限制\n- 设置PATH环境变量\n\n    ![Untitled](Untitled%2014.png)\n\n## 变量赋值\n\nShell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。\n\n- 引用用户变量和环境变量\n  - 使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。\n  - 在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。\n  - 变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。没有美元符，Shell会将变量名解释成普通的文本字符串\n\n    ![Untitled](Untitled%2015.png)\n\n- 命令替换\n\n    Shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。有两种方法可以将命令输出赋给变量：\n\n  - 反引号字符（`）(与~同键位)\n  - $()格式\n\n    ![Untitled](Untitled%2016.png)\n\n- 从键盘读入赋值\n\n    在Shell脚本中，Shell变量可以通过从键盘读入输入的内容并来赋值。命令格式为：read –p [提示信息]：[变量名]\n\n    read命令被用来从标准输入读取单行数据。\n\n    ![Untitled](Untitled%2017.png)\n\n## 变量数值计算\n\n- 使用 `expr`命令\n\n    ![Untitled](Untitled%2018.png)\n\n- 使用方括号\n\n    ![Untitled](Untitled%2019.png)\n\n- 在脚本内使用 `bc` 进行浮点数计算\n\n    ![Untitled](Untitled%2020.png)\n\n    ![Untitled](Untitled%2021.png)\n\n- let数值运算命令\n\n    let数值符号可以直接进行计算，且不带回显功能，也就是说当使用let的时候，不再使用$引用变量。let运算命令的语法格式为：let 赋值表达式，其功能等同于“((赋值表达式))” 。\n\n    ![Untitled](Untitled%2022.png)\n\n- 变量的自增\n\n    Shell变量的自增运算符是i++和++i。i++表示先赋值再自加，++i表示先自加再赋值。\n\n    ![Untitled](Untitled%2023.png)\n\n## 特殊参数\n\n- 位置参数\n\n    $0表示脚本名，$1表示脚本传递的第一个参数，$2 表示传递的第二个参数\n\n    ![Untitled](Untitled%2024.png)\n\n- 预定义参数\n\n    ![Untitled](Untitled%2025.png)\n\n## Shell中的特殊符号\n\n- “#”用在行首表示程序的注释。\n- “;” 作为命令的分隔符，分隔同一行上两个或者两个以上的命令。\n- “.”等价于source命令。它是bash中的一个内建命令。\n\n    “.”也可以作为文件名的一部分，如果“.”放在文件名的开头，那么这个文件将会成为“隐藏文件”，ls命令将不会正常显示出这个文件。\n\n- 单引号''，双引号\"\"的区别是单引号''剥夺了所有字符的特殊含义，单引号''内就变成了单纯的字符。双引号\"\"则对于双引号\"\"内的参数替换($)和命令替换(``)是个例外。","source":"_posts/linux_shell/2.构建基本脚本.md","raw":"---\ntitle: 构建基本脚本\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n- `~/.vimrc` 内添加以下内容，实现在Vim内显示行号并且按 `F5` 一键运行Shell脚本\n\n    ```text\n    set nu\n    \n    nnoremap <F5> :call CompileRunGcc()<cr>\n    \n    func! CompileRunGcc()\n              exec \"w\"\n              if &filetype == 'sh'\n                      exec \"!clear;bash %\"\n              endif\n    endfunc\n    ```\n\n## 构建基本脚本\n\n- 在命令行中使用分号组织命令  \n    Shell脚本的关键在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给另一个命令。Shell可以让你将多个命令串起来，一次执行完成。如果要两个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开。\n\n    ```Shell 使用分号一次执行两个命令\n    [centos@host1 /]$ date;date\n    Tue Jun 13 14:16:40 UTC 2023\n    Tue Jun 13 14:16:40 UTC 2023\n    [centos@host1 /]$ date;whoami\n    Tue Jun 13 14:16:44 UTC 2023\n    centos\n    ```\n\n- 创建Shell脚本文件  \n    1. 在Shell脚本中，井号`#`用作注释行，Shell并不会处理Shell脚本中的注释行。但是Shell脚本文件的第一行是个例外，`#!`符号是一个特殊的标记，它会告诉系统用哪个Shell来运行脚本。  \n    2. 在Shell脚本中，你可以在独立的行中书写命令，Shell会按根据命令在文件中出现的顺序进行处理。  \n\n    ```bash 第一个Shell脚本\n    #!/bin/bash\n\n    # 这是一行注释，下面两行代码通过echo命令向标准输出发送指定字符\n    echo \"Hello World!\"\n    echo \"Hello World!\"\n    ```\n\n## 执行脚本文件的方式\n\n在执行脚本时先确认脚本是否有执行权限\n\n```shell\n[centos@host1 ~]$ ls -l test.sh\n-rwxrwxr-x 1 centos centos 124 Jun 13 14:51 test.sh\n```\n\n- 第一种方式：在提示符中使用绝对或者相对文件路径来引用脚本文件\n- 第二种方式：将Shell脚本文件所处目录添加到PATH变量中\n\n    ```shell\n    [centos@host1 ~]$ echo $PATH\n    /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n    ```\n\n- 第三种方式：使用 `bash + 脚本名` 或者 `source + 脚本名` 进行调用\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    Hello World!\n    Hello World!\n    [centos@host1 ~]$ source test.sh\n    Hello World!\n    Hello World!\n    ```\n\n## Shell变量概念\n\n- 变量定义\n\n    Shell变量是一种用于存储数据的容器。在Shell脚本中，变量用于存储各种类型的数据，例如数字、字符、字符串等。变量名通常是由一个字母、数字或下划线组成的字符串，并且不能以数字开头。\n\n- 变量分类\n\n    Shell中主要有两种类型的变量：环境变量和自定义变量。环境变量是在系统中定义的，可以由所有进程和用户访问。常见的环境变量包括PATH、HOME和USER等。自定义变量是在脚本中定义的，只能在脚本中使用，不能在脚本外部访问。\n\n- 定义变量的语法格式： `varName=varValue`\n\n    ![Untitled](Untitled%208.png)\n\n## Shell环境变量\n\n- 环境变量定义\n\n    bash Shell用环境变量（environment variable）来存储有关Shell会话和工作环\n    境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或Shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。\n\n- 环境变量分类\n  - 全局环境变量\n  - 局部环境变量\n- 全局环境变量\n\n    全局环境变量对于Shell会话和所有生成的子Shell都是可见的。局部变量则只对创建它们的Shell可见。这让全局环境变量对那些所创建的子Shell需要获取父Shell信息的程序来说非常有用。\n\n    Linux系统在你开始bash会话时就设置了一些全局环境变量。系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。\n\n- 查看全局环境变量\n  - `printenv` 、 `env`\n  - `printenv HOME`\n  - `echo $HOME`\n\n    ![Untitled](Untitled%209.png)\n\n  - 全局环境变量可以用于所有子Shell\n\n        ![Untitled](Untitled%2010.png)\n\n- 局部环境变量\n\n    局部环境变量只能在定义它们的进程中可见。查看局部环境变量的列表有点复杂。在Linux系统并没有一个只显示局部环境变量的命令。set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。\n\n- 局部用户定义变量，区别于系统环境变量使用小写字符\n\n    ![Untitled](Untitled%2011.png)\n\n    局部变量在子Shell中不可用，同样子Shell中定义的局部变量在父Shell中不可用\n\n    ![Untitled](Untitled%2012.png)\n\n- 设置全局环境变量\n\n    在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再使用 `export`把它导出到全局环境中。\n\n    ![Untitled](Untitled%2013.png)\n\n- bash默认的环境变量\n    1. HOME：当前用户的家目录\n    2. PATH：系统执行命令的路径\n    3. USER：当前登录的用户名\n    4. Shell：当前用户使用的默认Shell程序\n    5. PWD：当前工作目录\n    6. LANG：当前语言环境\n    7. TERM：当前终端的类型\n    8. PS1：命令提示符的格式\n    9. HISTSIZE：命令历史记录的长度限制\n    10. HISTFILESIZE：命令历史记录文件的大小限制\n- 设置PATH环境变量\n\n    ![Untitled](Untitled%2014.png)\n\n## 变量赋值\n\nShell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。\n\n- 引用用户变量和环境变量\n  - 使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。\n  - 在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。\n  - 变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。没有美元符，Shell会将变量名解释成普通的文本字符串\n\n    ![Untitled](Untitled%2015.png)\n\n- 命令替换\n\n    Shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。有两种方法可以将命令输出赋给变量：\n\n  - 反引号字符（`）(与~同键位)\n  - $()格式\n\n    ![Untitled](Untitled%2016.png)\n\n- 从键盘读入赋值\n\n    在Shell脚本中，Shell变量可以通过从键盘读入输入的内容并来赋值。命令格式为：read –p [提示信息]：[变量名]\n\n    read命令被用来从标准输入读取单行数据。\n\n    ![Untitled](Untitled%2017.png)\n\n## 变量数值计算\n\n- 使用 `expr`命令\n\n    ![Untitled](Untitled%2018.png)\n\n- 使用方括号\n\n    ![Untitled](Untitled%2019.png)\n\n- 在脚本内使用 `bc` 进行浮点数计算\n\n    ![Untitled](Untitled%2020.png)\n\n    ![Untitled](Untitled%2021.png)\n\n- let数值运算命令\n\n    let数值符号可以直接进行计算，且不带回显功能，也就是说当使用let的时候，不再使用$引用变量。let运算命令的语法格式为：let 赋值表达式，其功能等同于“((赋值表达式))” 。\n\n    ![Untitled](Untitled%2022.png)\n\n- 变量的自增\n\n    Shell变量的自增运算符是i++和++i。i++表示先赋值再自加，++i表示先自加再赋值。\n\n    ![Untitled](Untitled%2023.png)\n\n## 特殊参数\n\n- 位置参数\n\n    $0表示脚本名，$1表示脚本传递的第一个参数，$2 表示传递的第二个参数\n\n    ![Untitled](Untitled%2024.png)\n\n- 预定义参数\n\n    ![Untitled](Untitled%2025.png)\n\n## Shell中的特殊符号\n\n- “#”用在行首表示程序的注释。\n- “;” 作为命令的分隔符，分隔同一行上两个或者两个以上的命令。\n- “.”等价于source命令。它是bash中的一个内建命令。\n\n    “.”也可以作为文件名的一部分，如果“.”放在文件名的开头，那么这个文件将会成为“隐藏文件”，ls命令将不会正常显示出这个文件。\n\n- 单引号''，双引号\"\"的区别是单引号''剥夺了所有字符的特殊含义，单引号''内就变成了单纯的字符。双引号\"\"则对于双引号\"\"内的参数替换($)和命令替换(``)是个例外。","slug":"linux_shell/2.构建基本脚本","published":1,"updated":"2023-06-13T15:08:09.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cliuf72wb0003j1nzaxsn033i","content":"<ul>\n<li><p><code>~/.vimrc</code> 内添加以下内容，实现在Vim内显示行号并且按 <code>F5</code> 一键运行Shell脚本</p>\n  <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set nu</span><br><span class=\"line\"></span><br><span class=\"line\">nnoremap &lt;F5&gt; :call CompileRunGcc()&lt;cr&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">func! CompileRunGcc()</span><br><span class=\"line\">          exec &quot;w&quot;</span><br><span class=\"line\">          if &amp;filetype == &#x27;sh&#x27;</span><br><span class=\"line\">                  exec &quot;!clear;bash %&quot;</span><br><span class=\"line\">          endif</span><br><span class=\"line\">endfunc</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"构建基本脚本\"><a href=\"#构建基本脚本\" class=\"headerlink\" title=\"构建基本脚本\"></a>构建基本脚本</h2><ul>\n<li><p>在命令行中使用分号组织命令<br>  Shell脚本的关键在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给另一个命令。Shell可以让你将多个命令串起来，一次执行完成。如果要两个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开。</p>\n  <figure class=\"highlight shell\"><figcaption><span>使用分号一次执行两个命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[centos@host1 /]$ date;date</span><br><span class=\"line\">Tue Jun 13 14:16:40 UTC 2023</span><br><span class=\"line\">Tue Jun 13 14:16:40 UTC 2023</span><br><span class=\"line\">[centos@host1 /]$ date;whoami</span><br><span class=\"line\">Tue Jun 13 14:16:44 UTC 2023</span><br><span class=\"line\">centos</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建Shell脚本文件  </p>\n<ol>\n<li>在Shell脚本中，井号<code>#</code>用作注释行，Shell并不会处理Shell脚本中的注释行。但是Shell脚本文件的第一行是个例外，<code>#!</code>符号是一个特殊的标记，它会告诉系统用哪个Shell来运行脚本。  </li>\n<li>在Shell脚本中，你可以在独立的行中书写命令，Shell会按根据命令在文件中出现的顺序进行处理。</li>\n</ol>\n  <figure class=\"highlight bash\"><figcaption><span>第一个Shell脚本</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这是一行注释，下面两行代码通过echo命令向标准输出发送指定字符</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello World!&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"执行脚本文件的方式\"><a href=\"#执行脚本文件的方式\" class=\"headerlink\" title=\"执行脚本文件的方式\"></a>执行脚本文件的方式</h2><p>在执行脚本时先确认脚本是否有执行权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[centos@host1 ~]$ ls -l test.sh</span><br><span class=\"line\">-rwxrwxr-x 1 centos centos 124 Jun 13 14:51 test.sh</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>第一种方式：在提示符中使用绝对或者相对文件路径来引用脚本文件</p>\n</li>\n<li><p>第二种方式：将Shell脚本文件所处目录添加到PATH变量中</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[centos@host1 ~]$ echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第三种方式：使用 <code>bash + 脚本名</code> 或者 <code>source + 脚本名</code> 进行调用</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[centos@host1 ~]$ bash test.sh</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">[centos@host1 ~]$ source test.sh</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">Hello World!</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Shell变量概念\"><a href=\"#Shell变量概念\" class=\"headerlink\" title=\"Shell变量概念\"></a>Shell变量概念</h2><ul>\n<li><p>变量定义</p>\n<p>  Shell变量是一种用于存储数据的容器。在Shell脚本中，变量用于存储各种类型的数据，例如数字、字符、字符串等。变量名通常是由一个字母、数字或下划线组成的字符串，并且不能以数字开头。</p>\n</li>\n<li><p>变量分类</p>\n<p>  Shell中主要有两种类型的变量：环境变量和自定义变量。环境变量是在系统中定义的，可以由所有进程和用户访问。常见的环境变量包括PATH、HOME和USER等。自定义变量是在脚本中定义的，只能在脚本中使用，不能在脚本外部访问。</p>\n</li>\n<li><p>定义变量的语法格式： <code>varName=varValue</code></p>\n<p>  <img src=\"/Untitled%208.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n<h2 id=\"Shell环境变量\"><a href=\"#Shell环境变量\" class=\"headerlink\" title=\"Shell环境变量\"></a>Shell环境变量</h2><ul>\n<li><p>环境变量定义</p>\n<p>  bash Shell用环境变量（environment variable）来存储有关Shell会话和工作环<br>  境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或Shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。</p>\n</li>\n<li><p>环境变量分类</p>\n<ul>\n<li>全局环境变量</li>\n<li>局部环境变量</li>\n</ul>\n</li>\n<li><p>全局环境变量</p>\n<p>  全局环境变量对于Shell会话和所有生成的子Shell都是可见的。局部变量则只对创建它们的Shell可见。这让全局环境变量对那些所创建的子Shell需要获取父Shell信息的程序来说非常有用。</p>\n<p>  Linux系统在你开始bash会话时就设置了一些全局环境变量。系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。</p>\n</li>\n<li><p>查看全局环境变量</p>\n<ul>\n<li><p><code>printenv</code> 、 <code>env</code></p>\n</li>\n<li><p><code>printenv HOME</code></p>\n</li>\n<li><p><code>echo $HOME</code></p>\n<p><img src=\"/Untitled%209.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>全局环境变量可以用于所有子Shell</p>\n<pre><code>![Untitled](Untitled%2010.png)\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>局部环境变量</p>\n<p>  局部环境变量只能在定义它们的进程中可见。查看局部环境变量的列表有点复杂。在Linux系统并没有一个只显示局部环境变量的命令。set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。</p>\n</li>\n<li><p>局部用户定义变量，区别于系统环境变量使用小写字符</p>\n<p>  <img src=\"/Untitled%2011.png\" alt=\"Untitled\"></p>\n<p>  局部变量在子Shell中不可用，同样子Shell中定义的局部变量在父Shell中不可用</p>\n<p>  <img src=\"/Untitled%2012.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>设置全局环境变量</p>\n<p>  在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再使用 <code>export</code>把它导出到全局环境中。</p>\n<p>  <img src=\"/Untitled%2013.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>bash默认的环境变量</p>\n<ol>\n<li>HOME：当前用户的家目录</li>\n<li>PATH：系统执行命令的路径</li>\n<li>USER：当前登录的用户名</li>\n<li>Shell：当前用户使用的默认Shell程序</li>\n<li>PWD：当前工作目录</li>\n<li>LANG：当前语言环境</li>\n<li>TERM：当前终端的类型</li>\n<li>PS1：命令提示符的格式</li>\n<li>HISTSIZE：命令历史记录的长度限制</li>\n<li>HISTFILESIZE：命令历史记录文件的大小限制</li>\n</ol>\n</li>\n<li><p>设置PATH环境变量</p>\n<p>  <img src=\"/Untitled%2014.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n<h2 id=\"变量赋值\"><a href=\"#变量赋值\" class=\"headerlink\" title=\"变量赋值\"></a>变量赋值</h2><p>Shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。</p>\n<ul>\n<li><p>引用用户变量和环境变量</p>\n<ul>\n<li><p>使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。</p>\n</li>\n<li><p>在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。</p>\n</li>\n<li><p>变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。没有美元符，Shell会将变量名解释成普通的文本字符串</p>\n<p><img src=\"/Untitled%2015.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n</li>\n<li><p>命令替换</p>\n<p>  Shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。有两种方法可以将命令输出赋给变量：</p>\n<ul>\n<li><p>反引号字符（&#96;）(与~同键位)</p>\n</li>\n<li><p>$()格式</p>\n<p><img src=\"/Untitled%2016.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n</li>\n<li><p>从键盘读入赋值</p>\n<p>  在Shell脚本中，Shell变量可以通过从键盘读入输入的内容并来赋值。命令格式为：read –p [提示信息]：[变量名]</p>\n<p>  read命令被用来从标准输入读取单行数据。</p>\n<p>  <img src=\"/Untitled%2017.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n<h2 id=\"变量数值计算\"><a href=\"#变量数值计算\" class=\"headerlink\" title=\"变量数值计算\"></a>变量数值计算</h2><ul>\n<li><p>使用 <code>expr</code>命令</p>\n<p>  <img src=\"/Untitled%2018.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>使用方括号</p>\n<p>  <img src=\"/Untitled%2019.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>在脚本内使用 <code>bc</code> 进行浮点数计算</p>\n<p>  <img src=\"/Untitled%2020.png\" alt=\"Untitled\"></p>\n<p>  <img src=\"/Untitled%2021.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>let数值运算命令</p>\n<p>  let数值符号可以直接进行计算，且不带回显功能，也就是说当使用let的时候，不再使用$引用变量。let运算命令的语法格式为：let 赋值表达式，其功能等同于“((赋值表达式))” 。</p>\n<p>  <img src=\"/Untitled%2022.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>变量的自增</p>\n<p>  Shell变量的自增运算符是i++和++i。i++表示先赋值再自加，++i表示先自加再赋值。</p>\n<p>  <img src=\"/Untitled%2023.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n<h2 id=\"特殊参数\"><a href=\"#特殊参数\" class=\"headerlink\" title=\"特殊参数\"></a>特殊参数</h2><ul>\n<li><p>位置参数</p>\n<p>  $0表示脚本名，$1表示脚本传递的第一个参数，$2 表示传递的第二个参数</p>\n<p>  <img src=\"/Untitled%2024.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>预定义参数</p>\n<p>  <img src=\"/Untitled%2025.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n<h2 id=\"Shell中的特殊符号\"><a href=\"#Shell中的特殊符号\" class=\"headerlink\" title=\"Shell中的特殊符号\"></a>Shell中的特殊符号</h2><ul>\n<li><p>“#”用在行首表示程序的注释。</p>\n</li>\n<li><p>“;” 作为命令的分隔符，分隔同一行上两个或者两个以上的命令。</p>\n</li>\n<li><p>“.”等价于source命令。它是bash中的一个内建命令。</p>\n<p>  “.”也可以作为文件名的一部分，如果“.”放在文件名的开头，那么这个文件将会成为“隐藏文件”，ls命令将不会正常显示出这个文件。</p>\n</li>\n<li><p>单引号’’，双引号””的区别是单引号’’剥夺了所有字符的特殊含义，单引号’’内就变成了单纯的字符。双引号””则对于双引号””内的参数替换($)和命令替换(&#96;&#96;)是个例外。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p><code>~/.vimrc</code> 内添加以下内容，实现在Vim内显示行号并且按 <code>F5</code> 一键运行Shell脚本</p>\n  <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set nu</span><br><span class=\"line\"></span><br><span class=\"line\">nnoremap &lt;F5&gt; :call CompileRunGcc()&lt;cr&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">func! CompileRunGcc()</span><br><span class=\"line\">          exec &quot;w&quot;</span><br><span class=\"line\">          if &amp;filetype == &#x27;sh&#x27;</span><br><span class=\"line\">                  exec &quot;!clear;bash %&quot;</span><br><span class=\"line\">          endif</span><br><span class=\"line\">endfunc</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"构建基本脚本\"><a href=\"#构建基本脚本\" class=\"headerlink\" title=\"构建基本脚本\"></a>构建基本脚本</h2><ul>\n<li><p>在命令行中使用分号组织命令<br>  Shell脚本的关键在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给另一个命令。Shell可以让你将多个命令串起来，一次执行完成。如果要两个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开。</p>\n  <figure class=\"highlight shell\"><figcaption><span>使用分号一次执行两个命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[centos@host1 /]$ date;date</span><br><span class=\"line\">Tue Jun 13 14:16:40 UTC 2023</span><br><span class=\"line\">Tue Jun 13 14:16:40 UTC 2023</span><br><span class=\"line\">[centos@host1 /]$ date;whoami</span><br><span class=\"line\">Tue Jun 13 14:16:44 UTC 2023</span><br><span class=\"line\">centos</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建Shell脚本文件  </p>\n<ol>\n<li>在Shell脚本中，井号<code>#</code>用作注释行，Shell并不会处理Shell脚本中的注释行。但是Shell脚本文件的第一行是个例外，<code>#!</code>符号是一个特殊的标记，它会告诉系统用哪个Shell来运行脚本。  </li>\n<li>在Shell脚本中，你可以在独立的行中书写命令，Shell会按根据命令在文件中出现的顺序进行处理。</li>\n</ol>\n  <figure class=\"highlight bash\"><figcaption><span>第一个Shell脚本</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这是一行注释，下面两行代码通过echo命令向标准输出发送指定字符</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello World!&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"执行脚本文件的方式\"><a href=\"#执行脚本文件的方式\" class=\"headerlink\" title=\"执行脚本文件的方式\"></a>执行脚本文件的方式</h2><p>在执行脚本时先确认脚本是否有执行权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[centos@host1 ~]$ ls -l test.sh</span><br><span class=\"line\">-rwxrwxr-x 1 centos centos 124 Jun 13 14:51 test.sh</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>第一种方式：在提示符中使用绝对或者相对文件路径来引用脚本文件</p>\n</li>\n<li><p>第二种方式：将Shell脚本文件所处目录添加到PATH变量中</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[centos@host1 ~]$ echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第三种方式：使用 <code>bash + 脚本名</code> 或者 <code>source + 脚本名</code> 进行调用</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[centos@host1 ~]$ bash test.sh</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">[centos@host1 ~]$ source test.sh</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">Hello World!</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Shell变量概念\"><a href=\"#Shell变量概念\" class=\"headerlink\" title=\"Shell变量概念\"></a>Shell变量概念</h2><ul>\n<li><p>变量定义</p>\n<p>  Shell变量是一种用于存储数据的容器。在Shell脚本中，变量用于存储各种类型的数据，例如数字、字符、字符串等。变量名通常是由一个字母、数字或下划线组成的字符串，并且不能以数字开头。</p>\n</li>\n<li><p>变量分类</p>\n<p>  Shell中主要有两种类型的变量：环境变量和自定义变量。环境变量是在系统中定义的，可以由所有进程和用户访问。常见的环境变量包括PATH、HOME和USER等。自定义变量是在脚本中定义的，只能在脚本中使用，不能在脚本外部访问。</p>\n</li>\n<li><p>定义变量的语法格式： <code>varName=varValue</code></p>\n<p>  <img src=\"/Untitled%208.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n<h2 id=\"Shell环境变量\"><a href=\"#Shell环境变量\" class=\"headerlink\" title=\"Shell环境变量\"></a>Shell环境变量</h2><ul>\n<li><p>环境变量定义</p>\n<p>  bash Shell用环境变量（environment variable）来存储有关Shell会话和工作环<br>  境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或Shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。</p>\n</li>\n<li><p>环境变量分类</p>\n<ul>\n<li>全局环境变量</li>\n<li>局部环境变量</li>\n</ul>\n</li>\n<li><p>全局环境变量</p>\n<p>  全局环境变量对于Shell会话和所有生成的子Shell都是可见的。局部变量则只对创建它们的Shell可见。这让全局环境变量对那些所创建的子Shell需要获取父Shell信息的程序来说非常有用。</p>\n<p>  Linux系统在你开始bash会话时就设置了一些全局环境变量。系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。</p>\n</li>\n<li><p>查看全局环境变量</p>\n<ul>\n<li><p><code>printenv</code> 、 <code>env</code></p>\n</li>\n<li><p><code>printenv HOME</code></p>\n</li>\n<li><p><code>echo $HOME</code></p>\n<p><img src=\"/Untitled%209.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>全局环境变量可以用于所有子Shell</p>\n<pre><code>![Untitled](Untitled%2010.png)\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>局部环境变量</p>\n<p>  局部环境变量只能在定义它们的进程中可见。查看局部环境变量的列表有点复杂。在Linux系统并没有一个只显示局部环境变量的命令。set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。</p>\n</li>\n<li><p>局部用户定义变量，区别于系统环境变量使用小写字符</p>\n<p>  <img src=\"/Untitled%2011.png\" alt=\"Untitled\"></p>\n<p>  局部变量在子Shell中不可用，同样子Shell中定义的局部变量在父Shell中不可用</p>\n<p>  <img src=\"/Untitled%2012.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>设置全局环境变量</p>\n<p>  在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再使用 <code>export</code>把它导出到全局环境中。</p>\n<p>  <img src=\"/Untitled%2013.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>bash默认的环境变量</p>\n<ol>\n<li>HOME：当前用户的家目录</li>\n<li>PATH：系统执行命令的路径</li>\n<li>USER：当前登录的用户名</li>\n<li>Shell：当前用户使用的默认Shell程序</li>\n<li>PWD：当前工作目录</li>\n<li>LANG：当前语言环境</li>\n<li>TERM：当前终端的类型</li>\n<li>PS1：命令提示符的格式</li>\n<li>HISTSIZE：命令历史记录的长度限制</li>\n<li>HISTFILESIZE：命令历史记录文件的大小限制</li>\n</ol>\n</li>\n<li><p>设置PATH环境变量</p>\n<p>  <img src=\"/Untitled%2014.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n<h2 id=\"变量赋值\"><a href=\"#变量赋值\" class=\"headerlink\" title=\"变量赋值\"></a>变量赋值</h2><p>Shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。</p>\n<ul>\n<li><p>引用用户变量和环境变量</p>\n<ul>\n<li><p>使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。</p>\n</li>\n<li><p>在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。</p>\n</li>\n<li><p>变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。没有美元符，Shell会将变量名解释成普通的文本字符串</p>\n<p><img src=\"/Untitled%2015.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n</li>\n<li><p>命令替换</p>\n<p>  Shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。有两种方法可以将命令输出赋给变量：</p>\n<ul>\n<li><p>反引号字符（&#96;）(与~同键位)</p>\n</li>\n<li><p>$()格式</p>\n<p><img src=\"/Untitled%2016.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n</li>\n<li><p>从键盘读入赋值</p>\n<p>  在Shell脚本中，Shell变量可以通过从键盘读入输入的内容并来赋值。命令格式为：read –p [提示信息]：[变量名]</p>\n<p>  read命令被用来从标准输入读取单行数据。</p>\n<p>  <img src=\"/Untitled%2017.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n<h2 id=\"变量数值计算\"><a href=\"#变量数值计算\" class=\"headerlink\" title=\"变量数值计算\"></a>变量数值计算</h2><ul>\n<li><p>使用 <code>expr</code>命令</p>\n<p>  <img src=\"/Untitled%2018.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>使用方括号</p>\n<p>  <img src=\"/Untitled%2019.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>在脚本内使用 <code>bc</code> 进行浮点数计算</p>\n<p>  <img src=\"/Untitled%2020.png\" alt=\"Untitled\"></p>\n<p>  <img src=\"/Untitled%2021.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>let数值运算命令</p>\n<p>  let数值符号可以直接进行计算，且不带回显功能，也就是说当使用let的时候，不再使用$引用变量。let运算命令的语法格式为：let 赋值表达式，其功能等同于“((赋值表达式))” 。</p>\n<p>  <img src=\"/Untitled%2022.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>变量的自增</p>\n<p>  Shell变量的自增运算符是i++和++i。i++表示先赋值再自加，++i表示先自加再赋值。</p>\n<p>  <img src=\"/Untitled%2023.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n<h2 id=\"特殊参数\"><a href=\"#特殊参数\" class=\"headerlink\" title=\"特殊参数\"></a>特殊参数</h2><ul>\n<li><p>位置参数</p>\n<p>  $0表示脚本名，$1表示脚本传递的第一个参数，$2 表示传递的第二个参数</p>\n<p>  <img src=\"/Untitled%2024.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>预定义参数</p>\n<p>  <img src=\"/Untitled%2025.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n<h2 id=\"Shell中的特殊符号\"><a href=\"#Shell中的特殊符号\" class=\"headerlink\" title=\"Shell中的特殊符号\"></a>Shell中的特殊符号</h2><ul>\n<li><p>“#”用在行首表示程序的注释。</p>\n</li>\n<li><p>“;” 作为命令的分隔符，分隔同一行上两个或者两个以上的命令。</p>\n</li>\n<li><p>“.”等价于source命令。它是bash中的一个内建命令。</p>\n<p>  “.”也可以作为文件名的一部分，如果“.”放在文件名的开头，那么这个文件将会成为“隐藏文件”，ls命令将不会正常显示出这个文件。</p>\n</li>\n<li><p>单引号’’，双引号””的区别是单引号’’剥夺了所有字符的特殊含义，单引号’’内就变成了单纯的字符。双引号””则对于双引号””内的参数替换($)和命令替换(&#96;&#96;)是个例外。</p>\n</li>\n</ul>\n"},{"title":"Shell条件测试","date":"2023-04-18T03:31:23.000Z","_content":"\n- 结构化命令\n    \n    Shell按照命令在脚本中出现的顺序依次进行处理。对顺序操作来说，这已经足够了，因为在这种操作环境下，你想要的就是所有的命令按照正确的顺序执行。\n    \n    许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令（structured command）\n    \n    常见的条件测试命令： `if-then语句` 、 `case语句` 、 `for语句` 、 `while语句` \n    \n- if条件语句\n    - if条件语句通常由以下三个关键字组成：\n        - if：用于指定要测试的条件。\n        - then：用于指定如果条件为true时要执行的指令。\n        - else：用于指定如果条件为false时要执行的指令。\n    - 语法格式如下：\n    \n    ![Untitled](Untitled%2026.png)\n    \n    - 在其他编程语言中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。但bash shell的if语句并不是这么做的。bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码是0（该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值，then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。fi语句用来表示if-then语句到此结束。\n        \n        ![Untitled](Untitled%2027.png)\n        \n    - `if-then` 语句的另一种形式\n        \n        ```bash\n        if command; then\n        commands\n        fi\n        ```\n        \n    - 练习\n        \n        ![Untitled](Untitled%2028.png)\n        \n    - `if-then-else` 双分支语句\n        \n        当if语句中的命令返回退出状态码0时，then部分中的命令会被执行，这跟普通的if-then\n        语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。\n        \n        ![Untitled](Untitled%2029.png)\n        \n    - `if-then-elif-else` 多分支语句\n        \n        ![Untitled](Untitled%2030.png)\n        \n- `test` 命令\n    \n    如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。\n    \n    - test命令格式\n        \n        `test condition` \n        \n        ```bash\n        if test condition\n        then\n        \tcommands\n        fi\n        ```\n        \n        ![Untitled](Untitled%2031.png)\n        \n    - bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。\n        \n        ```bash\n        if [ condition ]\n        then\n        \tcommands\n        fi\n        ```\n        \n        方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。\n        \n        test命令可以判断三类条件：\n        \n        - 文件比较\n        - 字符串比较\n        - 数值比较\n- 文件比较\n    \n    这些测试条件使你能够在shell脚本中检查文件系统中的文件。它们经常出现在需要进行文件访问的脚本中，文件比较的操作符如下：\n    \n    ![Untitled](Untitled%2032.png)\n    \n    ![Untitled](Untitled%2033.png)\n    \n    ![Untitled](Untitled%2034.png)\n    \n- 字符串比较\n    \n    ![Untitled](Untitled%2035.png)\n    \n    ![Untitled](Untitled%2036.png)\n    \n    - 大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名\n    \n    ![Untitled](Untitled%2037.png)\n    \n- 数值比较\n    \n    数值条件测试可以用在数字和变量上。\n    \n    ![Untitled](Untitled%2038.png)\n    \n\n## 复合条件测试\n\n- `&&和||` 用法\n    \n    ```bash\n    [ condition1 ] && [ condition2 ]\n    [ condition1 ] || [ condition2 ]\n    ```\n    \n    - 第一种布尔运算使用AND布尔运算符来组合两个条件。要让then部分的命令执行，两个条件都必须满足。\n    - 第二种布尔运算使用OR布尔运算符来组合两个条件。如果任意条件为TRUE，then部分的命令就会执行。\n\n## case命令\n\n在shell编程中，case语句是一种多分支条件语句，用于测试变量或表达式是否与某些模式匹配，并执行相应的命令。\n\ncase语句通常用于替代if-then-else语句，特别是在需要测试一个变量或表达式是否匹配多个模式的情况下。case语句的语法结构如下：\n\n```bash\ncase expression in\n  pattern1)\n    command1\n    ;;\n  pattern2)\n    command2\n    ;;\n  pattern3)\n    command3\n    ;;\n  *)\n    default_command\n    ;;\nesac\n```\n\n其中，expression是要测试的变量或表达式，pattern1、pattern2、pattern3等是匹配模式，command1、command2、command3等是匹配模式成立时要执行的命令，**`;;`**表示命令结束，**`*)`**表示如果所有模式都不匹配时要执行的默认命令。\n\n![Untitled](Untitled%2039.png)\n\n## 练习题\n\n- 使用 `read`要求用户输入一个数字。\n- 使用 `if`判断该数字是否在`0-9`之间，如果不满足则停止脚本。\n- 然后使用 **`case`** 语句输出对应数字`0-3`的英文，对于其他数字输出一个提示“该数字在4-9之间”。","source":"_posts/linux_shell/3.Shell条件测试.md","raw":"---\ntitle: Shell条件测试\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n- 结构化命令\n    \n    Shell按照命令在脚本中出现的顺序依次进行处理。对顺序操作来说，这已经足够了，因为在这种操作环境下，你想要的就是所有的命令按照正确的顺序执行。\n    \n    许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令（structured command）\n    \n    常见的条件测试命令： `if-then语句` 、 `case语句` 、 `for语句` 、 `while语句` \n    \n- if条件语句\n    - if条件语句通常由以下三个关键字组成：\n        - if：用于指定要测试的条件。\n        - then：用于指定如果条件为true时要执行的指令。\n        - else：用于指定如果条件为false时要执行的指令。\n    - 语法格式如下：\n    \n    ![Untitled](Untitled%2026.png)\n    \n    - 在其他编程语言中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。但bash shell的if语句并不是这么做的。bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码是0（该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值，then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。fi语句用来表示if-then语句到此结束。\n        \n        ![Untitled](Untitled%2027.png)\n        \n    - `if-then` 语句的另一种形式\n        \n        ```bash\n        if command; then\n        commands\n        fi\n        ```\n        \n    - 练习\n        \n        ![Untitled](Untitled%2028.png)\n        \n    - `if-then-else` 双分支语句\n        \n        当if语句中的命令返回退出状态码0时，then部分中的命令会被执行，这跟普通的if-then\n        语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。\n        \n        ![Untitled](Untitled%2029.png)\n        \n    - `if-then-elif-else` 多分支语句\n        \n        ![Untitled](Untitled%2030.png)\n        \n- `test` 命令\n    \n    如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。\n    \n    - test命令格式\n        \n        `test condition` \n        \n        ```bash\n        if test condition\n        then\n        \tcommands\n        fi\n        ```\n        \n        ![Untitled](Untitled%2031.png)\n        \n    - bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。\n        \n        ```bash\n        if [ condition ]\n        then\n        \tcommands\n        fi\n        ```\n        \n        方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。\n        \n        test命令可以判断三类条件：\n        \n        - 文件比较\n        - 字符串比较\n        - 数值比较\n- 文件比较\n    \n    这些测试条件使你能够在shell脚本中检查文件系统中的文件。它们经常出现在需要进行文件访问的脚本中，文件比较的操作符如下：\n    \n    ![Untitled](Untitled%2032.png)\n    \n    ![Untitled](Untitled%2033.png)\n    \n    ![Untitled](Untitled%2034.png)\n    \n- 字符串比较\n    \n    ![Untitled](Untitled%2035.png)\n    \n    ![Untitled](Untitled%2036.png)\n    \n    - 大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名\n    \n    ![Untitled](Untitled%2037.png)\n    \n- 数值比较\n    \n    数值条件测试可以用在数字和变量上。\n    \n    ![Untitled](Untitled%2038.png)\n    \n\n## 复合条件测试\n\n- `&&和||` 用法\n    \n    ```bash\n    [ condition1 ] && [ condition2 ]\n    [ condition1 ] || [ condition2 ]\n    ```\n    \n    - 第一种布尔运算使用AND布尔运算符来组合两个条件。要让then部分的命令执行，两个条件都必须满足。\n    - 第二种布尔运算使用OR布尔运算符来组合两个条件。如果任意条件为TRUE，then部分的命令就会执行。\n\n## case命令\n\n在shell编程中，case语句是一种多分支条件语句，用于测试变量或表达式是否与某些模式匹配，并执行相应的命令。\n\ncase语句通常用于替代if-then-else语句，特别是在需要测试一个变量或表达式是否匹配多个模式的情况下。case语句的语法结构如下：\n\n```bash\ncase expression in\n  pattern1)\n    command1\n    ;;\n  pattern2)\n    command2\n    ;;\n  pattern3)\n    command3\n    ;;\n  *)\n    default_command\n    ;;\nesac\n```\n\n其中，expression是要测试的变量或表达式，pattern1、pattern2、pattern3等是匹配模式，command1、command2、command3等是匹配模式成立时要执行的命令，**`;;`**表示命令结束，**`*)`**表示如果所有模式都不匹配时要执行的默认命令。\n\n![Untitled](Untitled%2039.png)\n\n## 练习题\n\n- 使用 `read`要求用户输入一个数字。\n- 使用 `if`判断该数字是否在`0-9`之间，如果不满足则停止脚本。\n- 然后使用 **`case`** 语句输出对应数字`0-3`的英文，对于其他数字输出一个提示“该数字在4-9之间”。","slug":"linux_shell/3.Shell条件测试","published":1,"updated":"2023-06-10T08:09:30.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cliuf72wc0004j1nzguix6j59","content":"<ul>\n<li><p>结构化命令</p>\n<p>  Shell按照命令在脚本中出现的顺序依次进行处理。对顺序操作来说，这已经足够了，因为在这种操作环境下，你想要的就是所有的命令按照正确的顺序执行。</p>\n<p>  许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令（structured command）</p>\n<p>  常见的条件测试命令： <code>if-then语句</code> 、 <code>case语句</code> 、 <code>for语句</code> 、 <code>while语句</code> </p>\n</li>\n<li><p>if条件语句</p>\n<ul>\n<li>if条件语句通常由以下三个关键字组成：<ul>\n<li>if：用于指定要测试的条件。</li>\n<li>then：用于指定如果条件为true时要执行的指令。</li>\n<li>else：用于指定如果条件为false时要执行的指令。</li>\n</ul>\n</li>\n<li>语法格式如下：</li>\n</ul>\n<p>  <img src=\"/Untitled%2026.png\" alt=\"Untitled\"></p>\n<ul>\n<li><p>在其他编程语言中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。但bash shell的if语句并不是这么做的。bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码是0（该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值，then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。fi语句用来表示if-then语句到此结束。</p>\n<p>  <img src=\"/Untitled%2027.png\" alt=\"Untitled\"></p>\n</li>\n<li><p><code>if-then</code> 语句的另一种形式</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">command</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">commands</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>练习</p>\n<p>  <img src=\"/Untitled%2028.png\" alt=\"Untitled\"></p>\n</li>\n<li><p><code>if-then-else</code> 双分支语句</p>\n<p>  当if语句中的命令返回退出状态码0时，then部分中的命令会被执行，这跟普通的if-then<br>  语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。</p>\n<p>  <img src=\"/Untitled%2029.png\" alt=\"Untitled\"></p>\n</li>\n<li><p><code>if-then-elif-else</code> 多分支语句</p>\n<p>  <img src=\"/Untitled%2030.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n</li>\n<li><p><code>test</code> 命令</p>\n<p>  如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。</p>\n<ul>\n<li><p>test命令格式</p>\n<p>  <code>test condition</code> </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">test</span> condition</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">\tcommands</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<p>  <img src=\"/Untitled%2031.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ condition ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">\tcommands</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<p>  方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。</p>\n<p>  test命令可以判断三类条件：</p>\n<ul>\n<li>文件比较</li>\n<li>字符串比较</li>\n<li>数值比较</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>文件比较</p>\n<p>  这些测试条件使你能够在shell脚本中检查文件系统中的文件。它们经常出现在需要进行文件访问的脚本中，文件比较的操作符如下：</p>\n<p>  <img src=\"/Untitled%2032.png\" alt=\"Untitled\"></p>\n<p>  <img src=\"/Untitled%2033.png\" alt=\"Untitled\"></p>\n<p>  <img src=\"/Untitled%2034.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>字符串比较</p>\n<p>  <img src=\"/Untitled%2035.png\" alt=\"Untitled\"></p>\n<p>  <img src=\"/Untitled%2036.png\" alt=\"Untitled\"></p>\n<ul>\n<li>大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名</li>\n</ul>\n<p>  <img src=\"/Untitled%2037.png\" alt=\"Untitled\">\n  </p>\n</li>\n<li><p>数值比较</p>\n<p>  数值条件测试可以用在数字和变量上。</p>\n<p>  <img src=\"/Untitled%2038.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n<h2 id=\"复合条件测试\"><a href=\"#复合条件测试\" class=\"headerlink\" title=\"复合条件测试\"></a>复合条件测试</h2><ul>\n<li><p><code>&amp;&amp;和||</code> 用法</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ condition1 ] &amp;&amp; [ condition2 ]</span><br><span class=\"line\">[ condition1 ] || [ condition2 ]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一种布尔运算使用AND布尔运算符来组合两个条件。要让then部分的命令执行，两个条件都必须满足。</li>\n<li>第二种布尔运算使用OR布尔运算符来组合两个条件。如果任意条件为TRUE，then部分的命令就会执行。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"case命令\"><a href=\"#case命令\" class=\"headerlink\" title=\"case命令\"></a>case命令</h2><p>在shell编程中，case语句是一种多分支条件语句，用于测试变量或表达式是否与某些模式匹配，并执行相应的命令。</p>\n<p>case语句通常用于替代if-then-else语句，特别是在需要测试一个变量或表达式是否匹配多个模式的情况下。case语句的语法结构如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> expression <span class=\"keyword\">in</span></span><br><span class=\"line\">  pattern1)</span><br><span class=\"line\">    command1</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">  pattern2)</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">  pattern3)</span><br><span class=\"line\">    command3</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">  *)</span><br><span class=\"line\">    default_command</span><br><span class=\"line\">    ;;</span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，expression是要测试的变量或表达式，pattern1、pattern2、pattern3等是匹配模式，command1、command2、command3等是匹配模式成立时要执行的命令，**<code>;;</code><strong>表示命令结束，</strong><code>*)</code>**表示如果所有模式都不匹配时要执行的默认命令。</p>\n<p><img src=\"/Untitled%2039.png\" alt=\"Untitled\"></p>\n<h2 id=\"练习题\"><a href=\"#练习题\" class=\"headerlink\" title=\"练习题\"></a>练习题</h2><ul>\n<li>使用 <code>read</code>要求用户输入一个数字。</li>\n<li>使用 <code>if</code>判断该数字是否在<code>0-9</code>之间，如果不满足则停止脚本。</li>\n<li>然后使用 <strong><code>case</code></strong> 语句输出对应数字<code>0-3</code>的英文，对于其他数字输出一个提示“该数字在4-9之间”。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>结构化命令</p>\n<p>  Shell按照命令在脚本中出现的顺序依次进行处理。对顺序操作来说，这已经足够了，因为在这种操作环境下，你想要的就是所有的命令按照正确的顺序执行。</p>\n<p>  许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令（structured command）</p>\n<p>  常见的条件测试命令： <code>if-then语句</code> 、 <code>case语句</code> 、 <code>for语句</code> 、 <code>while语句</code> </p>\n</li>\n<li><p>if条件语句</p>\n<ul>\n<li>if条件语句通常由以下三个关键字组成：<ul>\n<li>if：用于指定要测试的条件。</li>\n<li>then：用于指定如果条件为true时要执行的指令。</li>\n<li>else：用于指定如果条件为false时要执行的指令。</li>\n</ul>\n</li>\n<li>语法格式如下：</li>\n</ul>\n<p>  <img src=\"/Untitled%2026.png\" alt=\"Untitled\"></p>\n<ul>\n<li><p>在其他编程语言中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。但bash shell的if语句并不是这么做的。bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码是0（该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值，then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。fi语句用来表示if-then语句到此结束。</p>\n<p>  <img src=\"/Untitled%2027.png\" alt=\"Untitled\"></p>\n</li>\n<li><p><code>if-then</code> 语句的另一种形式</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">command</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">commands</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>练习</p>\n<p>  <img src=\"/Untitled%2028.png\" alt=\"Untitled\"></p>\n</li>\n<li><p><code>if-then-else</code> 双分支语句</p>\n<p>  当if语句中的命令返回退出状态码0时，then部分中的命令会被执行，这跟普通的if-then<br>  语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。</p>\n<p>  <img src=\"/Untitled%2029.png\" alt=\"Untitled\"></p>\n</li>\n<li><p><code>if-then-elif-else</code> 多分支语句</p>\n<p>  <img src=\"/Untitled%2030.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n</li>\n<li><p><code>test</code> 命令</p>\n<p>  如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。</p>\n<ul>\n<li><p>test命令格式</p>\n<p>  <code>test condition</code> </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">test</span> condition</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">\tcommands</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<p>  <img src=\"/Untitled%2031.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ condition ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">\tcommands</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<p>  方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。</p>\n<p>  test命令可以判断三类条件：</p>\n<ul>\n<li>文件比较</li>\n<li>字符串比较</li>\n<li>数值比较</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>文件比较</p>\n<p>  这些测试条件使你能够在shell脚本中检查文件系统中的文件。它们经常出现在需要进行文件访问的脚本中，文件比较的操作符如下：</p>\n<p>  <img src=\"/Untitled%2032.png\" alt=\"Untitled\"></p>\n<p>  <img src=\"/Untitled%2033.png\" alt=\"Untitled\"></p>\n<p>  <img src=\"/Untitled%2034.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>字符串比较</p>\n<p>  <img src=\"/Untitled%2035.png\" alt=\"Untitled\"></p>\n<p>  <img src=\"/Untitled%2036.png\" alt=\"Untitled\"></p>\n<ul>\n<li>大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名</li>\n</ul>\n<p>  <img src=\"/Untitled%2037.png\" alt=\"Untitled\">\n  </p>\n</li>\n<li><p>数值比较</p>\n<p>  数值条件测试可以用在数字和变量上。</p>\n<p>  <img src=\"/Untitled%2038.png\" alt=\"Untitled\"></p>\n</li>\n</ul>\n<h2 id=\"复合条件测试\"><a href=\"#复合条件测试\" class=\"headerlink\" title=\"复合条件测试\"></a>复合条件测试</h2><ul>\n<li><p><code>&amp;&amp;和||</code> 用法</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ condition1 ] &amp;&amp; [ condition2 ]</span><br><span class=\"line\">[ condition1 ] || [ condition2 ]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一种布尔运算使用AND布尔运算符来组合两个条件。要让then部分的命令执行，两个条件都必须满足。</li>\n<li>第二种布尔运算使用OR布尔运算符来组合两个条件。如果任意条件为TRUE，then部分的命令就会执行。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"case命令\"><a href=\"#case命令\" class=\"headerlink\" title=\"case命令\"></a>case命令</h2><p>在shell编程中，case语句是一种多分支条件语句，用于测试变量或表达式是否与某些模式匹配，并执行相应的命令。</p>\n<p>case语句通常用于替代if-then-else语句，特别是在需要测试一个变量或表达式是否匹配多个模式的情况下。case语句的语法结构如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> expression <span class=\"keyword\">in</span></span><br><span class=\"line\">  pattern1)</span><br><span class=\"line\">    command1</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">  pattern2)</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">  pattern3)</span><br><span class=\"line\">    command3</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">  *)</span><br><span class=\"line\">    default_command</span><br><span class=\"line\">    ;;</span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，expression是要测试的变量或表达式，pattern1、pattern2、pattern3等是匹配模式，command1、command2、command3等是匹配模式成立时要执行的命令，**<code>;;</code><strong>表示命令结束，</strong><code>*)</code>**表示如果所有模式都不匹配时要执行的默认命令。</p>\n<p><img src=\"/Untitled%2039.png\" alt=\"Untitled\"></p>\n<h2 id=\"练习题\"><a href=\"#练习题\" class=\"headerlink\" title=\"练习题\"></a>练习题</h2><ul>\n<li>使用 <code>read</code>要求用户输入一个数字。</li>\n<li>使用 <code>if</code>判断该数字是否在<code>0-9</code>之间，如果不满足则停止脚本。</li>\n<li>然后使用 <strong><code>case</code></strong> 语句输出对应数字<code>0-3</code>的英文，对于其他数字输出一个提示“该数字在4-9之间”。</li>\n</ul>\n"},{"title":"Shell循环","date":"2023-04-18T03:31:23.000Z","_content":"\n上一章学习的结构化命令中的 `if-then` 和 `case` 语句，其中 `if-then` 语句是通过检查命令的执行结果或者表达式（文件比较、字符串比较、数值比较）的结果来控制脚本的执行流程。\n\n### Shell编程中的循环语句\n\n在Shell脚本中，循环语句是一种重要的控制结构，用于多次执行同一段代码。Shell脚本中提供了多种循环语句，包括`for`、`while`、`until`三种。\n\n### for 循环\n\n`for` 循环是一种针对列表中每个元素执行相同操作的循环结构。该语句会将列表中的每个元素依次赋值给变量，并执行循环体中的语句。其基本语法格式如下：\n\n```\nfor 变量名 in 列表\ndo\n    循环体\ndone\n\n```\n\n其中，`变量名`是一个新的变量，用于存储列表中的每个元素；`列表`是一个由空格分隔的参数列表。\n\n例如，下面的代码中，`for` 循环遍历了一个包含 5 个元素的列表，依次输出了每个元素：\n\n```bash\n#!/bin/bash\nfor i in 1 2 3 4 5\ndo\n    echo \"列表中的元素：$i\"\ndone,rk\n\necho \"i = $i\"\n\n```\n\n以上代码会输出以下结果：\n\n```\n列表中的元素：1\n列表中的元素：2\n列表中的元素：3\n列表中的元素：4\n列表中的元素：5\ni = 5\n```\n\n- 读取列表中的复杂值\n    \n    ```bash\n    #!/bin/bash\n    for i in I don't know if this'll work\n    do\n        echo \"word:$i\"\n    done\n    ```\n    \n    以上代码输出以下结果：\n    \n    ```\n    word:I\n    word:dont know if thisll\n    word:work\n    ```\n    \n    - 两种方法解决列表中单引号引用的问题\n        \n        使用转义字符（反斜杠）将单引号转义\n        \n        使用双引号定义用到单引号的值\n        \n        ```bash\n        #!/bin/bash\n        for i in I don\\'t know if this\\'ll work\n        do\n            echo \"word:$i\"\n        done\n        \n        for i in I \"don't\" know if \"this'll\" work\n        do\n            echo \"word:$i\"\n        done\n        ```\n        \n    - 使用双引号引用输出多个单词\n        \n        ```bash\n        #!/bin/bash\n        for i in \"1 2\" \"3 4\" 5\n        do\n            echo \"列表中的元素：$i\"\n        done\n        \n        echo \"i = $i\"\n        ```\n        \n        以上代码输出以下结果：\n        \n        ```\n        列表中的元素：1 2\n        列表中的元素：3 4\n        列表中的元素：5\n        i = 5\n        ```\n        \n- 从变量读取列表\n    \n    ```bash\n    #!/bin/bash\n    \n    list=\"1 2 3 4 5\"\n    list=$list\" 6\"\n    \n    for i in $list\n    do\n        echo \"列表中的元素：$i\"\n    done\n    ```\n    \n    以上代码输出以下结果：\n    \n    ```bash\n    列表中的元素：1\n    列表中的元素：2\n    列表中的元素：3\n    列表中的元素：4\n    列表中的元素：5\n    列表中的元素：6\n    ```\n    \n- 通过命令读取\n    \n    ```bash\n    #!/bin/bash\n    \n    IFS=$'\\n'\n    \n    cat > test.sh <<EOF\n    1 2 3\n    2\n    3\n    4\n    5\n    EOF\n    \n    for i in `cat test.sh`\n    do\n        echo \"列表中的元素：$i\"\n    done\n    ```\n    \n- 用通配符读取目录\n    \n    在 Shell 编程中，通配符是一种用于匹配文件名或目录名的特殊字符。通配符可以帮助你快速地匹配一组文件或目录，从而方便地对它们进行操作。\n    \n    常见的通配符包括：\n    \n    - `*`：匹配任意长度的任意字符，包括空字符串。\n    - `?`：匹配任意一个字符。\n    - `[...]`：匹配括号内列举的任意一个字符。\n    - `[^...]`：匹配除了括号内列举的任意一个字符以外的所有字符。\n    \n    以下是一些通配符匹配的示例：\n    \n    - `*.txt`：匹配所有以 `.txt` 结尾的文件，如 `file1.txt`、`file2.txt` 等。\n    - `file?.txt`：匹配所有文件名为 `file` 开头，后面跟着任意一个字符，最后以 `.txt` 结尾的文件，如 `file1.txt`、`fileA.txt` 等。\n    - `[abc].txt`：匹配所有文件名为 `a.txt`、`b.txt`、`c.txt` 的文件。\n    - `[^abc].txt`：匹配除了文件名为 `a.txt`、`b.txt`、`c.txt` 以外的所有以 `.txt` 结尾的文件。\n    \n    ```bash\n    #!/bin/bash\n    \n    touch ~/file{1..2}\n    mkdir ~/dir{1..3}\n    \n    for file in ~/*\n    do\n        if [ -d \"$file\" ]\n        then\n    \t\t\t  echo \"$file is a directory\"\n        elif [ -f \"$file\" ]\n        then\n            echo \"$file is a file\"\n        fi\n    done\n    ```\n    \n    练习：\n    \n    通过shell脚本实现批量主机检测\n    \n    ```bash\n    #!/bin/bash\n    >ip.txt\n    \n    for i in {2..254}\n    do\n        {\n        ip=192.168.13.$i\n        ping -c1 -W1 $ip &>/dev/null\n        if [ $? -eq 0 ]\n        then\n    \t\t\t\techo \"$ip\" |tee -a ip.txt\n    \t\tfi\n    \t\t}&\n    done\n    wait\n    echo \"finish...\"\n    ```\n    \n\n### while 循环\n\n`while` 循环是一种基于条件判断的循环结构，当条件满足时就会一直执行循环体中的语句。其基本语法格式如下：\n\n```\nwhile [ 条件 ]\ndo\n    循环体\ndone\n\n```\n\n其中，`条件`是一个可以执行的测试命令或表达式，如果返回值为0，则为真，循环继续执行；否则为假，循环结束。\n\n例如，下面的代码中，`while` 循环会一直执行，直到变量 `i` 的值达到 5：\n\n```bash\n#!/bin/sh\ni=1\nwhile [ $i -le 5 ]\ndo\n    echo \"当前变量的值是 $i\"\n    i=$(( $i + 1 ))\ndone\n\n```\n\n以上代码会输出以下结果：\n\n```\n当前变量的值是 1\n当前变量的值是 2\n当前变量的值是 3\n当前变量的值是 4\n当前变量的值是 5\n\n```\n\n### until 循环\n\n`until` 循环与 `while` 循环类似，但是只有当条件为假时才会执行循环体中的语句。其基本语法格式如下：\n\n```\nuntil [ 条件 ]\ndo\n    循环体\ndone\n\n```\n\n其中，`条件`是一个可以执行的测试命令或表达式，如果返回值为0，则为假，循环继续执行；否则为真，循环结束。\n\n例如，下面的代码中，`until` 循环会一直执行，直到变量 `i` 的值达到 5：\n\n```bash\n#!/bin/bash\ni=1\nuntil [ $i -gt 5 ]\ndo\n    echo \"当前变量的值是 $i\"\n    i=$(( $i + 1 ))\ndone\n\n```\n\n以上代码会输出以下结果：\n\n```\n当前变量的值是 1\n当前变量的值是 2\n当前变量的值是 3\n当前变量的值是 4\n当前变量的值是 5\n\n```\n\n### 循环控制语句\n\n在循环中，有时需要跳过某些循环或终止循环的执行，Shell脚本提供了以下三种循环控制语句：\n\n- `break`语句：用于强制退出循环，跳出循环体，执行循环后面的语句。\n- `continue`语句：用于跳过循环体中的一个迭代，直接进入下一个迭代。\n- `return`语句：用于退出函数，返回到函数调用处。\n\n例如，下面的代码演示了如何在循环中使用 `break` 和 `continue` 语句：\n\n```bash\n#!/bin/bash\ni=1\nwhile [ $i -le 100 ]\ndo\n    if [ $i -eq 3 ]\n    then\n        echo \"跳过第 $i 次迭代\"\n        i=$(( $i + 1 ))\n        continue\n    fi\n    if [ $i -eq 5 ]\n    then\n        echo \"退出循环\"\n        break\n    fi\n    echo \"第 $i 次迭代\"\n    i=$(( $i + 1 ))\ndone\n\n```\n\n以上代码会输出以下结果：\n\n```\n第 1 次迭代\n第 2 次迭代\n跳过第 3 次迭代\n第 4 次迭代\n退出循环\n\n```","source":"_posts/linux_shell/4.Shell循环.md","raw":"---\ntitle: Shell循环\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n上一章学习的结构化命令中的 `if-then` 和 `case` 语句，其中 `if-then` 语句是通过检查命令的执行结果或者表达式（文件比较、字符串比较、数值比较）的结果来控制脚本的执行流程。\n\n### Shell编程中的循环语句\n\n在Shell脚本中，循环语句是一种重要的控制结构，用于多次执行同一段代码。Shell脚本中提供了多种循环语句，包括`for`、`while`、`until`三种。\n\n### for 循环\n\n`for` 循环是一种针对列表中每个元素执行相同操作的循环结构。该语句会将列表中的每个元素依次赋值给变量，并执行循环体中的语句。其基本语法格式如下：\n\n```\nfor 变量名 in 列表\ndo\n    循环体\ndone\n\n```\n\n其中，`变量名`是一个新的变量，用于存储列表中的每个元素；`列表`是一个由空格分隔的参数列表。\n\n例如，下面的代码中，`for` 循环遍历了一个包含 5 个元素的列表，依次输出了每个元素：\n\n```bash\n#!/bin/bash\nfor i in 1 2 3 4 5\ndo\n    echo \"列表中的元素：$i\"\ndone,rk\n\necho \"i = $i\"\n\n```\n\n以上代码会输出以下结果：\n\n```\n列表中的元素：1\n列表中的元素：2\n列表中的元素：3\n列表中的元素：4\n列表中的元素：5\ni = 5\n```\n\n- 读取列表中的复杂值\n    \n    ```bash\n    #!/bin/bash\n    for i in I don't know if this'll work\n    do\n        echo \"word:$i\"\n    done\n    ```\n    \n    以上代码输出以下结果：\n    \n    ```\n    word:I\n    word:dont know if thisll\n    word:work\n    ```\n    \n    - 两种方法解决列表中单引号引用的问题\n        \n        使用转义字符（反斜杠）将单引号转义\n        \n        使用双引号定义用到单引号的值\n        \n        ```bash\n        #!/bin/bash\n        for i in I don\\'t know if this\\'ll work\n        do\n            echo \"word:$i\"\n        done\n        \n        for i in I \"don't\" know if \"this'll\" work\n        do\n            echo \"word:$i\"\n        done\n        ```\n        \n    - 使用双引号引用输出多个单词\n        \n        ```bash\n        #!/bin/bash\n        for i in \"1 2\" \"3 4\" 5\n        do\n            echo \"列表中的元素：$i\"\n        done\n        \n        echo \"i = $i\"\n        ```\n        \n        以上代码输出以下结果：\n        \n        ```\n        列表中的元素：1 2\n        列表中的元素：3 4\n        列表中的元素：5\n        i = 5\n        ```\n        \n- 从变量读取列表\n    \n    ```bash\n    #!/bin/bash\n    \n    list=\"1 2 3 4 5\"\n    list=$list\" 6\"\n    \n    for i in $list\n    do\n        echo \"列表中的元素：$i\"\n    done\n    ```\n    \n    以上代码输出以下结果：\n    \n    ```bash\n    列表中的元素：1\n    列表中的元素：2\n    列表中的元素：3\n    列表中的元素：4\n    列表中的元素：5\n    列表中的元素：6\n    ```\n    \n- 通过命令读取\n    \n    ```bash\n    #!/bin/bash\n    \n    IFS=$'\\n'\n    \n    cat > test.sh <<EOF\n    1 2 3\n    2\n    3\n    4\n    5\n    EOF\n    \n    for i in `cat test.sh`\n    do\n        echo \"列表中的元素：$i\"\n    done\n    ```\n    \n- 用通配符读取目录\n    \n    在 Shell 编程中，通配符是一种用于匹配文件名或目录名的特殊字符。通配符可以帮助你快速地匹配一组文件或目录，从而方便地对它们进行操作。\n    \n    常见的通配符包括：\n    \n    - `*`：匹配任意长度的任意字符，包括空字符串。\n    - `?`：匹配任意一个字符。\n    - `[...]`：匹配括号内列举的任意一个字符。\n    - `[^...]`：匹配除了括号内列举的任意一个字符以外的所有字符。\n    \n    以下是一些通配符匹配的示例：\n    \n    - `*.txt`：匹配所有以 `.txt` 结尾的文件，如 `file1.txt`、`file2.txt` 等。\n    - `file?.txt`：匹配所有文件名为 `file` 开头，后面跟着任意一个字符，最后以 `.txt` 结尾的文件，如 `file1.txt`、`fileA.txt` 等。\n    - `[abc].txt`：匹配所有文件名为 `a.txt`、`b.txt`、`c.txt` 的文件。\n    - `[^abc].txt`：匹配除了文件名为 `a.txt`、`b.txt`、`c.txt` 以外的所有以 `.txt` 结尾的文件。\n    \n    ```bash\n    #!/bin/bash\n    \n    touch ~/file{1..2}\n    mkdir ~/dir{1..3}\n    \n    for file in ~/*\n    do\n        if [ -d \"$file\" ]\n        then\n    \t\t\t  echo \"$file is a directory\"\n        elif [ -f \"$file\" ]\n        then\n            echo \"$file is a file\"\n        fi\n    done\n    ```\n    \n    练习：\n    \n    通过shell脚本实现批量主机检测\n    \n    ```bash\n    #!/bin/bash\n    >ip.txt\n    \n    for i in {2..254}\n    do\n        {\n        ip=192.168.13.$i\n        ping -c1 -W1 $ip &>/dev/null\n        if [ $? -eq 0 ]\n        then\n    \t\t\t\techo \"$ip\" |tee -a ip.txt\n    \t\tfi\n    \t\t}&\n    done\n    wait\n    echo \"finish...\"\n    ```\n    \n\n### while 循环\n\n`while` 循环是一种基于条件判断的循环结构，当条件满足时就会一直执行循环体中的语句。其基本语法格式如下：\n\n```\nwhile [ 条件 ]\ndo\n    循环体\ndone\n\n```\n\n其中，`条件`是一个可以执行的测试命令或表达式，如果返回值为0，则为真，循环继续执行；否则为假，循环结束。\n\n例如，下面的代码中，`while` 循环会一直执行，直到变量 `i` 的值达到 5：\n\n```bash\n#!/bin/sh\ni=1\nwhile [ $i -le 5 ]\ndo\n    echo \"当前变量的值是 $i\"\n    i=$(( $i + 1 ))\ndone\n\n```\n\n以上代码会输出以下结果：\n\n```\n当前变量的值是 1\n当前变量的值是 2\n当前变量的值是 3\n当前变量的值是 4\n当前变量的值是 5\n\n```\n\n### until 循环\n\n`until` 循环与 `while` 循环类似，但是只有当条件为假时才会执行循环体中的语句。其基本语法格式如下：\n\n```\nuntil [ 条件 ]\ndo\n    循环体\ndone\n\n```\n\n其中，`条件`是一个可以执行的测试命令或表达式，如果返回值为0，则为假，循环继续执行；否则为真，循环结束。\n\n例如，下面的代码中，`until` 循环会一直执行，直到变量 `i` 的值达到 5：\n\n```bash\n#!/bin/bash\ni=1\nuntil [ $i -gt 5 ]\ndo\n    echo \"当前变量的值是 $i\"\n    i=$(( $i + 1 ))\ndone\n\n```\n\n以上代码会输出以下结果：\n\n```\n当前变量的值是 1\n当前变量的值是 2\n当前变量的值是 3\n当前变量的值是 4\n当前变量的值是 5\n\n```\n\n### 循环控制语句\n\n在循环中，有时需要跳过某些循环或终止循环的执行，Shell脚本提供了以下三种循环控制语句：\n\n- `break`语句：用于强制退出循环，跳出循环体，执行循环后面的语句。\n- `continue`语句：用于跳过循环体中的一个迭代，直接进入下一个迭代。\n- `return`语句：用于退出函数，返回到函数调用处。\n\n例如，下面的代码演示了如何在循环中使用 `break` 和 `continue` 语句：\n\n```bash\n#!/bin/bash\ni=1\nwhile [ $i -le 100 ]\ndo\n    if [ $i -eq 3 ]\n    then\n        echo \"跳过第 $i 次迭代\"\n        i=$(( $i + 1 ))\n        continue\n    fi\n    if [ $i -eq 5 ]\n    then\n        echo \"退出循环\"\n        break\n    fi\n    echo \"第 $i 次迭代\"\n    i=$(( $i + 1 ))\ndone\n\n```\n\n以上代码会输出以下结果：\n\n```\n第 1 次迭代\n第 2 次迭代\n跳过第 3 次迭代\n第 4 次迭代\n退出循环\n\n```","slug":"linux_shell/4.Shell循环","published":1,"updated":"2023-06-10T08:09:30.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cliuf72wd0005j1nz5l7lb9sg","content":"<p>上一章学习的结构化命令中的 <code>if-then</code> 和 <code>case</code> 语句，其中 <code>if-then</code> 语句是通过检查命令的执行结果或者表达式（文件比较、字符串比较、数值比较）的结果来控制脚本的执行流程。</p>\n<h3 id=\"Shell编程中的循环语句\"><a href=\"#Shell编程中的循环语句\" class=\"headerlink\" title=\"Shell编程中的循环语句\"></a>Shell编程中的循环语句</h3><p>在Shell脚本中，循环语句是一种重要的控制结构，用于多次执行同一段代码。Shell脚本中提供了多种循环语句，包括<code>for</code>、<code>while</code>、<code>until</code>三种。</p>\n<h3 id=\"for-循环\"><a href=\"#for-循环\" class=\"headerlink\" title=\"for 循环\"></a>for 循环</h3><p><code>for</code> 循环是一种针对列表中每个元素执行相同操作的循环结构。该语句会将列表中的每个元素依次赋值给变量，并执行循环体中的语句。其基本语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for 变量名 in 列表</span><br><span class=\"line\">do</span><br><span class=\"line\">    循环体</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>变量名</code>是一个新的变量，用于存储列表中的每个元素；<code>列表</code>是一个由空格分隔的参数列表。</p>\n<p>例如，下面的代码中，<code>for</code> 循环遍历了一个包含 5 个元素的列表，依次输出了每个元素：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> 1 2 3 4 5</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;列表中的元素：<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span>,rk</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;i = <span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上代码会输出以下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">列表中的元素：1</span><br><span class=\"line\">列表中的元素：2</span><br><span class=\"line\">列表中的元素：3</span><br><span class=\"line\">列表中的元素：4</span><br><span class=\"line\">列表中的元素：5</span><br><span class=\"line\">i = 5</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>读取列表中的复杂值</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> I don<span class=\"string\">&#x27;t know if this&#x27;</span>ll work</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;word:<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n<p>  以上代码输出以下结果：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">word:I</span><br><span class=\"line\">word:dont know if thisll</span><br><span class=\"line\">word:work</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>两种方法解决列表中单引号引用的问题</p>\n<p>  使用转义字符（反斜杠）将单引号转义</p>\n<p>  使用双引号定义用到单引号的值</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> I don\\<span class=\"string\">&#x27;t know if this\\&#x27;</span>ll work</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;word:<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> I <span class=\"string\">&quot;don&#x27;t&quot;</span> know <span class=\"keyword\">if</span> <span class=\"string\">&quot;this&#x27;ll&quot;</span> work</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;word:<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用双引号引用输出多个单词</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;1 2&quot;</span> <span class=\"string\">&quot;3 4&quot;</span> 5</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;列表中的元素：<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;i = <span class=\"variable\">$i</span>&quot;</span></span><br></pre></td></tr></table></figure>\n<p>  以上代码输出以下结果：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">列表中的元素：1 2</span><br><span class=\"line\">列表中的元素：3 4</span><br><span class=\"line\">列表中的元素：5</span><br><span class=\"line\">i = 5</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>从变量读取列表</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">list=<span class=\"string\">&quot;1 2 3 4 5&quot;</span></span><br><span class=\"line\">list=<span class=\"variable\">$list</span><span class=\"string\">&quot; 6&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"variable\">$list</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;列表中的元素：<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n<p>  以上代码输出以下结果：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">列表中的元素：1</span><br><span class=\"line\">列表中的元素：2</span><br><span class=\"line\">列表中的元素：3</span><br><span class=\"line\">列表中的元素：4</span><br><span class=\"line\">列表中的元素：5</span><br><span class=\"line\">列表中的元素：6</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过命令读取</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">IFS=$<span class=\"string\">&#x27;\\n&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; test.sh &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">1 2 3</span></span><br><span class=\"line\"><span class=\"string\">2</span></span><br><span class=\"line\"><span class=\"string\">3</span></span><br><span class=\"line\"><span class=\"string\">4</span></span><br><span class=\"line\"><span class=\"string\">5</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> `<span class=\"built_in\">cat</span> test.sh`</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;列表中的元素：<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用通配符读取目录</p>\n<p>  在 Shell 编程中，通配符是一种用于匹配文件名或目录名的特殊字符。通配符可以帮助你快速地匹配一组文件或目录，从而方便地对它们进行操作。</p>\n<p>  常见的通配符包括：</p>\n<ul>\n<li><code>*</code>：匹配任意长度的任意字符，包括空字符串。</li>\n<li><code>?</code>：匹配任意一个字符。</li>\n<li><code>[...]</code>：匹配括号内列举的任意一个字符。</li>\n<li><code>[^...]</code>：匹配除了括号内列举的任意一个字符以外的所有字符。</li>\n</ul>\n<p>  以下是一些通配符匹配的示例：</p>\n<ul>\n<li><code>*.txt</code>：匹配所有以 <code>.txt</code> 结尾的文件，如 <code>file1.txt</code>、<code>file2.txt</code> 等。</li>\n<li><code>file?.txt</code>：匹配所有文件名为 <code>file</code> 开头，后面跟着任意一个字符，最后以 <code>.txt</code> 结尾的文件，如 <code>file1.txt</code>、<code>fileA.txt</code> 等。</li>\n<li><code>[abc].txt</code>：匹配所有文件名为 <code>a.txt</code>、<code>b.txt</code>、<code>c.txt</code> 的文件。</li>\n<li><code>[^abc].txt</code>：匹配除了文件名为 <code>a.txt</code>、<code>b.txt</code>、<code>c.txt</code> 以外的所有以 <code>.txt</code> 结尾的文件。</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">touch</span> ~/file&#123;1..2&#125;</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/dir&#123;1..3&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> ~/*</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$file</span>&quot;</span> ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$file</span> is a directory&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> [ -f <span class=\"string\">&quot;<span class=\"variable\">$file</span>&quot;</span> ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$file</span> is a file&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n<p>  练习：</p>\n<p>  通过shell脚本实现批量主机检测</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">&gt;ip.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &#123;2..254&#125;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    ip=192.168.13.<span class=\"variable\">$i</span></span><br><span class=\"line\">    ping -c1 -W1 <span class=\"variable\">$ip</span> &amp;&gt;/dev/null</span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ $? -eq 0 ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$ip</span>&quot;</span> |<span class=\"built_in\">tee</span> -a ip.txt</span><br><span class=\"line\">\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t\t&#125;&amp;</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">wait</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;finish...&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"while-循环\"><a href=\"#while-循环\" class=\"headerlink\" title=\"while 循环\"></a>while 循环</h3><p><code>while</code> 循环是一种基于条件判断的循环结构，当条件满足时就会一直执行循环体中的语句。其基本语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 条件 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    循环体</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>条件</code>是一个可以执行的测试命令或表达式，如果返回值为0，则为真，循环继续执行；否则为假，循环结束。</p>\n<p>例如，下面的代码中，<code>while</code> 循环会一直执行，直到变量 <code>i</code> 的值达到 5：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\">i=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$i</span> -le 5 ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;当前变量的值是 <span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\">    i=$(( <span class=\"variable\">$i</span> + <span class=\"number\">1</span> ))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上代码会输出以下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前变量的值是 1</span><br><span class=\"line\">当前变量的值是 2</span><br><span class=\"line\">当前变量的值是 3</span><br><span class=\"line\">当前变量的值是 4</span><br><span class=\"line\">当前变量的值是 5</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"until-循环\"><a href=\"#until-循环\" class=\"headerlink\" title=\"until 循环\"></a>until 循环</h3><p><code>until</code> 循环与 <code>while</code> 循环类似，但是只有当条件为假时才会执行循环体中的语句。其基本语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">until [ 条件 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    循环体</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>条件</code>是一个可以执行的测试命令或表达式，如果返回值为0，则为假，循环继续执行；否则为真，循环结束。</p>\n<p>例如，下面的代码中，<code>until</code> 循环会一直执行，直到变量 <code>i</code> 的值达到 5：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">i=1</span><br><span class=\"line\"><span class=\"keyword\">until</span> [ <span class=\"variable\">$i</span> -gt 5 ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;当前变量的值是 <span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\">    i=$(( <span class=\"variable\">$i</span> + <span class=\"number\">1</span> ))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上代码会输出以下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前变量的值是 1</span><br><span class=\"line\">当前变量的值是 2</span><br><span class=\"line\">当前变量的值是 3</span><br><span class=\"line\">当前变量的值是 4</span><br><span class=\"line\">当前变量的值是 5</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环控制语句\"><a href=\"#循环控制语句\" class=\"headerlink\" title=\"循环控制语句\"></a>循环控制语句</h3><p>在循环中，有时需要跳过某些循环或终止循环的执行，Shell脚本提供了以下三种循环控制语句：</p>\n<ul>\n<li><code>break</code>语句：用于强制退出循环，跳出循环体，执行循环后面的语句。</li>\n<li><code>continue</code>语句：用于跳过循环体中的一个迭代，直接进入下一个迭代。</li>\n<li><code>return</code>语句：用于退出函数，返回到函数调用处。</li>\n</ul>\n<p>例如，下面的代码演示了如何在循环中使用 <code>break</code> 和 <code>continue</code> 语句：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">i=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$i</span> -le 100 ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"variable\">$i</span> -eq 3 ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;跳过第 <span class=\"variable\">$i</span> 次迭代&quot;</span></span><br><span class=\"line\">        i=$(( <span class=\"variable\">$i</span> + <span class=\"number\">1</span> ))</span><br><span class=\"line\">        <span class=\"built_in\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"variable\">$i</span> -eq 5 ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;退出循环&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;第 <span class=\"variable\">$i</span> 次迭代&quot;</span></span><br><span class=\"line\">    i=$(( <span class=\"variable\">$i</span> + <span class=\"number\">1</span> ))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上代码会输出以下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第 1 次迭代</span><br><span class=\"line\">第 2 次迭代</span><br><span class=\"line\">跳过第 3 次迭代</span><br><span class=\"line\">第 4 次迭代</span><br><span class=\"line\">退出循环</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>上一章学习的结构化命令中的 <code>if-then</code> 和 <code>case</code> 语句，其中 <code>if-then</code> 语句是通过检查命令的执行结果或者表达式（文件比较、字符串比较、数值比较）的结果来控制脚本的执行流程。</p>\n<h3 id=\"Shell编程中的循环语句\"><a href=\"#Shell编程中的循环语句\" class=\"headerlink\" title=\"Shell编程中的循环语句\"></a>Shell编程中的循环语句</h3><p>在Shell脚本中，循环语句是一种重要的控制结构，用于多次执行同一段代码。Shell脚本中提供了多种循环语句，包括<code>for</code>、<code>while</code>、<code>until</code>三种。</p>\n<h3 id=\"for-循环\"><a href=\"#for-循环\" class=\"headerlink\" title=\"for 循环\"></a>for 循环</h3><p><code>for</code> 循环是一种针对列表中每个元素执行相同操作的循环结构。该语句会将列表中的每个元素依次赋值给变量，并执行循环体中的语句。其基本语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for 变量名 in 列表</span><br><span class=\"line\">do</span><br><span class=\"line\">    循环体</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>变量名</code>是一个新的变量，用于存储列表中的每个元素；<code>列表</code>是一个由空格分隔的参数列表。</p>\n<p>例如，下面的代码中，<code>for</code> 循环遍历了一个包含 5 个元素的列表，依次输出了每个元素：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> 1 2 3 4 5</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;列表中的元素：<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span>,rk</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;i = <span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上代码会输出以下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">列表中的元素：1</span><br><span class=\"line\">列表中的元素：2</span><br><span class=\"line\">列表中的元素：3</span><br><span class=\"line\">列表中的元素：4</span><br><span class=\"line\">列表中的元素：5</span><br><span class=\"line\">i = 5</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>读取列表中的复杂值</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> I don<span class=\"string\">&#x27;t know if this&#x27;</span>ll work</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;word:<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n<p>  以上代码输出以下结果：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">word:I</span><br><span class=\"line\">word:dont know if thisll</span><br><span class=\"line\">word:work</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>两种方法解决列表中单引号引用的问题</p>\n<p>  使用转义字符（反斜杠）将单引号转义</p>\n<p>  使用双引号定义用到单引号的值</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> I don\\<span class=\"string\">&#x27;t know if this\\&#x27;</span>ll work</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;word:<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> I <span class=\"string\">&quot;don&#x27;t&quot;</span> know <span class=\"keyword\">if</span> <span class=\"string\">&quot;this&#x27;ll&quot;</span> work</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;word:<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用双引号引用输出多个单词</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;1 2&quot;</span> <span class=\"string\">&quot;3 4&quot;</span> 5</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;列表中的元素：<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;i = <span class=\"variable\">$i</span>&quot;</span></span><br></pre></td></tr></table></figure>\n<p>  以上代码输出以下结果：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">列表中的元素：1 2</span><br><span class=\"line\">列表中的元素：3 4</span><br><span class=\"line\">列表中的元素：5</span><br><span class=\"line\">i = 5</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>从变量读取列表</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">list=<span class=\"string\">&quot;1 2 3 4 5&quot;</span></span><br><span class=\"line\">list=<span class=\"variable\">$list</span><span class=\"string\">&quot; 6&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"variable\">$list</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;列表中的元素：<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n<p>  以上代码输出以下结果：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">列表中的元素：1</span><br><span class=\"line\">列表中的元素：2</span><br><span class=\"line\">列表中的元素：3</span><br><span class=\"line\">列表中的元素：4</span><br><span class=\"line\">列表中的元素：5</span><br><span class=\"line\">列表中的元素：6</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过命令读取</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">IFS=$<span class=\"string\">&#x27;\\n&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; test.sh &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">1 2 3</span></span><br><span class=\"line\"><span class=\"string\">2</span></span><br><span class=\"line\"><span class=\"string\">3</span></span><br><span class=\"line\"><span class=\"string\">4</span></span><br><span class=\"line\"><span class=\"string\">5</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> `<span class=\"built_in\">cat</span> test.sh`</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;列表中的元素：<span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用通配符读取目录</p>\n<p>  在 Shell 编程中，通配符是一种用于匹配文件名或目录名的特殊字符。通配符可以帮助你快速地匹配一组文件或目录，从而方便地对它们进行操作。</p>\n<p>  常见的通配符包括：</p>\n<ul>\n<li><code>*</code>：匹配任意长度的任意字符，包括空字符串。</li>\n<li><code>?</code>：匹配任意一个字符。</li>\n<li><code>[...]</code>：匹配括号内列举的任意一个字符。</li>\n<li><code>[^...]</code>：匹配除了括号内列举的任意一个字符以外的所有字符。</li>\n</ul>\n<p>  以下是一些通配符匹配的示例：</p>\n<ul>\n<li><code>*.txt</code>：匹配所有以 <code>.txt</code> 结尾的文件，如 <code>file1.txt</code>、<code>file2.txt</code> 等。</li>\n<li><code>file?.txt</code>：匹配所有文件名为 <code>file</code> 开头，后面跟着任意一个字符，最后以 <code>.txt</code> 结尾的文件，如 <code>file1.txt</code>、<code>fileA.txt</code> 等。</li>\n<li><code>[abc].txt</code>：匹配所有文件名为 <code>a.txt</code>、<code>b.txt</code>、<code>c.txt</code> 的文件。</li>\n<li><code>[^abc].txt</code>：匹配除了文件名为 <code>a.txt</code>、<code>b.txt</code>、<code>c.txt</code> 以外的所有以 <code>.txt</code> 结尾的文件。</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">touch</span> ~/file&#123;1..2&#125;</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/dir&#123;1..3&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> ~/*</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$file</span>&quot;</span> ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$file</span> is a directory&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> [ -f <span class=\"string\">&quot;<span class=\"variable\">$file</span>&quot;</span> ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$file</span> is a file&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n<p>  练习：</p>\n<p>  通过shell脚本实现批量主机检测</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">&gt;ip.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &#123;2..254&#125;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    ip=192.168.13.<span class=\"variable\">$i</span></span><br><span class=\"line\">    ping -c1 -W1 <span class=\"variable\">$ip</span> &amp;&gt;/dev/null</span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ $? -eq 0 ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$ip</span>&quot;</span> |<span class=\"built_in\">tee</span> -a ip.txt</span><br><span class=\"line\">\t\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t\t&#125;&amp;</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">wait</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;finish...&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"while-循环\"><a href=\"#while-循环\" class=\"headerlink\" title=\"while 循环\"></a>while 循环</h3><p><code>while</code> 循环是一种基于条件判断的循环结构，当条件满足时就会一直执行循环体中的语句。其基本语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 条件 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    循环体</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>条件</code>是一个可以执行的测试命令或表达式，如果返回值为0，则为真，循环继续执行；否则为假，循环结束。</p>\n<p>例如，下面的代码中，<code>while</code> 循环会一直执行，直到变量 <code>i</code> 的值达到 5：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\">i=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$i</span> -le 5 ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;当前变量的值是 <span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\">    i=$(( <span class=\"variable\">$i</span> + <span class=\"number\">1</span> ))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上代码会输出以下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前变量的值是 1</span><br><span class=\"line\">当前变量的值是 2</span><br><span class=\"line\">当前变量的值是 3</span><br><span class=\"line\">当前变量的值是 4</span><br><span class=\"line\">当前变量的值是 5</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"until-循环\"><a href=\"#until-循环\" class=\"headerlink\" title=\"until 循环\"></a>until 循环</h3><p><code>until</code> 循环与 <code>while</code> 循环类似，但是只有当条件为假时才会执行循环体中的语句。其基本语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">until [ 条件 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    循环体</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>条件</code>是一个可以执行的测试命令或表达式，如果返回值为0，则为假，循环继续执行；否则为真，循环结束。</p>\n<p>例如，下面的代码中，<code>until</code> 循环会一直执行，直到变量 <code>i</code> 的值达到 5：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">i=1</span><br><span class=\"line\"><span class=\"keyword\">until</span> [ <span class=\"variable\">$i</span> -gt 5 ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;当前变量的值是 <span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\">    i=$(( <span class=\"variable\">$i</span> + <span class=\"number\">1</span> ))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上代码会输出以下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前变量的值是 1</span><br><span class=\"line\">当前变量的值是 2</span><br><span class=\"line\">当前变量的值是 3</span><br><span class=\"line\">当前变量的值是 4</span><br><span class=\"line\">当前变量的值是 5</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环控制语句\"><a href=\"#循环控制语句\" class=\"headerlink\" title=\"循环控制语句\"></a>循环控制语句</h3><p>在循环中，有时需要跳过某些循环或终止循环的执行，Shell脚本提供了以下三种循环控制语句：</p>\n<ul>\n<li><code>break</code>语句：用于强制退出循环，跳出循环体，执行循环后面的语句。</li>\n<li><code>continue</code>语句：用于跳过循环体中的一个迭代，直接进入下一个迭代。</li>\n<li><code>return</code>语句：用于退出函数，返回到函数调用处。</li>\n</ul>\n<p>例如，下面的代码演示了如何在循环中使用 <code>break</code> 和 <code>continue</code> 语句：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">i=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$i</span> -le 100 ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"variable\">$i</span> -eq 3 ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;跳过第 <span class=\"variable\">$i</span> 次迭代&quot;</span></span><br><span class=\"line\">        i=$(( <span class=\"variable\">$i</span> + <span class=\"number\">1</span> ))</span><br><span class=\"line\">        <span class=\"built_in\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"variable\">$i</span> -eq 5 ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;退出循环&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;第 <span class=\"variable\">$i</span> 次迭代&quot;</span></span><br><span class=\"line\">    i=$(( <span class=\"variable\">$i</span> + <span class=\"number\">1</span> ))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上代码会输出以下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第 1 次迭代</span><br><span class=\"line\">第 2 次迭代</span><br><span class=\"line\">跳过第 3 次迭代</span><br><span class=\"line\">第 4 次迭代</span><br><span class=\"line\">退出循环</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"处理用户输入","date":"2023-04-18T03:31:23.000Z","_content":"\n- bash shell提供了一些不同的方法从用户处获得数据，包括命令行参数、命令行选项、直接从键盘读取。\n\n## 命令行参数\n\n### 读取参数\n\n在Shell脚本中，命令行参数可以通过特殊变量 **`$1`**、**`$2`**、**`$3`** ... **`$n`**来获取，其中 **`$1`**表示第一个参数，**`$2`**表示第二个参数，以此类推，**`$n`**表示第 n 个参数。\n\n```bash\n#!/bin/bash\n\necho \"第一个参数为：$1\"\necho \"第二个参数为：$2\"\necho \"第三个参数为：$3\"\n```\n\n1. 利用`for`循环和命令行参数计算阶乘：\n    \n    ```bash\n    #!/bin/bash\n    \n    n=$1\n    fact=1\n    \n    for((i=1; i<=$n; i++))\n    do\n    \t  fact=$((fact * i))  \n    done\n    echo \"Factorial of $n is $fact\"\n    exit 0\n    ```\n    \n2. 将带有空格的文本字符串传递给脚本时需要注意用引号，引号在进行传递时只表明数据的起止位置，不作为数据的一部分：\n    \n    ```bash\n    #!/bin/bash\n    \n    echo Hello $1, glad to meet you.\n    ```\n    \n3. 当参数超过9个时需要修改变量名，变量名两侧加上花括号。\n    \n    ```bash\n    #!/bin/bash\n    # handling lots of parameters\n    #\n    total=$[ ${10} * ${11} ]\n    echo The tenth parameter is ${10}\n    echo The eleventh parameter is ${11}\n    echo The total is $total\n    ```\n    \n    执行结果：\n    \n    ```\n    The tenth parameter is 10\n    The eleventh parameter is 11\n    The total is 110\n    ```\n    \n\n### 读取脚本名\n\n可以用`$0`参数获取shell在命令行启动的脚本名：\n\n```bash\n#!/bin/bash\n# Testing the $0 parameter\n#\necho The zero parameter is set to: $0\n#\n```\n\n当传给`$0`变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量`$0`就会使用整个路径：\n\n```\nubuntu@sh:~$ bash ~/temp.sh\nThe zero parameter is set to: /home/ubuntu/temp.sh\n```\n\nbasename命令会返回不包含路径的脚本名：\n\n```bash\n#!/bin/bash\n# Testing the $0 parameter\n#\nname=$(basename $0)\n\necho The zero parameter is set to: $name\n#\n```\n\n基于脚本名实现不同功能的脚本：\n\n```bash\n#!/bin/bash\n# Testing a Multi-function script\n#\nname=$(basename $0)\n#\nif [ $name = \"addem\" ]\nthen\ntotal=$[ $1 + $2 ]\n#\nelif [ $name = \"multem\" ]\nthen\ntotal=$[ $1 * $2 ]\nfi\n#\necho\necho The calculated value is $total\n```\n\n```\n$ cp temp.sh addem\n$ ln -s temp.sh multem\n\n$ bash addem 2 5\nThe calculated value is 7\n\n$ bash multem 2 5\nThe calculated value is 10\n$\n\n```\n\n### 测试参数\n\n在脚本内使用参数时需要考虑到当用户输入错误参数时的情况：\n\n```bash\n#!/bin/bash\n\nn=$1\nfact=1\n\nif [ $n -eq 0 ]; then\n  echo \"Factorial of 0 is 1\"\n  exit 0\nelif [ $n -lt 0 ]; then\n  echo \"Invalid input. Number must be a positive integer\"\n  exit 1\nfi\n\nfor ((i=1; i<=$n; i++)); do\n  fact=$((fact * i))\ndone\n\necho \"Factorial of $n is $fact\"\nexit 0\n```\n\n## 特殊参数变量\n\n### 参数统计\n\n使用特殊变量可以帮助我们更方便的检查用户传递给脚本的参数。特殊变量`$#`含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。\n\n```bash\n#!/bin/bash\n# getting the number of parameters\n#\necho There were $# parameters supplied.\n```\n\n执行结果：\n\n```\nubuntu@sh:~$ bash temp.sh\nThere were 0 parameters supplied.\n\nubuntu@sh:~$ bash temp.sh 1 2 3 4 5\nThere were 5 parameters supplied.\n\nubuntu@sh:~$ bash temp.sh \"Hello world\"\nThere were 1 parameters supplied.\n```\n\n在使用参数前测试参数总数：\n\n```bash\n#!/bin/bash\n\nif [ $# -ne 1 ]; then\n  echo \"Usage: $0 number\"\n  exit 1\nfi\n\nn=$1\nfact=1\n\nif [ $n -eq 0 ]; then\n  echo \"Factorial of 0 is 1\"\n  exit 0\nelif [ $n -lt 0 ]; then\n  echo \"Invalid input. Number must be a positive integer\"\n  exit 1\nfi\n\nfor ((i=1; i<=$n; i++)); do\n  fact=$((fact * i))\ndone\n\necho \"Factorial of $n is $fact\"\nexit 0\n```\n\n### 抓取所有的数据\n\n`$*`变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每\n一个参数值。基本上`$*`变量会将这些参数视为一个整体，而不是多个个体。\n另一方面，`$@`变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样\n你就能够遍历所有的参数值，得到每个参数。这通常通过`for`命令完成。\n\n```bash\n#!/bin/bash\n# testing $* and $@\n#j,r:\necho\ncount=1\n#\nfor param in \"$*\"\ndo\necho \"\\$* Parameter #$count = $param\"\ncount=$[ $count + 1 ]\ndone\n#\necho\ncount=1\n#\nfor param in \"$@\"\ndo\necho \"\\$@ Parameter #$count = $param\"\ncount=$[ $count + 1 ]\ndone\n```\n\n## 移动变量\n\nbash shell的`shift`命令能够用来操作命令行参数。在使用`shift`命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量`$3`的值会移到$2中，变量`$2`的值会移到`$1`中，而变量`$1`的值则会被删除（注意，变量`$0`的值，也就是程序名，不会改变）。\n\n这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数。\n\n```bash\n#!/bin/bash\n\nwhile [ -n \"$1\" ]\ndo\n                sum=$(($sum+$1))\n                shift\ndone\n\necho sum=$sum\nexit 0\n```\n\n```\nubuntu@sh:~$ bash temp.sh 1 2 3\nsum=6\n\nubuntu@sh:~$ bash temp.sh 1 2 3 4 5 6\nsum=21\n```\n\n## 处理选项\n\n选项是跟在单破折线后面的单个字母，它能改变命令的行为。\n\n### 处理简单选项\n\n```bash\n#!/bin/bash\n\necho\nwhile [ -n \"$1\" ]\ndo\n         case \"$1\" in\n                                -a) echo \"Found the -a option\" ;;\n                                -b) echo \"Found the -b option\" ;;\n                                -c) echo \"Found the -c option\" ;;\n                                *) echo \"$1 is not an option\" ;;\n         esac\n         shift\ndone\n```\n\n### 分离参数和选项、处理带值选项\n\n```bash\n#!/bin/bash\n# extracting options and parameters\necho\nwhile [ -n \"$1\" ]\ndo\n                case \"$1\" in\n                                -a) echo \"Found the -a option\" ;;\n                                -b) echo \"Found the -b option\";;\n                                -c) echo \"Found the -c option\" \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcoption=$($2 * $3)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\techo $coption\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshift\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshift\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;;\n                                --) shift\n                                                break ;;\n                                *) echo \"$1 is not an option\";;\n                esac\n                shift\ndone\n#\ncount=1\nfor param in $@\ndo\n                echo \"Parameter #$count: $param\"\n                count=$(( $count + 1 ))\ndone\n```\n\n### 利用选项和参数实现阶乘和求和的计算工具\n\n```bash\n#!/bin/bash\n\nif [ $# -eq 0 ] || [ $# -eq 1 ]\nthen\n                echo\n                echo \"sum and factorial tool\"\n                echo \"Usage:\"\n                echo \"          -a number ...\"\n                echo \"          -f number\"\n                exit 1\nfi\n\ncase \"$1\" in\n                -a)\n                                while [ -n \"$2\" ]\n                                do\n                                                sum=$[$sum + $2]\n                                                shift\n                                done\n                                echo \"sum=$sum\"\n                                exit 0\n# shift\n# for i in $@\n# do\n\t# sum=$((sum + i))\n# done\n# exit 0\n                                ;;\n                -f)\n                                if [ $2 -eq 0 ]\n                                then\n                                                echo \"fact=1\"\n                                                exit 0\n                                fi\n                                fact=1\n                                for((i=1; i<=$2; i++))\n                                do\n                                                fact=$[$fact * $i]\n                                done\n                                echo fact=$fact\n                                exit 0\n                                ;;\n                -h)\n                                ;;\n                *)\n                                echo\n                                echo \"sum and factorial tool\"\n                                echo \"Usage:\"\n                                echo \"          -a number ...\"\n                                echo \"          -f number\"\n                                ;;\nesac\nexit 0\n```\n\n## 标准化选项\n\n![Untitled](Untitled%2040.png)","source":"_posts/linux_shell/5.处理用户输入.md","raw":"---\ntitle: 处理用户输入\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n- bash shell提供了一些不同的方法从用户处获得数据，包括命令行参数、命令行选项、直接从键盘读取。\n\n## 命令行参数\n\n### 读取参数\n\n在Shell脚本中，命令行参数可以通过特殊变量 **`$1`**、**`$2`**、**`$3`** ... **`$n`**来获取，其中 **`$1`**表示第一个参数，**`$2`**表示第二个参数，以此类推，**`$n`**表示第 n 个参数。\n\n```bash\n#!/bin/bash\n\necho \"第一个参数为：$1\"\necho \"第二个参数为：$2\"\necho \"第三个参数为：$3\"\n```\n\n1. 利用`for`循环和命令行参数计算阶乘：\n    \n    ```bash\n    #!/bin/bash\n    \n    n=$1\n    fact=1\n    \n    for((i=1; i<=$n; i++))\n    do\n    \t  fact=$((fact * i))  \n    done\n    echo \"Factorial of $n is $fact\"\n    exit 0\n    ```\n    \n2. 将带有空格的文本字符串传递给脚本时需要注意用引号，引号在进行传递时只表明数据的起止位置，不作为数据的一部分：\n    \n    ```bash\n    #!/bin/bash\n    \n    echo Hello $1, glad to meet you.\n    ```\n    \n3. 当参数超过9个时需要修改变量名，变量名两侧加上花括号。\n    \n    ```bash\n    #!/bin/bash\n    # handling lots of parameters\n    #\n    total=$[ ${10} * ${11} ]\n    echo The tenth parameter is ${10}\n    echo The eleventh parameter is ${11}\n    echo The total is $total\n    ```\n    \n    执行结果：\n    \n    ```\n    The tenth parameter is 10\n    The eleventh parameter is 11\n    The total is 110\n    ```\n    \n\n### 读取脚本名\n\n可以用`$0`参数获取shell在命令行启动的脚本名：\n\n```bash\n#!/bin/bash\n# Testing the $0 parameter\n#\necho The zero parameter is set to: $0\n#\n```\n\n当传给`$0`变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量`$0`就会使用整个路径：\n\n```\nubuntu@sh:~$ bash ~/temp.sh\nThe zero parameter is set to: /home/ubuntu/temp.sh\n```\n\nbasename命令会返回不包含路径的脚本名：\n\n```bash\n#!/bin/bash\n# Testing the $0 parameter\n#\nname=$(basename $0)\n\necho The zero parameter is set to: $name\n#\n```\n\n基于脚本名实现不同功能的脚本：\n\n```bash\n#!/bin/bash\n# Testing a Multi-function script\n#\nname=$(basename $0)\n#\nif [ $name = \"addem\" ]\nthen\ntotal=$[ $1 + $2 ]\n#\nelif [ $name = \"multem\" ]\nthen\ntotal=$[ $1 * $2 ]\nfi\n#\necho\necho The calculated value is $total\n```\n\n```\n$ cp temp.sh addem\n$ ln -s temp.sh multem\n\n$ bash addem 2 5\nThe calculated value is 7\n\n$ bash multem 2 5\nThe calculated value is 10\n$\n\n```\n\n### 测试参数\n\n在脚本内使用参数时需要考虑到当用户输入错误参数时的情况：\n\n```bash\n#!/bin/bash\n\nn=$1\nfact=1\n\nif [ $n -eq 0 ]; then\n  echo \"Factorial of 0 is 1\"\n  exit 0\nelif [ $n -lt 0 ]; then\n  echo \"Invalid input. Number must be a positive integer\"\n  exit 1\nfi\n\nfor ((i=1; i<=$n; i++)); do\n  fact=$((fact * i))\ndone\n\necho \"Factorial of $n is $fact\"\nexit 0\n```\n\n## 特殊参数变量\n\n### 参数统计\n\n使用特殊变量可以帮助我们更方便的检查用户传递给脚本的参数。特殊变量`$#`含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。\n\n```bash\n#!/bin/bash\n# getting the number of parameters\n#\necho There were $# parameters supplied.\n```\n\n执行结果：\n\n```\nubuntu@sh:~$ bash temp.sh\nThere were 0 parameters supplied.\n\nubuntu@sh:~$ bash temp.sh 1 2 3 4 5\nThere were 5 parameters supplied.\n\nubuntu@sh:~$ bash temp.sh \"Hello world\"\nThere were 1 parameters supplied.\n```\n\n在使用参数前测试参数总数：\n\n```bash\n#!/bin/bash\n\nif [ $# -ne 1 ]; then\n  echo \"Usage: $0 number\"\n  exit 1\nfi\n\nn=$1\nfact=1\n\nif [ $n -eq 0 ]; then\n  echo \"Factorial of 0 is 1\"\n  exit 0\nelif [ $n -lt 0 ]; then\n  echo \"Invalid input. Number must be a positive integer\"\n  exit 1\nfi\n\nfor ((i=1; i<=$n; i++)); do\n  fact=$((fact * i))\ndone\n\necho \"Factorial of $n is $fact\"\nexit 0\n```\n\n### 抓取所有的数据\n\n`$*`变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每\n一个参数值。基本上`$*`变量会将这些参数视为一个整体，而不是多个个体。\n另一方面，`$@`变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样\n你就能够遍历所有的参数值，得到每个参数。这通常通过`for`命令完成。\n\n```bash\n#!/bin/bash\n# testing $* and $@\n#j,r:\necho\ncount=1\n#\nfor param in \"$*\"\ndo\necho \"\\$* Parameter #$count = $param\"\ncount=$[ $count + 1 ]\ndone\n#\necho\ncount=1\n#\nfor param in \"$@\"\ndo\necho \"\\$@ Parameter #$count = $param\"\ncount=$[ $count + 1 ]\ndone\n```\n\n## 移动变量\n\nbash shell的`shift`命令能够用来操作命令行参数。在使用`shift`命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量`$3`的值会移到$2中，变量`$2`的值会移到`$1`中，而变量`$1`的值则会被删除（注意，变量`$0`的值，也就是程序名，不会改变）。\n\n这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数。\n\n```bash\n#!/bin/bash\n\nwhile [ -n \"$1\" ]\ndo\n                sum=$(($sum+$1))\n                shift\ndone\n\necho sum=$sum\nexit 0\n```\n\n```\nubuntu@sh:~$ bash temp.sh 1 2 3\nsum=6\n\nubuntu@sh:~$ bash temp.sh 1 2 3 4 5 6\nsum=21\n```\n\n## 处理选项\n\n选项是跟在单破折线后面的单个字母，它能改变命令的行为。\n\n### 处理简单选项\n\n```bash\n#!/bin/bash\n\necho\nwhile [ -n \"$1\" ]\ndo\n         case \"$1\" in\n                                -a) echo \"Found the -a option\" ;;\n                                -b) echo \"Found the -b option\" ;;\n                                -c) echo \"Found the -c option\" ;;\n                                *) echo \"$1 is not an option\" ;;\n         esac\n         shift\ndone\n```\n\n### 分离参数和选项、处理带值选项\n\n```bash\n#!/bin/bash\n# extracting options and parameters\necho\nwhile [ -n \"$1\" ]\ndo\n                case \"$1\" in\n                                -a) echo \"Found the -a option\" ;;\n                                -b) echo \"Found the -b option\";;\n                                -c) echo \"Found the -c option\" \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcoption=$($2 * $3)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\techo $coption\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshift\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshift\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;;\n                                --) shift\n                                                break ;;\n                                *) echo \"$1 is not an option\";;\n                esac\n                shift\ndone\n#\ncount=1\nfor param in $@\ndo\n                echo \"Parameter #$count: $param\"\n                count=$(( $count + 1 ))\ndone\n```\n\n### 利用选项和参数实现阶乘和求和的计算工具\n\n```bash\n#!/bin/bash\n\nif [ $# -eq 0 ] || [ $# -eq 1 ]\nthen\n                echo\n                echo \"sum and factorial tool\"\n                echo \"Usage:\"\n                echo \"          -a number ...\"\n                echo \"          -f number\"\n                exit 1\nfi\n\ncase \"$1\" in\n                -a)\n                                while [ -n \"$2\" ]\n                                do\n                                                sum=$[$sum + $2]\n                                                shift\n                                done\n                                echo \"sum=$sum\"\n                                exit 0\n# shift\n# for i in $@\n# do\n\t# sum=$((sum + i))\n# done\n# exit 0\n                                ;;\n                -f)\n                                if [ $2 -eq 0 ]\n                                then\n                                                echo \"fact=1\"\n                                                exit 0\n                                fi\n                                fact=1\n                                for((i=1; i<=$2; i++))\n                                do\n                                                fact=$[$fact * $i]\n                                done\n                                echo fact=$fact\n                                exit 0\n                                ;;\n                -h)\n                                ;;\n                *)\n                                echo\n                                echo \"sum and factorial tool\"\n                                echo \"Usage:\"\n                                echo \"          -a number ...\"\n                                echo \"          -f number\"\n                                ;;\nesac\nexit 0\n```\n\n## 标准化选项\n\n![Untitled](Untitled%2040.png)","slug":"linux_shell/5.处理用户输入","published":1,"updated":"2023-06-10T08:09:30.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cliuf72we0006j1nz3rcg0sut","content":"<ul>\n<li>bash shell提供了一些不同的方法从用户处获得数据，包括命令行参数、命令行选项、直接从键盘读取。</li>\n</ul>\n<h2 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h2><h3 id=\"读取参数\"><a href=\"#读取参数\" class=\"headerlink\" title=\"读取参数\"></a>读取参数</h3><p>在Shell脚本中，命令行参数可以通过特殊变量 <strong><code>$1</code><strong>、</strong><code>$2</code><strong>、</strong><code>$3</code></strong> … **<code>$n</code>**来获取，其中 **<code>$1</code><strong>表示第一个参数，</strong><code>$2</code><strong>表示第二个参数，以此类推，</strong><code>$n</code>**表示第 n 个参数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;第一个参数为：<span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;第二个参数为：<span class=\"variable\">$2</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;第三个参数为：<span class=\"variable\">$3</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>利用<code>for</code>循环和命令行参数计算阶乘：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">n=<span class=\"variable\">$1</span></span><br><span class=\"line\">fact=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>((i=<span class=\"number\">1</span>; i&lt;=<span class=\"variable\">$n</span>; i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\t  fact=$((fact * i))  </span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Factorial of <span class=\"variable\">$n</span> is <span class=\"variable\">$fact</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将带有空格的文本字符串传递给脚本时需要注意用引号，引号在进行传递时只表明数据的起止位置，不作为数据的一部分：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Hello <span class=\"variable\">$1</span>, glad to meet you.</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当参数超过9个时需要修改变量名，变量名两侧加上花括号。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># handling lots of parameters</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">total=$[ <span class=\"variable\">$&#123;10&#125;</span> * <span class=\"variable\">$&#123;11&#125;</span> ]</span><br><span class=\"line\"><span class=\"built_in\">echo</span> The tenth parameter is <span class=\"variable\">$&#123;10&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> The eleventh parameter is <span class=\"variable\">$&#123;11&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> The total is <span class=\"variable\">$total</span></span><br></pre></td></tr></table></figure>\n<p> 执行结果：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The tenth parameter is 10</span><br><span class=\"line\">The eleventh parameter is 11</span><br><span class=\"line\">The total is 110</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"读取脚本名\"><a href=\"#读取脚本名\" class=\"headerlink\" title=\"读取脚本名\"></a>读取脚本名</h3><p>可以用<code>$0</code>参数获取shell在命令行启动的脚本名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># Testing the $0 parameter</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> The zero parameter is <span class=\"built_in\">set</span> to: <span class=\"variable\">$0</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n\n<p>当传给<code>$0</code>变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量<code>$0</code>就会使用整个路径：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ bash ~/temp.sh</span><br><span class=\"line\">The zero parameter is set to: /home/ubuntu/temp.sh</span><br></pre></td></tr></table></figure>\n\n<p>basename命令会返回不包含路径的脚本名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># Testing the $0 parameter</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">name=$(<span class=\"built_in\">basename</span> <span class=\"variable\">$0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> The zero parameter is <span class=\"built_in\">set</span> to: <span class=\"variable\">$name</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n\n<p>基于脚本名实现不同功能的脚本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># Testing a Multi-function script</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">name=$(<span class=\"built_in\">basename</span> <span class=\"variable\">$0</span>)</span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$name</span> = <span class=\"string\">&quot;addem&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">total=$[ <span class=\"variable\">$1</span> + <span class=\"variable\">$2</span> ]</span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ <span class=\"variable\">$name</span> = <span class=\"string\">&quot;multem&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">total=$[ <span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> ]</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> The calculated value is <span class=\"variable\">$total</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cp temp.sh addem</span><br><span class=\"line\">$ ln -s temp.sh multem</span><br><span class=\"line\"></span><br><span class=\"line\">$ bash addem 2 5</span><br><span class=\"line\">The calculated value is 7</span><br><span class=\"line\"></span><br><span class=\"line\">$ bash multem 2 5</span><br><span class=\"line\">The calculated value is 10</span><br><span class=\"line\">$</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试参数\"><a href=\"#测试参数\" class=\"headerlink\" title=\"测试参数\"></a>测试参数</h3><p>在脚本内使用参数时需要考虑到当用户输入错误参数时的情况：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">n=<span class=\"variable\">$1</span></span><br><span class=\"line\">fact=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$n</span> -eq 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Factorial of 0 is 1&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ <span class=\"variable\">$n</span> -lt 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Invalid input. Number must be a positive integer&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=<span class=\"number\">1</span>; i&lt;=<span class=\"variable\">$n</span>; i++)); <span class=\"keyword\">do</span></span><br><span class=\"line\">  fact=$((fact * i))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Factorial of <span class=\"variable\">$n</span> is <span class=\"variable\">$fact</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"特殊参数变量\"><a href=\"#特殊参数变量\" class=\"headerlink\" title=\"特殊参数变量\"></a>特殊参数变量</h2><h3 id=\"参数统计\"><a href=\"#参数统计\" class=\"headerlink\" title=\"参数统计\"></a>参数统计</h3><p>使用特殊变量可以帮助我们更方便的检查用户传递给脚本的参数。特殊变量<code>$#</code>含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># getting the number of parameters</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> There were <span class=\"variable\">$#</span> parameters supplied.</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ bash temp.sh</span><br><span class=\"line\">There were 0 parameters supplied.</span><br><span class=\"line\"></span><br><span class=\"line\">ubuntu@sh:~$ bash temp.sh 1 2 3 4 5</span><br><span class=\"line\">There were 5 parameters supplied.</span><br><span class=\"line\"></span><br><span class=\"line\">ubuntu@sh:~$ bash temp.sh &quot;Hello world&quot;</span><br><span class=\"line\">There were 1 parameters supplied.</span><br></pre></td></tr></table></figure>\n\n<p>在使用参数前测试参数总数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$#</span> -ne 1 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Usage: <span class=\"variable\">$0</span> number&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">n=<span class=\"variable\">$1</span></span><br><span class=\"line\">fact=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$n</span> -eq 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Factorial of 0 is 1&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ <span class=\"variable\">$n</span> -lt 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Invalid input. Number must be a positive integer&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=<span class=\"number\">1</span>; i&lt;=<span class=\"variable\">$n</span>; i++)); <span class=\"keyword\">do</span></span><br><span class=\"line\">  fact=$((fact * i))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Factorial of <span class=\"variable\">$n</span> is <span class=\"variable\">$fact</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"抓取所有的数据\"><a href=\"#抓取所有的数据\" class=\"headerlink\" title=\"抓取所有的数据\"></a>抓取所有的数据</h3><p><code>$*</code>变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每<br>一个参数值。基本上<code>$*</code>变量会将这些参数视为一个整体，而不是多个个体。<br>另一方面，<code>$@</code>变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样<br>你就能够遍历所有的参数值，得到每个参数。这通常通过<code>for</code>命令完成。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># testing $* and $@</span></span><br><span class=\"line\"><span class=\"comment\">#j,r:</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> param <span class=\"keyword\">in</span> <span class=\"string\">&quot;$*&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;\\$* Parameter #<span class=\"variable\">$count</span> = <span class=\"variable\">$param</span>&quot;</span></span><br><span class=\"line\">count=$[ <span class=\"variable\">$count</span> + 1 ]</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> param <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$@</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;\\$@ Parameter #<span class=\"variable\">$count</span> = <span class=\"variable\">$param</span>&quot;</span></span><br><span class=\"line\">count=$[ <span class=\"variable\">$count</span> + 1 ]</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"移动变量\"><a href=\"#移动变量\" class=\"headerlink\" title=\"移动变量\"></a>移动变量</h2><p>bash shell的<code>shift</code>命令能够用来操作命令行参数。在使用<code>shift</code>命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量<code>$3</code>的值会移到$2中，变量<code>$2</code>的值会移到<code>$1</code>中，而变量<code>$1</code>的值则会被删除（注意，变量<code>$0</code>的值，也就是程序名，不会改变）。</p>\n<p>这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> [ -n <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">                <span class=\"built_in\">sum</span>=$((<span class=\"variable\">$sum</span>+<span class=\"variable\">$1</span>))</span><br><span class=\"line\">                <span class=\"built_in\">shift</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"built_in\">sum</span>=<span class=\"variable\">$sum</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 0</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ bash temp.sh 1 2 3</span><br><span class=\"line\">sum=6</span><br><span class=\"line\"></span><br><span class=\"line\">ubuntu@sh:~$ bash temp.sh 1 2 3 4 5 6</span><br><span class=\"line\">sum=21</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"处理选项\"><a href=\"#处理选项\" class=\"headerlink\" title=\"处理选项\"></a>处理选项</h2><p>选项是跟在单破折线后面的单个字母，它能改变命令的行为。</p>\n<h3 id=\"处理简单选项\"><a href=\"#处理简单选项\" class=\"headerlink\" title=\"处理简单选项\"></a>处理简单选项</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> [ -n <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">         <span class=\"keyword\">case</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">                                -a) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Found the -a option&quot;</span> ;;</span><br><span class=\"line\">                                -b) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Found the -b option&quot;</span> ;;</span><br><span class=\"line\">                                -c) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Found the -c option&quot;</span> ;;</span><br><span class=\"line\">                                *) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> is not an option&quot;</span> ;;</span><br><span class=\"line\">         <span class=\"keyword\">esac</span></span><br><span class=\"line\">         <span class=\"built_in\">shift</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分离参数和选项、处理带值选项\"><a href=\"#分离参数和选项、处理带值选项\" class=\"headerlink\" title=\"分离参数和选项、处理带值选项\"></a>分离参数和选项、处理带值选项</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># extracting options and parameters</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> [ -n <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">                                -a) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Found the -a option&quot;</span> ;;</span><br><span class=\"line\">                                -b) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Found the -b option&quot;</span>;;</span><br><span class=\"line\">                                -c) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Found the -c option&quot;</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcoption=$(<span class=\"variable\">$2</span> * <span class=\"variable\">$3</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"built_in\">echo</span> <span class=\"variable\">$coption</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"built_in\">shift</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"built_in\">shift</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;;</span><br><span class=\"line\">                                --) <span class=\"built_in\">shift</span></span><br><span class=\"line\">                                                <span class=\"built_in\">break</span> ;;</span><br><span class=\"line\">                                *) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> is not an option&quot;</span>;;</span><br><span class=\"line\">                <span class=\"keyword\">esac</span></span><br><span class=\"line\">                <span class=\"built_in\">shift</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"keyword\">for</span> param <span class=\"keyword\">in</span> <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Parameter #<span class=\"variable\">$count</span>: <span class=\"variable\">$param</span>&quot;</span></span><br><span class=\"line\">                count=$(( <span class=\"variable\">$count</span> + <span class=\"number\">1</span> ))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"利用选项和参数实现阶乘和求和的计算工具\"><a href=\"#利用选项和参数实现阶乘和求和的计算工具\" class=\"headerlink\" title=\"利用选项和参数实现阶乘和求和的计算工具\"></a>利用选项和参数实现阶乘和求和的计算工具</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$#</span> -eq 0 ] || [ <span class=\"variable\">$#</span> -eq 1 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;sum and factorial tool&quot;</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Usage:&quot;</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;          -a number ...&quot;</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;          -f number&quot;</span></span><br><span class=\"line\">                <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">                -a)</span><br><span class=\"line\">                                <span class=\"keyword\">while</span> [ -n <span class=\"string\">&quot;<span class=\"variable\">$2</span>&quot;</span> ]</span><br><span class=\"line\">                                <span class=\"keyword\">do</span></span><br><span class=\"line\">                                                <span class=\"built_in\">sum</span>=$[<span class=\"variable\">$sum</span> + <span class=\"variable\">$2</span>]</span><br><span class=\"line\">                                                <span class=\"built_in\">shift</span></span><br><span class=\"line\">                                <span class=\"keyword\">done</span></span><br><span class=\"line\">                                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;sum=<span class=\"variable\">$sum</span>&quot;</span></span><br><span class=\"line\">                                <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\"><span class=\"comment\"># shift</span></span><br><span class=\"line\"><span class=\"comment\"># for i in $@</span></span><br><span class=\"line\"><span class=\"comment\"># do</span></span><br><span class=\"line\">\t<span class=\"comment\"># sum=$((sum + i))</span></span><br><span class=\"line\"><span class=\"comment\"># done</span></span><br><span class=\"line\"><span class=\"comment\"># exit 0</span></span><br><span class=\"line\">                                ;;</span><br><span class=\"line\">                -f)</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> [ <span class=\"variable\">$2</span> -eq 0 ]</span><br><span class=\"line\">                                <span class=\"keyword\">then</span></span><br><span class=\"line\">                                                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;fact=1&quot;</span></span><br><span class=\"line\">                                                <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\">                                <span class=\"keyword\">fi</span></span><br><span class=\"line\">                                fact=1</span><br><span class=\"line\">                                <span class=\"keyword\">for</span>((i=<span class=\"number\">1</span>; i&lt;=<span class=\"variable\">$2</span>; i++))</span><br><span class=\"line\">                                <span class=\"keyword\">do</span></span><br><span class=\"line\">                                                fact=$[<span class=\"variable\">$fact</span> * <span class=\"variable\">$i</span>]</span><br><span class=\"line\">                                <span class=\"keyword\">done</span></span><br><span class=\"line\">                                <span class=\"built_in\">echo</span> fact=<span class=\"variable\">$fact</span></span><br><span class=\"line\">                                <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\">                                ;;</span><br><span class=\"line\">                -h)</span><br><span class=\"line\">                                ;;</span><br><span class=\"line\">                *)</span><br><span class=\"line\">                                <span class=\"built_in\">echo</span></span><br><span class=\"line\">                                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;sum and factorial tool&quot;</span></span><br><span class=\"line\">                                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Usage:&quot;</span></span><br><span class=\"line\">                                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;          -a number ...&quot;</span></span><br><span class=\"line\">                                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;          -f number&quot;</span></span><br><span class=\"line\">                                ;;</span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标准化选项\"><a href=\"#标准化选项\" class=\"headerlink\" title=\"标准化选项\"></a>标准化选项</h2><p><img src=\"/Untitled%2040.png\" alt=\"Untitled\"></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>bash shell提供了一些不同的方法从用户处获得数据，包括命令行参数、命令行选项、直接从键盘读取。</li>\n</ul>\n<h2 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h2><h3 id=\"读取参数\"><a href=\"#读取参数\" class=\"headerlink\" title=\"读取参数\"></a>读取参数</h3><p>在Shell脚本中，命令行参数可以通过特殊变量 <strong><code>$1</code><strong>、</strong><code>$2</code><strong>、</strong><code>$3</code></strong> … **<code>$n</code>**来获取，其中 **<code>$1</code><strong>表示第一个参数，</strong><code>$2</code><strong>表示第二个参数，以此类推，</strong><code>$n</code>**表示第 n 个参数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;第一个参数为：<span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;第二个参数为：<span class=\"variable\">$2</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;第三个参数为：<span class=\"variable\">$3</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>利用<code>for</code>循环和命令行参数计算阶乘：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">n=<span class=\"variable\">$1</span></span><br><span class=\"line\">fact=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>((i=<span class=\"number\">1</span>; i&lt;=<span class=\"variable\">$n</span>; i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\t  fact=$((fact * i))  </span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Factorial of <span class=\"variable\">$n</span> is <span class=\"variable\">$fact</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将带有空格的文本字符串传递给脚本时需要注意用引号，引号在进行传递时只表明数据的起止位置，不作为数据的一部分：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Hello <span class=\"variable\">$1</span>, glad to meet you.</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当参数超过9个时需要修改变量名，变量名两侧加上花括号。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># handling lots of parameters</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">total=$[ <span class=\"variable\">$&#123;10&#125;</span> * <span class=\"variable\">$&#123;11&#125;</span> ]</span><br><span class=\"line\"><span class=\"built_in\">echo</span> The tenth parameter is <span class=\"variable\">$&#123;10&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> The eleventh parameter is <span class=\"variable\">$&#123;11&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> The total is <span class=\"variable\">$total</span></span><br></pre></td></tr></table></figure>\n<p> 执行结果：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The tenth parameter is 10</span><br><span class=\"line\">The eleventh parameter is 11</span><br><span class=\"line\">The total is 110</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"读取脚本名\"><a href=\"#读取脚本名\" class=\"headerlink\" title=\"读取脚本名\"></a>读取脚本名</h3><p>可以用<code>$0</code>参数获取shell在命令行启动的脚本名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># Testing the $0 parameter</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> The zero parameter is <span class=\"built_in\">set</span> to: <span class=\"variable\">$0</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n\n<p>当传给<code>$0</code>变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量<code>$0</code>就会使用整个路径：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ bash ~/temp.sh</span><br><span class=\"line\">The zero parameter is set to: /home/ubuntu/temp.sh</span><br></pre></td></tr></table></figure>\n\n<p>basename命令会返回不包含路径的脚本名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># Testing the $0 parameter</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">name=$(<span class=\"built_in\">basename</span> <span class=\"variable\">$0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> The zero parameter is <span class=\"built_in\">set</span> to: <span class=\"variable\">$name</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n\n<p>基于脚本名实现不同功能的脚本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># Testing a Multi-function script</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">name=$(<span class=\"built_in\">basename</span> <span class=\"variable\">$0</span>)</span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$name</span> = <span class=\"string\">&quot;addem&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">total=$[ <span class=\"variable\">$1</span> + <span class=\"variable\">$2</span> ]</span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ <span class=\"variable\">$name</span> = <span class=\"string\">&quot;multem&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">total=$[ <span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> ]</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> The calculated value is <span class=\"variable\">$total</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cp temp.sh addem</span><br><span class=\"line\">$ ln -s temp.sh multem</span><br><span class=\"line\"></span><br><span class=\"line\">$ bash addem 2 5</span><br><span class=\"line\">The calculated value is 7</span><br><span class=\"line\"></span><br><span class=\"line\">$ bash multem 2 5</span><br><span class=\"line\">The calculated value is 10</span><br><span class=\"line\">$</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试参数\"><a href=\"#测试参数\" class=\"headerlink\" title=\"测试参数\"></a>测试参数</h3><p>在脚本内使用参数时需要考虑到当用户输入错误参数时的情况：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">n=<span class=\"variable\">$1</span></span><br><span class=\"line\">fact=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$n</span> -eq 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Factorial of 0 is 1&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ <span class=\"variable\">$n</span> -lt 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Invalid input. Number must be a positive integer&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=<span class=\"number\">1</span>; i&lt;=<span class=\"variable\">$n</span>; i++)); <span class=\"keyword\">do</span></span><br><span class=\"line\">  fact=$((fact * i))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Factorial of <span class=\"variable\">$n</span> is <span class=\"variable\">$fact</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"特殊参数变量\"><a href=\"#特殊参数变量\" class=\"headerlink\" title=\"特殊参数变量\"></a>特殊参数变量</h2><h3 id=\"参数统计\"><a href=\"#参数统计\" class=\"headerlink\" title=\"参数统计\"></a>参数统计</h3><p>使用特殊变量可以帮助我们更方便的检查用户传递给脚本的参数。特殊变量<code>$#</code>含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># getting the number of parameters</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> There were <span class=\"variable\">$#</span> parameters supplied.</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ bash temp.sh</span><br><span class=\"line\">There were 0 parameters supplied.</span><br><span class=\"line\"></span><br><span class=\"line\">ubuntu@sh:~$ bash temp.sh 1 2 3 4 5</span><br><span class=\"line\">There were 5 parameters supplied.</span><br><span class=\"line\"></span><br><span class=\"line\">ubuntu@sh:~$ bash temp.sh &quot;Hello world&quot;</span><br><span class=\"line\">There were 1 parameters supplied.</span><br></pre></td></tr></table></figure>\n\n<p>在使用参数前测试参数总数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$#</span> -ne 1 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Usage: <span class=\"variable\">$0</span> number&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">n=<span class=\"variable\">$1</span></span><br><span class=\"line\">fact=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$n</span> -eq 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Factorial of 0 is 1&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ <span class=\"variable\">$n</span> -lt 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Invalid input. Number must be a positive integer&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=<span class=\"number\">1</span>; i&lt;=<span class=\"variable\">$n</span>; i++)); <span class=\"keyword\">do</span></span><br><span class=\"line\">  fact=$((fact * i))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Factorial of <span class=\"variable\">$n</span> is <span class=\"variable\">$fact</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"抓取所有的数据\"><a href=\"#抓取所有的数据\" class=\"headerlink\" title=\"抓取所有的数据\"></a>抓取所有的数据</h3><p><code>$*</code>变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每<br>一个参数值。基本上<code>$*</code>变量会将这些参数视为一个整体，而不是多个个体。<br>另一方面，<code>$@</code>变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样<br>你就能够遍历所有的参数值，得到每个参数。这通常通过<code>for</code>命令完成。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># testing $* and $@</span></span><br><span class=\"line\"><span class=\"comment\">#j,r:</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> param <span class=\"keyword\">in</span> <span class=\"string\">&quot;$*&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;\\$* Parameter #<span class=\"variable\">$count</span> = <span class=\"variable\">$param</span>&quot;</span></span><br><span class=\"line\">count=$[ <span class=\"variable\">$count</span> + 1 ]</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> param <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$@</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;\\$@ Parameter #<span class=\"variable\">$count</span> = <span class=\"variable\">$param</span>&quot;</span></span><br><span class=\"line\">count=$[ <span class=\"variable\">$count</span> + 1 ]</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"移动变量\"><a href=\"#移动变量\" class=\"headerlink\" title=\"移动变量\"></a>移动变量</h2><p>bash shell的<code>shift</code>命令能够用来操作命令行参数。在使用<code>shift</code>命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量<code>$3</code>的值会移到$2中，变量<code>$2</code>的值会移到<code>$1</code>中，而变量<code>$1</code>的值则会被删除（注意，变量<code>$0</code>的值，也就是程序名，不会改变）。</p>\n<p>这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> [ -n <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">                <span class=\"built_in\">sum</span>=$((<span class=\"variable\">$sum</span>+<span class=\"variable\">$1</span>))</span><br><span class=\"line\">                <span class=\"built_in\">shift</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"built_in\">sum</span>=<span class=\"variable\">$sum</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 0</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ bash temp.sh 1 2 3</span><br><span class=\"line\">sum=6</span><br><span class=\"line\"></span><br><span class=\"line\">ubuntu@sh:~$ bash temp.sh 1 2 3 4 5 6</span><br><span class=\"line\">sum=21</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"处理选项\"><a href=\"#处理选项\" class=\"headerlink\" title=\"处理选项\"></a>处理选项</h2><p>选项是跟在单破折线后面的单个字母，它能改变命令的行为。</p>\n<h3 id=\"处理简单选项\"><a href=\"#处理简单选项\" class=\"headerlink\" title=\"处理简单选项\"></a>处理简单选项</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> [ -n <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">         <span class=\"keyword\">case</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">                                -a) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Found the -a option&quot;</span> ;;</span><br><span class=\"line\">                                -b) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Found the -b option&quot;</span> ;;</span><br><span class=\"line\">                                -c) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Found the -c option&quot;</span> ;;</span><br><span class=\"line\">                                *) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> is not an option&quot;</span> ;;</span><br><span class=\"line\">         <span class=\"keyword\">esac</span></span><br><span class=\"line\">         <span class=\"built_in\">shift</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分离参数和选项、处理带值选项\"><a href=\"#分离参数和选项、处理带值选项\" class=\"headerlink\" title=\"分离参数和选项、处理带值选项\"></a>分离参数和选项、处理带值选项</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># extracting options and parameters</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> [ -n <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">                                -a) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Found the -a option&quot;</span> ;;</span><br><span class=\"line\">                                -b) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Found the -b option&quot;</span>;;</span><br><span class=\"line\">                                -c) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Found the -c option&quot;</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcoption=$(<span class=\"variable\">$2</span> * <span class=\"variable\">$3</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"built_in\">echo</span> <span class=\"variable\">$coption</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"built_in\">shift</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"built_in\">shift</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;;</span><br><span class=\"line\">                                --) <span class=\"built_in\">shift</span></span><br><span class=\"line\">                                                <span class=\"built_in\">break</span> ;;</span><br><span class=\"line\">                                *) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> is not an option&quot;</span>;;</span><br><span class=\"line\">                <span class=\"keyword\">esac</span></span><br><span class=\"line\">                <span class=\"built_in\">shift</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"keyword\">for</span> param <span class=\"keyword\">in</span> <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Parameter #<span class=\"variable\">$count</span>: <span class=\"variable\">$param</span>&quot;</span></span><br><span class=\"line\">                count=$(( <span class=\"variable\">$count</span> + <span class=\"number\">1</span> ))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"利用选项和参数实现阶乘和求和的计算工具\"><a href=\"#利用选项和参数实现阶乘和求和的计算工具\" class=\"headerlink\" title=\"利用选项和参数实现阶乘和求和的计算工具\"></a>利用选项和参数实现阶乘和求和的计算工具</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$#</span> -eq 0 ] || [ <span class=\"variable\">$#</span> -eq 1 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;sum and factorial tool&quot;</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Usage:&quot;</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;          -a number ...&quot;</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;          -f number&quot;</span></span><br><span class=\"line\">                <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">                -a)</span><br><span class=\"line\">                                <span class=\"keyword\">while</span> [ -n <span class=\"string\">&quot;<span class=\"variable\">$2</span>&quot;</span> ]</span><br><span class=\"line\">                                <span class=\"keyword\">do</span></span><br><span class=\"line\">                                                <span class=\"built_in\">sum</span>=$[<span class=\"variable\">$sum</span> + <span class=\"variable\">$2</span>]</span><br><span class=\"line\">                                                <span class=\"built_in\">shift</span></span><br><span class=\"line\">                                <span class=\"keyword\">done</span></span><br><span class=\"line\">                                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;sum=<span class=\"variable\">$sum</span>&quot;</span></span><br><span class=\"line\">                                <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\"><span class=\"comment\"># shift</span></span><br><span class=\"line\"><span class=\"comment\"># for i in $@</span></span><br><span class=\"line\"><span class=\"comment\"># do</span></span><br><span class=\"line\">\t<span class=\"comment\"># sum=$((sum + i))</span></span><br><span class=\"line\"><span class=\"comment\"># done</span></span><br><span class=\"line\"><span class=\"comment\"># exit 0</span></span><br><span class=\"line\">                                ;;</span><br><span class=\"line\">                -f)</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> [ <span class=\"variable\">$2</span> -eq 0 ]</span><br><span class=\"line\">                                <span class=\"keyword\">then</span></span><br><span class=\"line\">                                                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;fact=1&quot;</span></span><br><span class=\"line\">                                                <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\">                                <span class=\"keyword\">fi</span></span><br><span class=\"line\">                                fact=1</span><br><span class=\"line\">                                <span class=\"keyword\">for</span>((i=<span class=\"number\">1</span>; i&lt;=<span class=\"variable\">$2</span>; i++))</span><br><span class=\"line\">                                <span class=\"keyword\">do</span></span><br><span class=\"line\">                                                fact=$[<span class=\"variable\">$fact</span> * <span class=\"variable\">$i</span>]</span><br><span class=\"line\">                                <span class=\"keyword\">done</span></span><br><span class=\"line\">                                <span class=\"built_in\">echo</span> fact=<span class=\"variable\">$fact</span></span><br><span class=\"line\">                                <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\">                                ;;</span><br><span class=\"line\">                -h)</span><br><span class=\"line\">                                ;;</span><br><span class=\"line\">                *)</span><br><span class=\"line\">                                <span class=\"built_in\">echo</span></span><br><span class=\"line\">                                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;sum and factorial tool&quot;</span></span><br><span class=\"line\">                                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Usage:&quot;</span></span><br><span class=\"line\">                                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;          -a number ...&quot;</span></span><br><span class=\"line\">                                <span class=\"built_in\">echo</span> <span class=\"string\">&quot;          -f number&quot;</span></span><br><span class=\"line\">                                ;;</span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标准化选项\"><a href=\"#标准化选项\" class=\"headerlink\" title=\"标准化选项\"></a>标准化选项</h2><p><img src=\"/Untitled%2040.png\" alt=\"Untitled\"></p>\n"},{"title":"使用重定向呈现数据","date":"2023-04-18T03:31:23.000Z","_content":"\n有些时候想要保存某个命令的输出而不仅仅只是让它显示在显示器上。 `bash shell`提供了几个操作符，可以将命令的输出重定向到另一个位置（比如文件）。重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。\n\n## 输出重定向\n\n```\nubuntu@sh:~$ date > test6\nubuntu@sh:~$ ls -l test6\n-rw-rw-r-- 1 ubuntu ubuntu 29 Mar 26 19:23 test6\nubuntu@sh:~$ cat test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu@sh:~$\n```\n\n重定向操作符创建了一个文件 `test6`（通过默认的 `umask`设置），并将 `date`命令的输出重定向到该文件中。如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。\n\n有时，可能并不想覆盖文件原有内容，而是想要将命令的输出追加到已有文件中，比如正在创建一个记录系统上某个操作的日志文件。在这种情况下，可以用双大于号 `（>>）`来追加数据。\n\n```\nubuntu@sh:~$ who >> test6\nubuntu@sh:~$ cat test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu   tty1         2023-03-26 19:01\nubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)\nubuntu@sh:~$\n```\n\n`test6`文件在原来`who`命令输出的基础上又加上了`date`命令的输出\n\n## 输入重定向\n\n输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。输入重定向符号是小于号`（<）`\n\n```powershell\nubuntu@sh:~$ cat test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu   tty1         2023-03-26 19:01\nubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)\nubuntu@sh:~$ wc < test6\n  3  15 122\nubuntu@sh:~$\n```\n\n`wc`命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值：文本的行数，文本的词数，文本的字节数。\n\n## 呈现数据\n\n### 标准文件描述符\n\nLinux的标准文件描述符：\n\n| 文件描述符 | 缩写 | 描述 |\n| --- | --- | --- |\n| 0 | STDIN | 标准输入 |\n| 1 | STDOUT | 标准输出 |\n| 2 | STDERR | 标准错误 |\n- 这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。\n1. STDIN(标准输入)\n    \n    STDIN文件描述符代表`shell`的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。\n    \n    在使用输入重定向符号`（<）`时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。\n    \n    当在命令行上只输入`cat`命令时，它会从`STDIN`接受输入。输入一行，`cat`命令就会显示出一行。\n    但你也可以通过`STDIN`重定向符号强制`cat`命令接受来自另一个`非STDIN`文件的输入。\n    \n    ```\n    ubuntu@sh:~$ cat < test6\n    Sun Mar 26 19:23:54 PDT 2023\n    ubuntu   tty1         2023-03-26 19:01\n    ubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)\n    ```\n    \n2. STDOUT(标准输出)\n    \n    `STDOUT`文件描述符代表`shell`的标准输出。在终端界面上，标准输出就是终端显示器。`shell`的所有输出（包括`shell`中运行的程序和脚本）会被定向到标准输出中，也就是显示器。\n    \n    默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。我们也可以使用`>`将输出重定向到文件。\n    \n    当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。shell对于错误消息的处理是跟普通输出分开的。如果创建了在后台模式下运行的shell脚本，通常必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。需要换种方法来处理。\n    \n    ```\n    ubuntu@sh:~$ ls -al badfile > test3\n    ls: cannot access 'badfile': No such file or directory\n    ubuntu@sh:~$ cat test3\n    ubuntu@sh:~$\n    ```\n    \n3. STDERR(标准错误)\n    \n    shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。但从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，常常会想改变这种行为，尤其是当希望将错误消息保存到日志文件中的时候。\n    \n\n### 重定向错误\n\n- 只重定向错误\n    \n    STDERR文件描述符被设成2。可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。\n    \n    ```\n    ubuntu@sh:~$ ls -al badfile 2> test3\n    ubuntu@sh:~$ cat test3\n    ls: cannot access 'badfile': No such file or directory\n    ubuntu@sh:~$\n    ```\n    \n- 重定向错误和数据\n    \n    如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。\n    \n    ```\n    ubuntu@sh:~$ ls -al test3 test6 badtest 2>test7 1>test8\n    ubuntu@sh:~$ cat test7\n    ls: cannot access 'badtest': No such file or directory\n    ubuntu@sh:~$ cat test8\n    -rw-rw-r-- 1 ubuntu ubuntu  55 Mar 26 20:24 test3\n    -rw-rw-r-- 1 ubuntu ubuntu 122 Mar 26 19:27 test6\n    ubuntu@sh:~$\n    ```\n    \n    shell利用`1>`符号将ls命令的正常输出重定向到了test8文件，而这些输出本该是进入`STDOUT`的。所有本该输出到`STDERR`的错误消息通过`2>`符号被重定向到了test7文件。\n    \n    可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别出错误信息。另外也可以将`STDERR`和`STDOUT`的输出重定向到同一个输出文件。为此`bash shell`提供了特殊的重定向符号`&>`。\n    \n    ```\n    ubuntu@sh:~$ ls -al badtest test3 test6 badtest &> test7\n    ubuntu@sh:~$ cat test7\n    ls: cannot access 'badtest': No such file or directory\n    ls: cannot access 'badtest': No such file or directory\n    -rw-rw-r-- 1 ubuntu ubuntu  55 Mar 26 20:24 test3\n    -rw-rw-r-- 1 ubuntu ubuntu 122 Mar 26 19:27 test6\n    ```\n    \n\n## 在脚本中重定向输出\n\n可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：\n\n1. 临时重定向行输出\n2. 永久重定向脚本中的所有命令\n\n### 临时重定向\n\n如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，必须在文件描述符数字之前加一个&：\n\n```\nubuntu@sh:~$ cat test.sh\n#!/bin/bash\n\necho \"This is an error\" >&2\necho \"This is normal output\"\n\nubuntu@sh:~$ bash test.sh 2> test9\nThis is normal output\nubuntu@sh:~$ cat test9\nThis is an error\n```\n\n### 永久重定向\n\n如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐，用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符，exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。\n\n```bash\n#!/bin/bash\n# redirecting all output to a file\nexec 1>testout\necho \"This is a test of redirecting all output\"\necho \"from a script to another file.\"\necho \"without having to redirect every individual line\"\n```\n\n```\nubuntu@sh:~$ bash test.sh\nubuntu@sh:~$ cat testout\nThis is a test of redirecting all output\nfrom a script to another file.\nwithout having to redirect every individual line\n```\n\n- 脚本执行过程中重定向\n    \n    ```bash\n    #!/bin/bash\n    # redirecting output to different locations\n    exec 2>testerror\n    echo \"This is the start of the script\"\n    echo \"now redirecting all output to another location\"\n    exec 1>testout\n    echo \"This output should go to the testout file\"\n    echo \"but this should go to the testerror file\" >&2\n    ```\n    \n\n## 在脚本中重定向输入\n\n可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许将STDIN重定向到Linux系统上的文件中。这个重定向只要在脚本需要输入时就会作用\n\n```bash\n#!/bin/bash\n# redirecting file input\nexec 0< testfile\ncount=1\nwhile read line\ndo\necho \"Line #$count: $line\"\ncount=$[ $count + 1 ]\ndone\n```\n\n## 创建自己的重定向\n\n### 创建输出文件描述符\n\n在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。在shell中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。\n\n```bash\n#!/bin/bash\n# using an alternative file descriptor\nexec 3>test3out\necho \"This should display on the monitor\"\necho \"and this should be stored in the file\" >&3\necho \"Then this should be back on the monitor\"\n```\n\n### 创建输入文件描述符\n\n可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置。\n\n```bash\n#!/bin/bash\n# redirecting input file descriptors\nexec 6<&0\nexec 0< testfile\ncount=1\nwhile read line\ndo\necho \"Line #$count: $line\"\ncount=$[ $count + 1 ]\ndone\nexec 0<&6\nread -p \"Are you done now? \" answer\ncase $answer in\nY|y) echo \"Goodbye\";;\nN|n) echo \"Sorry, this is the end.\";;\nesac\n```\n\n## 组织命令输出\n\n有时候，可能不想显示脚本的输出。这在将脚本作为后台进程运行时很常见。可以将STDERR重定向到一个叫作null文件的特殊/文件。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示。\n\n```bash\nubuntu@sh:~$ ls -al > /dev/null\nubuntu@sh:~$\nubuntu@sh:~$ ls -al badfile 2> /dev/null\nubuntu@sh:~$\n```","source":"_posts/linux_shell/6.使用重定向呈现数据.md","raw":"---\ntitle: 使用重定向呈现数据\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n有些时候想要保存某个命令的输出而不仅仅只是让它显示在显示器上。 `bash shell`提供了几个操作符，可以将命令的输出重定向到另一个位置（比如文件）。重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。\n\n## 输出重定向\n\n```\nubuntu@sh:~$ date > test6\nubuntu@sh:~$ ls -l test6\n-rw-rw-r-- 1 ubuntu ubuntu 29 Mar 26 19:23 test6\nubuntu@sh:~$ cat test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu@sh:~$\n```\n\n重定向操作符创建了一个文件 `test6`（通过默认的 `umask`设置），并将 `date`命令的输出重定向到该文件中。如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。\n\n有时，可能并不想覆盖文件原有内容，而是想要将命令的输出追加到已有文件中，比如正在创建一个记录系统上某个操作的日志文件。在这种情况下，可以用双大于号 `（>>）`来追加数据。\n\n```\nubuntu@sh:~$ who >> test6\nubuntu@sh:~$ cat test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu   tty1         2023-03-26 19:01\nubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)\nubuntu@sh:~$\n```\n\n`test6`文件在原来`who`命令输出的基础上又加上了`date`命令的输出\n\n## 输入重定向\n\n输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。输入重定向符号是小于号`（<）`\n\n```powershell\nubuntu@sh:~$ cat test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu   tty1         2023-03-26 19:01\nubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)\nubuntu@sh:~$ wc < test6\n  3  15 122\nubuntu@sh:~$\n```\n\n`wc`命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值：文本的行数，文本的词数，文本的字节数。\n\n## 呈现数据\n\n### 标准文件描述符\n\nLinux的标准文件描述符：\n\n| 文件描述符 | 缩写 | 描述 |\n| --- | --- | --- |\n| 0 | STDIN | 标准输入 |\n| 1 | STDOUT | 标准输出 |\n| 2 | STDERR | 标准错误 |\n- 这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。\n1. STDIN(标准输入)\n    \n    STDIN文件描述符代表`shell`的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。\n    \n    在使用输入重定向符号`（<）`时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。\n    \n    当在命令行上只输入`cat`命令时，它会从`STDIN`接受输入。输入一行，`cat`命令就会显示出一行。\n    但你也可以通过`STDIN`重定向符号强制`cat`命令接受来自另一个`非STDIN`文件的输入。\n    \n    ```\n    ubuntu@sh:~$ cat < test6\n    Sun Mar 26 19:23:54 PDT 2023\n    ubuntu   tty1         2023-03-26 19:01\n    ubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)\n    ```\n    \n2. STDOUT(标准输出)\n    \n    `STDOUT`文件描述符代表`shell`的标准输出。在终端界面上，标准输出就是终端显示器。`shell`的所有输出（包括`shell`中运行的程序和脚本）会被定向到标准输出中，也就是显示器。\n    \n    默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。我们也可以使用`>`将输出重定向到文件。\n    \n    当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。shell对于错误消息的处理是跟普通输出分开的。如果创建了在后台模式下运行的shell脚本，通常必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。需要换种方法来处理。\n    \n    ```\n    ubuntu@sh:~$ ls -al badfile > test3\n    ls: cannot access 'badfile': No such file or directory\n    ubuntu@sh:~$ cat test3\n    ubuntu@sh:~$\n    ```\n    \n3. STDERR(标准错误)\n    \n    shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。但从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，常常会想改变这种行为，尤其是当希望将错误消息保存到日志文件中的时候。\n    \n\n### 重定向错误\n\n- 只重定向错误\n    \n    STDERR文件描述符被设成2。可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。\n    \n    ```\n    ubuntu@sh:~$ ls -al badfile 2> test3\n    ubuntu@sh:~$ cat test3\n    ls: cannot access 'badfile': No such file or directory\n    ubuntu@sh:~$\n    ```\n    \n- 重定向错误和数据\n    \n    如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。\n    \n    ```\n    ubuntu@sh:~$ ls -al test3 test6 badtest 2>test7 1>test8\n    ubuntu@sh:~$ cat test7\n    ls: cannot access 'badtest': No such file or directory\n    ubuntu@sh:~$ cat test8\n    -rw-rw-r-- 1 ubuntu ubuntu  55 Mar 26 20:24 test3\n    -rw-rw-r-- 1 ubuntu ubuntu 122 Mar 26 19:27 test6\n    ubuntu@sh:~$\n    ```\n    \n    shell利用`1>`符号将ls命令的正常输出重定向到了test8文件，而这些输出本该是进入`STDOUT`的。所有本该输出到`STDERR`的错误消息通过`2>`符号被重定向到了test7文件。\n    \n    可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别出错误信息。另外也可以将`STDERR`和`STDOUT`的输出重定向到同一个输出文件。为此`bash shell`提供了特殊的重定向符号`&>`。\n    \n    ```\n    ubuntu@sh:~$ ls -al badtest test3 test6 badtest &> test7\n    ubuntu@sh:~$ cat test7\n    ls: cannot access 'badtest': No such file or directory\n    ls: cannot access 'badtest': No such file or directory\n    -rw-rw-r-- 1 ubuntu ubuntu  55 Mar 26 20:24 test3\n    -rw-rw-r-- 1 ubuntu ubuntu 122 Mar 26 19:27 test6\n    ```\n    \n\n## 在脚本中重定向输出\n\n可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：\n\n1. 临时重定向行输出\n2. 永久重定向脚本中的所有命令\n\n### 临时重定向\n\n如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，必须在文件描述符数字之前加一个&：\n\n```\nubuntu@sh:~$ cat test.sh\n#!/bin/bash\n\necho \"This is an error\" >&2\necho \"This is normal output\"\n\nubuntu@sh:~$ bash test.sh 2> test9\nThis is normal output\nubuntu@sh:~$ cat test9\nThis is an error\n```\n\n### 永久重定向\n\n如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐，用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符，exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。\n\n```bash\n#!/bin/bash\n# redirecting all output to a file\nexec 1>testout\necho \"This is a test of redirecting all output\"\necho \"from a script to another file.\"\necho \"without having to redirect every individual line\"\n```\n\n```\nubuntu@sh:~$ bash test.sh\nubuntu@sh:~$ cat testout\nThis is a test of redirecting all output\nfrom a script to another file.\nwithout having to redirect every individual line\n```\n\n- 脚本执行过程中重定向\n    \n    ```bash\n    #!/bin/bash\n    # redirecting output to different locations\n    exec 2>testerror\n    echo \"This is the start of the script\"\n    echo \"now redirecting all output to another location\"\n    exec 1>testout\n    echo \"This output should go to the testout file\"\n    echo \"but this should go to the testerror file\" >&2\n    ```\n    \n\n## 在脚本中重定向输入\n\n可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许将STDIN重定向到Linux系统上的文件中。这个重定向只要在脚本需要输入时就会作用\n\n```bash\n#!/bin/bash\n# redirecting file input\nexec 0< testfile\ncount=1\nwhile read line\ndo\necho \"Line #$count: $line\"\ncount=$[ $count + 1 ]\ndone\n```\n\n## 创建自己的重定向\n\n### 创建输出文件描述符\n\n在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。在shell中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。\n\n```bash\n#!/bin/bash\n# using an alternative file descriptor\nexec 3>test3out\necho \"This should display on the monitor\"\necho \"and this should be stored in the file\" >&3\necho \"Then this should be back on the monitor\"\n```\n\n### 创建输入文件描述符\n\n可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置。\n\n```bash\n#!/bin/bash\n# redirecting input file descriptors\nexec 6<&0\nexec 0< testfile\ncount=1\nwhile read line\ndo\necho \"Line #$count: $line\"\ncount=$[ $count + 1 ]\ndone\nexec 0<&6\nread -p \"Are you done now? \" answer\ncase $answer in\nY|y) echo \"Goodbye\";;\nN|n) echo \"Sorry, this is the end.\";;\nesac\n```\n\n## 组织命令输出\n\n有时候，可能不想显示脚本的输出。这在将脚本作为后台进程运行时很常见。可以将STDERR重定向到一个叫作null文件的特殊/文件。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示。\n\n```bash\nubuntu@sh:~$ ls -al > /dev/null\nubuntu@sh:~$\nubuntu@sh:~$ ls -al badfile 2> /dev/null\nubuntu@sh:~$\n```","slug":"linux_shell/6.使用重定向呈现数据","published":1,"updated":"2023-06-10T08:09:30.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cliuf72wf0007j1nz6galcmuq","content":"<p>有些时候想要保存某个命令的输出而不仅仅只是让它显示在显示器上。 <code>bash shell</code>提供了几个操作符，可以将命令的输出重定向到另一个位置（比如文件）。重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。</p>\n<h2 id=\"输出重定向\"><a href=\"#输出重定向\" class=\"headerlink\" title=\"输出重定向\"></a>输出重定向</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ date &gt; test6</span><br><span class=\"line\">ubuntu@sh:~$ ls -l test6</span><br><span class=\"line\">-rw-rw-r-- 1 ubuntu ubuntu 29 Mar 26 19:23 test6</span><br><span class=\"line\">ubuntu@sh:~$ cat test6</span><br><span class=\"line\">Sun Mar 26 19:23:54 PDT 2023</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n\n<p>重定向操作符创建了一个文件 <code>test6</code>（通过默认的 <code>umask</code>设置），并将 <code>date</code>命令的输出重定向到该文件中。如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。</p>\n<p>有时，可能并不想覆盖文件原有内容，而是想要将命令的输出追加到已有文件中，比如正在创建一个记录系统上某个操作的日志文件。在这种情况下，可以用双大于号 <code>（&gt;&gt;）</code>来追加数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ who &gt;&gt; test6</span><br><span class=\"line\">ubuntu@sh:~$ cat test6</span><br><span class=\"line\">Sun Mar 26 19:23:54 PDT 2023</span><br><span class=\"line\">ubuntu   tty1         2023-03-26 19:01</span><br><span class=\"line\">ubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n\n<p><code>test6</code>文件在原来<code>who</code>命令输出的基础上又加上了<code>date</code>命令的输出</p>\n<h2 id=\"输入重定向\"><a href=\"#输入重定向\" class=\"headerlink\" title=\"输入重定向\"></a>输入重定向</h2><p>输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。输入重定向符号是小于号<code>（&lt;）</code></p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~<span class=\"variable\">$</span> <span class=\"built_in\">cat</span> test6</span><br><span class=\"line\">Sun Mar <span class=\"number\">26</span> <span class=\"number\">19</span>:<span class=\"number\">23</span>:<span class=\"number\">54</span> PDT <span class=\"number\">2023</span></span><br><span class=\"line\">ubuntu   tty1         <span class=\"number\">2023</span><span class=\"literal\">-03-26</span> <span class=\"number\">19</span>:<span class=\"number\">01</span></span><br><span class=\"line\">ubuntu   pts/<span class=\"number\">0</span>        <span class=\"number\">2023</span><span class=\"literal\">-03-26</span> <span class=\"number\">19</span>:<span class=\"number\">01</span> (<span class=\"number\">192.168</span>.<span class=\"number\">13.1</span>)</span><br><span class=\"line\">ubuntu@sh:~<span class=\"variable\">$</span> wc &lt; test6</span><br><span class=\"line\">  <span class=\"number\">3</span>  <span class=\"number\">15</span> <span class=\"number\">122</span></span><br><span class=\"line\">ubuntu@sh:~<span class=\"variable\">$</span></span><br></pre></td></tr></table></figure>\n\n<p><code>wc</code>命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值：文本的行数，文本的词数，文本的字节数。</p>\n<h2 id=\"呈现数据\"><a href=\"#呈现数据\" class=\"headerlink\" title=\"呈现数据\"></a>呈现数据</h2><h3 id=\"标准文件描述符\"><a href=\"#标准文件描述符\" class=\"headerlink\" title=\"标准文件描述符\"></a>标准文件描述符</h3><p>Linux的标准文件描述符：</p>\n<table>\n<thead>\n<tr>\n<th>文件描述符</th>\n<th>缩写</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>STDIN</td>\n<td>标准输入</td>\n</tr>\n<tr>\n<td>1</td>\n<td>STDOUT</td>\n<td>标准输出</td>\n</tr>\n<tr>\n<td>2</td>\n<td>STDERR</td>\n<td>标准错误</td>\n</tr>\n</tbody></table>\n<ul>\n<li>这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。</li>\n</ul>\n<ol>\n<li><p>STDIN(标准输入)</p>\n<p> STDIN文件描述符代表<code>shell</code>的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。</p>\n<p> 在使用输入重定向符号<code>（&lt;）</code>时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。</p>\n<p> 当在命令行上只输入<code>cat</code>命令时，它会从<code>STDIN</code>接受输入。输入一行，<code>cat</code>命令就会显示出一行。<br> 但你也可以通过<code>STDIN</code>重定向符号强制<code>cat</code>命令接受来自另一个<code>非STDIN</code>文件的输入。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ cat &lt; test6</span><br><span class=\"line\">Sun Mar 26 19:23:54 PDT 2023</span><br><span class=\"line\">ubuntu   tty1         2023-03-26 19:01</span><br><span class=\"line\">ubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>STDOUT(标准输出)</p>\n<p> <code>STDOUT</code>文件描述符代表<code>shell</code>的标准输出。在终端界面上，标准输出就是终端显示器。<code>shell</code>的所有输出（包括<code>shell</code>中运行的程序和脚本）会被定向到标准输出中，也就是显示器。</p>\n<p> 默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。我们也可以使用<code>&gt;</code>将输出重定向到文件。</p>\n<p> 当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。shell对于错误消息的处理是跟普通输出分开的。如果创建了在后台模式下运行的shell脚本，通常必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。需要换种方法来处理。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ ls -al badfile &gt; test3</span><br><span class=\"line\">ls: cannot access &#x27;badfile&#x27;: No such file or directory</span><br><span class=\"line\">ubuntu@sh:~$ cat test3</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>STDERR(标准错误)</p>\n<p> shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。但从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，常常会想改变这种行为，尤其是当希望将错误消息保存到日志文件中的时候。</p>\n</li>\n</ol>\n<h3 id=\"重定向错误\"><a href=\"#重定向错误\" class=\"headerlink\" title=\"重定向错误\"></a>重定向错误</h3><ul>\n<li><p>只重定向错误</p>\n<p>  STDERR文件描述符被设成2。可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ ls -al badfile 2&gt; test3</span><br><span class=\"line\">ubuntu@sh:~$ cat test3</span><br><span class=\"line\">ls: cannot access &#x27;badfile&#x27;: No such file or directory</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重定向错误和数据</p>\n<p>  如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ ls -al test3 test6 badtest 2&gt;test7 1&gt;test8</span><br><span class=\"line\">ubuntu@sh:~$ cat test7</span><br><span class=\"line\">ls: cannot access &#x27;badtest&#x27;: No such file or directory</span><br><span class=\"line\">ubuntu@sh:~$ cat test8</span><br><span class=\"line\">-rw-rw-r-- 1 ubuntu ubuntu  55 Mar 26 20:24 test3</span><br><span class=\"line\">-rw-rw-r-- 1 ubuntu ubuntu 122 Mar 26 19:27 test6</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n<p>  shell利用<code>1&gt;</code>符号将ls命令的正常输出重定向到了test8文件，而这些输出本该是进入<code>STDOUT</code>的。所有本该输出到<code>STDERR</code>的错误消息通过<code>2&gt;</code>符号被重定向到了test7文件。</p>\n<p>  可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别出错误信息。另外也可以将<code>STDERR</code>和<code>STDOUT</code>的输出重定向到同一个输出文件。为此<code>bash shell</code>提供了特殊的重定向符号<code>&amp;&gt;</code>。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ ls -al badtest test3 test6 badtest &amp;&gt; test7</span><br><span class=\"line\">ubuntu@sh:~$ cat test7</span><br><span class=\"line\">ls: cannot access &#x27;badtest&#x27;: No such file or directory</span><br><span class=\"line\">ls: cannot access &#x27;badtest&#x27;: No such file or directory</span><br><span class=\"line\">-rw-rw-r-- 1 ubuntu ubuntu  55 Mar 26 20:24 test3</span><br><span class=\"line\">-rw-rw-r-- 1 ubuntu ubuntu 122 Mar 26 19:27 test6</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"在脚本中重定向输出\"><a href=\"#在脚本中重定向输出\" class=\"headerlink\" title=\"在脚本中重定向输出\"></a>在脚本中重定向输出</h2><p>可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：</p>\n<ol>\n<li>临时重定向行输出</li>\n<li>永久重定向脚本中的所有命令</li>\n</ol>\n<h3 id=\"临时重定向\"><a href=\"#临时重定向\" class=\"headerlink\" title=\"临时重定向\"></a>临时重定向</h3><p>如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，必须在文件描述符数字之前加一个&amp;：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ cat test.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;This is an error&quot; &gt;&amp;2</span><br><span class=\"line\">echo &quot;This is normal output&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">ubuntu@sh:~$ bash test.sh 2&gt; test9</span><br><span class=\"line\">This is normal output</span><br><span class=\"line\">ubuntu@sh:~$ cat test9</span><br><span class=\"line\">This is an error</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"永久重定向\"><a href=\"#永久重定向\" class=\"headerlink\" title=\"永久重定向\"></a>永久重定向</h3><p>如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐，用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符，exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># redirecting all output to a file</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 1&gt;testout</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This is a test of redirecting all output&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;from a script to another file.&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;without having to redirect every individual line&quot;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ bash test.sh</span><br><span class=\"line\">ubuntu@sh:~$ cat testout</span><br><span class=\"line\">This is a test of redirecting all output</span><br><span class=\"line\">from a script to another file.</span><br><span class=\"line\">without having to redirect every individual line</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>脚本执行过程中重定向</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># redirecting output to different locations</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 2&gt;testerror</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This is the start of the script&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;now redirecting all output to another location&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 1&gt;testout</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This output should go to the testout file&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;but this should go to the testerror file&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"在脚本中重定向输入\"><a href=\"#在脚本中重定向输入\" class=\"headerlink\" title=\"在脚本中重定向输入\"></a>在脚本中重定向输入</h2><p>可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许将STDIN重定向到Linux系统上的文件中。这个重定向只要在脚本需要输入时就会作用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># redirecting file input</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 0&lt; testfile</span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"built_in\">read</span> line</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Line #<span class=\"variable\">$count</span>: <span class=\"variable\">$line</span>&quot;</span></span><br><span class=\"line\">count=$[ <span class=\"variable\">$count</span> + 1 ]</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建自己的重定向\"><a href=\"#创建自己的重定向\" class=\"headerlink\" title=\"创建自己的重定向\"></a>创建自己的重定向</h2><h3 id=\"创建输出文件描述符\"><a href=\"#创建输出文件描述符\" class=\"headerlink\" title=\"创建输出文件描述符\"></a>创建输出文件描述符</h3><p>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。在shell中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># using an alternative file descriptor</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 3&gt;test3out</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This should display on the monitor&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;and this should be stored in the file&quot;</span> &gt;&amp;3</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Then this should be back on the monitor&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建输入文件描述符\"><a href=\"#创建输入文件描述符\" class=\"headerlink\" title=\"创建输入文件描述符\"></a>创建输入文件描述符</h3><p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># redirecting input file descriptors</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 6&lt;&amp;0</span><br><span class=\"line\"><span class=\"built_in\">exec</span> 0&lt; testfile</span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"built_in\">read</span> line</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Line #<span class=\"variable\">$count</span>: <span class=\"variable\">$line</span>&quot;</span></span><br><span class=\"line\">count=$[ <span class=\"variable\">$count</span> + 1 ]</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 0&lt;&amp;6</span><br><span class=\"line\"><span class=\"built_in\">read</span> -p <span class=\"string\">&quot;Are you done now? &quot;</span> answer</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"variable\">$answer</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">Y|y) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Goodbye&quot;</span>;;</span><br><span class=\"line\">N|n) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Sorry, this is the end.&quot;</span>;;</span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"组织命令输出\"><a href=\"#组织命令输出\" class=\"headerlink\" title=\"组织命令输出\"></a>组织命令输出</h2><p>有时候，可能不想显示脚本的输出。这在将脚本作为后台进程运行时很常见。可以将STDERR重定向到一个叫作null文件的特殊&#x2F;文件。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。在Linux系统上null文件的标准位置是&#x2F;dev&#x2F;null。你重定向到该位置的任何数据都会被丢掉，不会显示。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ <span class=\"built_in\">ls</span> -al &gt; /dev/null</span><br><span class=\"line\">ubuntu@sh:~$</span><br><span class=\"line\">ubuntu@sh:~$ <span class=\"built_in\">ls</span> -al badfile 2&gt; /dev/null</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>有些时候想要保存某个命令的输出而不仅仅只是让它显示在显示器上。 <code>bash shell</code>提供了几个操作符，可以将命令的输出重定向到另一个位置（比如文件）。重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。</p>\n<h2 id=\"输出重定向\"><a href=\"#输出重定向\" class=\"headerlink\" title=\"输出重定向\"></a>输出重定向</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ date &gt; test6</span><br><span class=\"line\">ubuntu@sh:~$ ls -l test6</span><br><span class=\"line\">-rw-rw-r-- 1 ubuntu ubuntu 29 Mar 26 19:23 test6</span><br><span class=\"line\">ubuntu@sh:~$ cat test6</span><br><span class=\"line\">Sun Mar 26 19:23:54 PDT 2023</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n\n<p>重定向操作符创建了一个文件 <code>test6</code>（通过默认的 <code>umask</code>设置），并将 <code>date</code>命令的输出重定向到该文件中。如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。</p>\n<p>有时，可能并不想覆盖文件原有内容，而是想要将命令的输出追加到已有文件中，比如正在创建一个记录系统上某个操作的日志文件。在这种情况下，可以用双大于号 <code>（&gt;&gt;）</code>来追加数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ who &gt;&gt; test6</span><br><span class=\"line\">ubuntu@sh:~$ cat test6</span><br><span class=\"line\">Sun Mar 26 19:23:54 PDT 2023</span><br><span class=\"line\">ubuntu   tty1         2023-03-26 19:01</span><br><span class=\"line\">ubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n\n<p><code>test6</code>文件在原来<code>who</code>命令输出的基础上又加上了<code>date</code>命令的输出</p>\n<h2 id=\"输入重定向\"><a href=\"#输入重定向\" class=\"headerlink\" title=\"输入重定向\"></a>输入重定向</h2><p>输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。输入重定向符号是小于号<code>（&lt;）</code></p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~<span class=\"variable\">$</span> <span class=\"built_in\">cat</span> test6</span><br><span class=\"line\">Sun Mar <span class=\"number\">26</span> <span class=\"number\">19</span>:<span class=\"number\">23</span>:<span class=\"number\">54</span> PDT <span class=\"number\">2023</span></span><br><span class=\"line\">ubuntu   tty1         <span class=\"number\">2023</span><span class=\"literal\">-03-26</span> <span class=\"number\">19</span>:<span class=\"number\">01</span></span><br><span class=\"line\">ubuntu   pts/<span class=\"number\">0</span>        <span class=\"number\">2023</span><span class=\"literal\">-03-26</span> <span class=\"number\">19</span>:<span class=\"number\">01</span> (<span class=\"number\">192.168</span>.<span class=\"number\">13.1</span>)</span><br><span class=\"line\">ubuntu@sh:~<span class=\"variable\">$</span> wc &lt; test6</span><br><span class=\"line\">  <span class=\"number\">3</span>  <span class=\"number\">15</span> <span class=\"number\">122</span></span><br><span class=\"line\">ubuntu@sh:~<span class=\"variable\">$</span></span><br></pre></td></tr></table></figure>\n\n<p><code>wc</code>命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值：文本的行数，文本的词数，文本的字节数。</p>\n<h2 id=\"呈现数据\"><a href=\"#呈现数据\" class=\"headerlink\" title=\"呈现数据\"></a>呈现数据</h2><h3 id=\"标准文件描述符\"><a href=\"#标准文件描述符\" class=\"headerlink\" title=\"标准文件描述符\"></a>标准文件描述符</h3><p>Linux的标准文件描述符：</p>\n<table>\n<thead>\n<tr>\n<th>文件描述符</th>\n<th>缩写</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>STDIN</td>\n<td>标准输入</td>\n</tr>\n<tr>\n<td>1</td>\n<td>STDOUT</td>\n<td>标准输出</td>\n</tr>\n<tr>\n<td>2</td>\n<td>STDERR</td>\n<td>标准错误</td>\n</tr>\n</tbody></table>\n<ul>\n<li>这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。</li>\n</ul>\n<ol>\n<li><p>STDIN(标准输入)</p>\n<p> STDIN文件描述符代表<code>shell</code>的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。</p>\n<p> 在使用输入重定向符号<code>（&lt;）</code>时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。</p>\n<p> 当在命令行上只输入<code>cat</code>命令时，它会从<code>STDIN</code>接受输入。输入一行，<code>cat</code>命令就会显示出一行。<br> 但你也可以通过<code>STDIN</code>重定向符号强制<code>cat</code>命令接受来自另一个<code>非STDIN</code>文件的输入。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ cat &lt; test6</span><br><span class=\"line\">Sun Mar 26 19:23:54 PDT 2023</span><br><span class=\"line\">ubuntu   tty1         2023-03-26 19:01</span><br><span class=\"line\">ubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>STDOUT(标准输出)</p>\n<p> <code>STDOUT</code>文件描述符代表<code>shell</code>的标准输出。在终端界面上，标准输出就是终端显示器。<code>shell</code>的所有输出（包括<code>shell</code>中运行的程序和脚本）会被定向到标准输出中，也就是显示器。</p>\n<p> 默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。我们也可以使用<code>&gt;</code>将输出重定向到文件。</p>\n<p> 当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。shell对于错误消息的处理是跟普通输出分开的。如果创建了在后台模式下运行的shell脚本，通常必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。需要换种方法来处理。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ ls -al badfile &gt; test3</span><br><span class=\"line\">ls: cannot access &#x27;badfile&#x27;: No such file or directory</span><br><span class=\"line\">ubuntu@sh:~$ cat test3</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>STDERR(标准错误)</p>\n<p> shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。但从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，常常会想改变这种行为，尤其是当希望将错误消息保存到日志文件中的时候。</p>\n</li>\n</ol>\n<h3 id=\"重定向错误\"><a href=\"#重定向错误\" class=\"headerlink\" title=\"重定向错误\"></a>重定向错误</h3><ul>\n<li><p>只重定向错误</p>\n<p>  STDERR文件描述符被设成2。可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ ls -al badfile 2&gt; test3</span><br><span class=\"line\">ubuntu@sh:~$ cat test3</span><br><span class=\"line\">ls: cannot access &#x27;badfile&#x27;: No such file or directory</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重定向错误和数据</p>\n<p>  如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ ls -al test3 test6 badtest 2&gt;test7 1&gt;test8</span><br><span class=\"line\">ubuntu@sh:~$ cat test7</span><br><span class=\"line\">ls: cannot access &#x27;badtest&#x27;: No such file or directory</span><br><span class=\"line\">ubuntu@sh:~$ cat test8</span><br><span class=\"line\">-rw-rw-r-- 1 ubuntu ubuntu  55 Mar 26 20:24 test3</span><br><span class=\"line\">-rw-rw-r-- 1 ubuntu ubuntu 122 Mar 26 19:27 test6</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n<p>  shell利用<code>1&gt;</code>符号将ls命令的正常输出重定向到了test8文件，而这些输出本该是进入<code>STDOUT</code>的。所有本该输出到<code>STDERR</code>的错误消息通过<code>2&gt;</code>符号被重定向到了test7文件。</p>\n<p>  可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别出错误信息。另外也可以将<code>STDERR</code>和<code>STDOUT</code>的输出重定向到同一个输出文件。为此<code>bash shell</code>提供了特殊的重定向符号<code>&amp;&gt;</code>。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ ls -al badtest test3 test6 badtest &amp;&gt; test7</span><br><span class=\"line\">ubuntu@sh:~$ cat test7</span><br><span class=\"line\">ls: cannot access &#x27;badtest&#x27;: No such file or directory</span><br><span class=\"line\">ls: cannot access &#x27;badtest&#x27;: No such file or directory</span><br><span class=\"line\">-rw-rw-r-- 1 ubuntu ubuntu  55 Mar 26 20:24 test3</span><br><span class=\"line\">-rw-rw-r-- 1 ubuntu ubuntu 122 Mar 26 19:27 test6</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"在脚本中重定向输出\"><a href=\"#在脚本中重定向输出\" class=\"headerlink\" title=\"在脚本中重定向输出\"></a>在脚本中重定向输出</h2><p>可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：</p>\n<ol>\n<li>临时重定向行输出</li>\n<li>永久重定向脚本中的所有命令</li>\n</ol>\n<h3 id=\"临时重定向\"><a href=\"#临时重定向\" class=\"headerlink\" title=\"临时重定向\"></a>临时重定向</h3><p>如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，必须在文件描述符数字之前加一个&amp;：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ cat test.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;This is an error&quot; &gt;&amp;2</span><br><span class=\"line\">echo &quot;This is normal output&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">ubuntu@sh:~$ bash test.sh 2&gt; test9</span><br><span class=\"line\">This is normal output</span><br><span class=\"line\">ubuntu@sh:~$ cat test9</span><br><span class=\"line\">This is an error</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"永久重定向\"><a href=\"#永久重定向\" class=\"headerlink\" title=\"永久重定向\"></a>永久重定向</h3><p>如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐，用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符，exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># redirecting all output to a file</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 1&gt;testout</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This is a test of redirecting all output&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;from a script to another file.&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;without having to redirect every individual line&quot;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ bash test.sh</span><br><span class=\"line\">ubuntu@sh:~$ cat testout</span><br><span class=\"line\">This is a test of redirecting all output</span><br><span class=\"line\">from a script to another file.</span><br><span class=\"line\">without having to redirect every individual line</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>脚本执行过程中重定向</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># redirecting output to different locations</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 2&gt;testerror</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This is the start of the script&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;now redirecting all output to another location&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 1&gt;testout</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This output should go to the testout file&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;but this should go to the testerror file&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"在脚本中重定向输入\"><a href=\"#在脚本中重定向输入\" class=\"headerlink\" title=\"在脚本中重定向输入\"></a>在脚本中重定向输入</h2><p>可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许将STDIN重定向到Linux系统上的文件中。这个重定向只要在脚本需要输入时就会作用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># redirecting file input</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 0&lt; testfile</span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"built_in\">read</span> line</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Line #<span class=\"variable\">$count</span>: <span class=\"variable\">$line</span>&quot;</span></span><br><span class=\"line\">count=$[ <span class=\"variable\">$count</span> + 1 ]</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建自己的重定向\"><a href=\"#创建自己的重定向\" class=\"headerlink\" title=\"创建自己的重定向\"></a>创建自己的重定向</h2><h3 id=\"创建输出文件描述符\"><a href=\"#创建输出文件描述符\" class=\"headerlink\" title=\"创建输出文件描述符\"></a>创建输出文件描述符</h3><p>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。在shell中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># using an alternative file descriptor</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 3&gt;test3out</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This should display on the monitor&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;and this should be stored in the file&quot;</span> &gt;&amp;3</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Then this should be back on the monitor&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建输入文件描述符\"><a href=\"#创建输入文件描述符\" class=\"headerlink\" title=\"创建输入文件描述符\"></a>创建输入文件描述符</h3><p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># redirecting input file descriptors</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 6&lt;&amp;0</span><br><span class=\"line\"><span class=\"built_in\">exec</span> 0&lt; testfile</span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"built_in\">read</span> line</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Line #<span class=\"variable\">$count</span>: <span class=\"variable\">$line</span>&quot;</span></span><br><span class=\"line\">count=$[ <span class=\"variable\">$count</span> + 1 ]</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 0&lt;&amp;6</span><br><span class=\"line\"><span class=\"built_in\">read</span> -p <span class=\"string\">&quot;Are you done now? &quot;</span> answer</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"variable\">$answer</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">Y|y) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Goodbye&quot;</span>;;</span><br><span class=\"line\">N|n) <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Sorry, this is the end.&quot;</span>;;</span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"组织命令输出\"><a href=\"#组织命令输出\" class=\"headerlink\" title=\"组织命令输出\"></a>组织命令输出</h2><p>有时候，可能不想显示脚本的输出。这在将脚本作为后台进程运行时很常见。可以将STDERR重定向到一个叫作null文件的特殊&#x2F;文件。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。在Linux系统上null文件的标准位置是&#x2F;dev&#x2F;null。你重定向到该位置的任何数据都会被丢掉，不会显示。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ <span class=\"built_in\">ls</span> -al &gt; /dev/null</span><br><span class=\"line\">ubuntu@sh:~$</span><br><span class=\"line\">ubuntu@sh:~$ <span class=\"built_in\">ls</span> -al badfile 2&gt; /dev/null</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>"},{"title":"Shell函数","date":"2023-04-18T03:31:23.000Z","_content":"\n编写shell脚本时，经常需要在多个地方使用了同一段代码。如果只是一小段代码，一般也无关紧要。但要在shell脚本中多次重写大块代码段就太累人了。bash shell提供的用户自定义函数功能可以解决这个问题。可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用。\n\n函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块时，只要使用所起的函数名就行了（这个过程称为调用函数）。\n\n## 基本脚本函数\n\n### 创建函数、调用函数\n\n1. 第一种方式采用function关键字，后面跟函数名以及代码块\n    \n    ```\n    function 函数名 {\n        函数体\n    }\n    ```\n    \n    name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。\n    \n2. 第二种方式更接近其他编程语言的定义方式\n    \n    ```\n    函数名() {\n        函数体\n    }\n    ```\n    \n\n```bash\n#!/bin/bash\n\ngreet\nfunction greet {\n    echo \"Hello, World!\"\n}\ngreet\n\n```\n\n- 当函数在被定义之前使用的话会产生错误信息\n\n```bash\n#!/bin/bash\n# using a function located in the middle of a script\ncount=1\necho \"This line comes before the function definition\"\nfunction func1 {\necho \"This is an exam,rple of a function\"\n}\nwhile [ $count -le 5 ]\ndo\nfunc1\ncount=$[ $count + 1 ]\ndone\necho \"This is the end of the loop\"\nfunc2\necho \"Now this is the end of the script\"\nfunction func2 {\necho \"This is an example of a function\"\n}\n```\n\n## 返回值\n\n`bash shell`会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成`退出状态码`。\n\n### 默认退出状态码\n\n默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量`$?`来确定函数的退出状态码。\n\n```bash\n#!/bin/bash\n\nfunction greet {\n\t\t# ls -l badfile\n    echo \"Hello, World!\"\n\t\tls -l badfile\n}\n\ngreet\necho \"the exit status is: $?\"\n```\n\n如果注释掉第一个`ls`命令，由于函数的最后一条语句`echo`运行成功，该函数的退出状态是`0`，尽管前一个命令没有运行成功。\n\n### 使用return命令\n\n`bash shell`使用`return`命令来退出函数并返回特定的退出状态码。`return`命令允许指定一个整数值来定义函数的`退出状态码`\n\n```bash\n#!/bin/bash\n# using the return command in a function\nfunction dbl {\nread -p \"Enter a value: \" value\necho \"doubling the value\"\nreturn $[ $value * 2 ]\n}\ndbl\necho \"The new value is $?\"\n```\n\n`dbl`函数会将`$value`变量中用户输入的值翻倍，然后用`return`命令返回结果。脚本用`$?`变量显示了该值。当使用该方法从函数中获取返回值时有两个要点：\n\n1. 函数一结束就取返回值\n2. 退出状态码必须是0~255\n\n如果在用`$?`变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，`$?`变量会返回执行的最后一条命令的退出状态码。\n第二个问题界定了返回值的取值范围。由于退出状态码必须`小于256`，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值。\n\n```\nubuntu@sh:~$ bash test.sh\nEnter a value: 200\ndoubling the value\nThe new value is 144\n```\n\n### 使用函数输出\n\n正如可以将命令的输出保存到shell变量中一样，也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中：\n\n```\nresult=`dbl`\n```\n\n这个命令会将`dbl`函数的输出赋给`$result`变量。\n\n```bash\n#!/bin/bash\n# using the echo to return a value\nfunction dbl {\nread -p \"Enter a value: \" value\necho $[ $value * 2 ]\n}\nresult=`dbl`\necho \"The new value is $result\"\n```\n\n```\nubuntu@sh:~$ bash test.sh\nEnter a value: 200\nvalue = 400\nubuntu@sh:~$\n```\n\n## 函数中使用变量\n\n### 向函数传递参数\n\nbash shell会将函数当作小型脚本来对待。这意味着可以像普通脚本那样向函数传递参数。\n\n函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在`$0`变量中定义，函数命令行上的任何参数都会通过`$1`、`$2`等定义。也可以用特殊变量`$#`来判断传给函数的参数数目。\n\n```bash\n#!/bin/bash\n\n# 定义一个函数，接收两个参数并输出它们\nfunction print_two_args {\n    echo \"第一个参数是：$1\"\n    echo \"第二个参数是：$2\"\n}\n\n# 调用函数，并传递两个参数\nprint_two_args \"hello\" \"world\"\n```\n\n```\n第一个参数是：hello\n第二个参数是：world\n```\n\n### 在函数中处理变量\n\n作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同。也就是说，对脚本的其他部分而言，它们是隐藏的。\n\n### 全局变量\n\n对于全局变量，可以直接在函数中使用或修改。例如：\n\n```bash\n#!/bin/bash\n\n# 定义全局变量\nname=\"Tom\"\n\n# 定义函数\nmy_func() {\n  echo \"Hello, $name\"\n  name=\"Jerry\"\n}\n\n# 调用函数\nmy_func\necho \"Name is $name\" # 输出 \"Name is Jerry\"\n```\n\n### 局部变量\n\n```bash\n#!/bin/bash\n\n# 定义函数\nmy_func() {\n  # 定义局部变量\n  local count=0\n\n  # 修改局部变量\n  count=$[ $count + 1 ]\n\n  # 输出局部变量\n  echo \"Count is $count\"\n}\n\n# 调用函数\nmy_func # 输出 \"Count is 1\"\n\n```\n\n需要注意的是，在函数中使用局部变量时，变量名前必须加上 **`local`**关键字，否则会被认为是全局变量。如果函数中定义了一个与全局变量同名的局部变量，则在函数中访问该变量时，会优先使用局部变量。\n\n```bash\n#!/bin/bash\n# 在函数中使用局部变量不会影响到脚本主体中的全局变量的值\nfunction func1 {\nlocal temp=$[ $value + 5 ]\nresult=$[ $temp * 2 ]\n}\ntemp=4\nvalue=6\nfunc1\necho \"The result is $result\"\nif [ $temp -gt $value ]\nthen\necho \"temp is larger\"\nelse\necho \"temp is smaller\"\nfi\n```\n\n## 在命令行上使用函数\n\n可以用脚本函数来执行一些十分复杂的操作。有时也很有必要在命令行界面的提示符下直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在`PATH`环境变量里。重点在于让shell能够识别这些函数。\n\n### 在命令行上创建函数\n\n- 单行方式定义函数\n\n```bash\nubuntu@sh:~$ function addem { echo $[ $1 + $2 ]; }\nubuntu@sh:~$ addem 1 2\n3\n```\n\n- 多行方式定义函数\n\n```bash\nubuntu@sh:~$ function multem {\n> echo $[ $1 * $2 ]\n> }\nubuntu@sh:~$ multem 2 4\n8\nubuntu@sh:~$\n```\n\n在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。\n\n### 在.bashrc文件中定义函数\n\n在命令行上直接定义`shell`函数的明显缺点是退出`shell`时，函数就消失了，这对于一些复杂函数并不适用。此时可以将函数写入一个特定位置并且在`shell`启动时由`shell`重新载入。`.bashrc`文件会在每次`shell`启动时在主目录下被查找并调用，因此可以在主目录下的.`bashrc`文件中定义函数。\n\n将以下内容写入到`.bashrc`文件的末尾：\n\n```\nfunction addem {\necho $[ $1 + $2 ]\n}\n```\n\n## 创建库\n\n通过创建函数库文件可以方便在多个脚本中使用同一段代码。以下代码保存在myfuncs文件中：\n\n```bash\nfunction addem {\necho $[ $1 + $2 ]\n}\nfunction multem {\necho $[ $1 * $2 ]\n}\nfunction divem {\nif [ $2 -ne 0 ]\nthen\necho $[ $1 / $2 ]\nelse\necho -1\nfi\n}\n```\n\n在另一个脚本中执行`myfuncs`\n\n```bash\n#!/bin/bash\n# using a library file the wrong way\n./myfuncs\nresult=$(adem 10 15)\necho \"The result is $result\"\n```\n\n输出信息\n\n```\naddem: command not found\nThe result is\n```\n\n使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。\n\n```bash\n#!/bin/bash\n# using functions defined in a library file\n. ./myfuncs\nvalue1=10\nvalue2=5\nresult1=$(addem $value1 $value2)\nresult2=$(multem $value1 $value2)\nresult3=$(divem $value1 $value2)\necho \"The result of adding them is: $result1\"\necho \"The result of multiplying them is: $result2\"\necho \"The result of dividing them is: $result3\"\n```\n\n## 通过函数体实现加减运算\n\n```bash\nfunction calculate {\n\n    case $op in\n        \"+\")\n            result=\n            ;;\n        \"-\")\n            result=\n            ;;\n        *)\n            echo \"Error: unsupported operator.\"\n            return 1\n            ;;\n    esac\n    echo \"Result: $result\"\n    return 0\n}\n```","source":"_posts/linux_shell/7.Shell函数.md","raw":"---\ntitle: Shell函数\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n编写shell脚本时，经常需要在多个地方使用了同一段代码。如果只是一小段代码，一般也无关紧要。但要在shell脚本中多次重写大块代码段就太累人了。bash shell提供的用户自定义函数功能可以解决这个问题。可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用。\n\n函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块时，只要使用所起的函数名就行了（这个过程称为调用函数）。\n\n## 基本脚本函数\n\n### 创建函数、调用函数\n\n1. 第一种方式采用function关键字，后面跟函数名以及代码块\n    \n    ```\n    function 函数名 {\n        函数体\n    }\n    ```\n    \n    name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。\n    \n2. 第二种方式更接近其他编程语言的定义方式\n    \n    ```\n    函数名() {\n        函数体\n    }\n    ```\n    \n\n```bash\n#!/bin/bash\n\ngreet\nfunction greet {\n    echo \"Hello, World!\"\n}\ngreet\n\n```\n\n- 当函数在被定义之前使用的话会产生错误信息\n\n```bash\n#!/bin/bash\n# using a function located in the middle of a script\ncount=1\necho \"This line comes before the function definition\"\nfunction func1 {\necho \"This is an exam,rple of a function\"\n}\nwhile [ $count -le 5 ]\ndo\nfunc1\ncount=$[ $count + 1 ]\ndone\necho \"This is the end of the loop\"\nfunc2\necho \"Now this is the end of the script\"\nfunction func2 {\necho \"This is an example of a function\"\n}\n```\n\n## 返回值\n\n`bash shell`会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成`退出状态码`。\n\n### 默认退出状态码\n\n默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量`$?`来确定函数的退出状态码。\n\n```bash\n#!/bin/bash\n\nfunction greet {\n\t\t# ls -l badfile\n    echo \"Hello, World!\"\n\t\tls -l badfile\n}\n\ngreet\necho \"the exit status is: $?\"\n```\n\n如果注释掉第一个`ls`命令，由于函数的最后一条语句`echo`运行成功，该函数的退出状态是`0`，尽管前一个命令没有运行成功。\n\n### 使用return命令\n\n`bash shell`使用`return`命令来退出函数并返回特定的退出状态码。`return`命令允许指定一个整数值来定义函数的`退出状态码`\n\n```bash\n#!/bin/bash\n# using the return command in a function\nfunction dbl {\nread -p \"Enter a value: \" value\necho \"doubling the value\"\nreturn $[ $value * 2 ]\n}\ndbl\necho \"The new value is $?\"\n```\n\n`dbl`函数会将`$value`变量中用户输入的值翻倍，然后用`return`命令返回结果。脚本用`$?`变量显示了该值。当使用该方法从函数中获取返回值时有两个要点：\n\n1. 函数一结束就取返回值\n2. 退出状态码必须是0~255\n\n如果在用`$?`变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，`$?`变量会返回执行的最后一条命令的退出状态码。\n第二个问题界定了返回值的取值范围。由于退出状态码必须`小于256`，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值。\n\n```\nubuntu@sh:~$ bash test.sh\nEnter a value: 200\ndoubling the value\nThe new value is 144\n```\n\n### 使用函数输出\n\n正如可以将命令的输出保存到shell变量中一样，也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中：\n\n```\nresult=`dbl`\n```\n\n这个命令会将`dbl`函数的输出赋给`$result`变量。\n\n```bash\n#!/bin/bash\n# using the echo to return a value\nfunction dbl {\nread -p \"Enter a value: \" value\necho $[ $value * 2 ]\n}\nresult=`dbl`\necho \"The new value is $result\"\n```\n\n```\nubuntu@sh:~$ bash test.sh\nEnter a value: 200\nvalue = 400\nubuntu@sh:~$\n```\n\n## 函数中使用变量\n\n### 向函数传递参数\n\nbash shell会将函数当作小型脚本来对待。这意味着可以像普通脚本那样向函数传递参数。\n\n函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在`$0`变量中定义，函数命令行上的任何参数都会通过`$1`、`$2`等定义。也可以用特殊变量`$#`来判断传给函数的参数数目。\n\n```bash\n#!/bin/bash\n\n# 定义一个函数，接收两个参数并输出它们\nfunction print_two_args {\n    echo \"第一个参数是：$1\"\n    echo \"第二个参数是：$2\"\n}\n\n# 调用函数，并传递两个参数\nprint_two_args \"hello\" \"world\"\n```\n\n```\n第一个参数是：hello\n第二个参数是：world\n```\n\n### 在函数中处理变量\n\n作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同。也就是说，对脚本的其他部分而言，它们是隐藏的。\n\n### 全局变量\n\n对于全局变量，可以直接在函数中使用或修改。例如：\n\n```bash\n#!/bin/bash\n\n# 定义全局变量\nname=\"Tom\"\n\n# 定义函数\nmy_func() {\n  echo \"Hello, $name\"\n  name=\"Jerry\"\n}\n\n# 调用函数\nmy_func\necho \"Name is $name\" # 输出 \"Name is Jerry\"\n```\n\n### 局部变量\n\n```bash\n#!/bin/bash\n\n# 定义函数\nmy_func() {\n  # 定义局部变量\n  local count=0\n\n  # 修改局部变量\n  count=$[ $count + 1 ]\n\n  # 输出局部变量\n  echo \"Count is $count\"\n}\n\n# 调用函数\nmy_func # 输出 \"Count is 1\"\n\n```\n\n需要注意的是，在函数中使用局部变量时，变量名前必须加上 **`local`**关键字，否则会被认为是全局变量。如果函数中定义了一个与全局变量同名的局部变量，则在函数中访问该变量时，会优先使用局部变量。\n\n```bash\n#!/bin/bash\n# 在函数中使用局部变量不会影响到脚本主体中的全局变量的值\nfunction func1 {\nlocal temp=$[ $value + 5 ]\nresult=$[ $temp * 2 ]\n}\ntemp=4\nvalue=6\nfunc1\necho \"The result is $result\"\nif [ $temp -gt $value ]\nthen\necho \"temp is larger\"\nelse\necho \"temp is smaller\"\nfi\n```\n\n## 在命令行上使用函数\n\n可以用脚本函数来执行一些十分复杂的操作。有时也很有必要在命令行界面的提示符下直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在`PATH`环境变量里。重点在于让shell能够识别这些函数。\n\n### 在命令行上创建函数\n\n- 单行方式定义函数\n\n```bash\nubuntu@sh:~$ function addem { echo $[ $1 + $2 ]; }\nubuntu@sh:~$ addem 1 2\n3\n```\n\n- 多行方式定义函数\n\n```bash\nubuntu@sh:~$ function multem {\n> echo $[ $1 * $2 ]\n> }\nubuntu@sh:~$ multem 2 4\n8\nubuntu@sh:~$\n```\n\n在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。\n\n### 在.bashrc文件中定义函数\n\n在命令行上直接定义`shell`函数的明显缺点是退出`shell`时，函数就消失了，这对于一些复杂函数并不适用。此时可以将函数写入一个特定位置并且在`shell`启动时由`shell`重新载入。`.bashrc`文件会在每次`shell`启动时在主目录下被查找并调用，因此可以在主目录下的.`bashrc`文件中定义函数。\n\n将以下内容写入到`.bashrc`文件的末尾：\n\n```\nfunction addem {\necho $[ $1 + $2 ]\n}\n```\n\n## 创建库\n\n通过创建函数库文件可以方便在多个脚本中使用同一段代码。以下代码保存在myfuncs文件中：\n\n```bash\nfunction addem {\necho $[ $1 + $2 ]\n}\nfunction multem {\necho $[ $1 * $2 ]\n}\nfunction divem {\nif [ $2 -ne 0 ]\nthen\necho $[ $1 / $2 ]\nelse\necho -1\nfi\n}\n```\n\n在另一个脚本中执行`myfuncs`\n\n```bash\n#!/bin/bash\n# using a library file the wrong way\n./myfuncs\nresult=$(adem 10 15)\necho \"The result is $result\"\n```\n\n输出信息\n\n```\naddem: command not found\nThe result is\n```\n\n使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。\n\n```bash\n#!/bin/bash\n# using functions defined in a library file\n. ./myfuncs\nvalue1=10\nvalue2=5\nresult1=$(addem $value1 $value2)\nresult2=$(multem $value1 $value2)\nresult3=$(divem $value1 $value2)\necho \"The result of adding them is: $result1\"\necho \"The result of multiplying them is: $result2\"\necho \"The result of dividing them is: $result3\"\n```\n\n## 通过函数体实现加减运算\n\n```bash\nfunction calculate {\n\n    case $op in\n        \"+\")\n            result=\n            ;;\n        \"-\")\n            result=\n            ;;\n        *)\n            echo \"Error: unsupported operator.\"\n            return 1\n            ;;\n    esac\n    echo \"Result: $result\"\n    return 0\n}\n```","slug":"linux_shell/7.Shell函数","published":1,"updated":"2023-06-10T08:09:30.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cliuf72wg0008j1nz1e7e0wpt","content":"<p>编写shell脚本时，经常需要在多个地方使用了同一段代码。如果只是一小段代码，一般也无关紧要。但要在shell脚本中多次重写大块代码段就太累人了。bash shell提供的用户自定义函数功能可以解决这个问题。可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用。</p>\n<p>函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块时，只要使用所起的函数名就行了（这个过程称为调用函数）。</p>\n<h2 id=\"基本脚本函数\"><a href=\"#基本脚本函数\" class=\"headerlink\" title=\"基本脚本函数\"></a>基本脚本函数</h2><h3 id=\"创建函数、调用函数\"><a href=\"#创建函数、调用函数\" class=\"headerlink\" title=\"创建函数、调用函数\"></a>创建函数、调用函数</h3><ol>\n<li><p>第一种方式采用function关键字，后面跟函数名以及代码块</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function 函数名 &#123;</span><br><span class=\"line\">    函数体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。</p>\n</li>\n<li><p>第二种方式更接近其他编程语言的定义方式</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数名() &#123;</span><br><span class=\"line\">    函数体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet</span><br><span class=\"line\"><span class=\"keyword\">function</span> greet &#123;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello, World!&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当函数在被定义之前使用的话会产生错误信息</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># using a function located in the middle of a script</span></span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This line comes before the function definition&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> func1 &#123;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This is an exam,rple of a function&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$count</span> -le 5 ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">func1</span><br><span class=\"line\">count=$[ <span class=\"variable\">$count</span> + 1 ]</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This is the end of the loop&quot;</span></span><br><span class=\"line\">func2</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Now this is the end of the script&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> func2 &#123;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This is an example of a function&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p><code>bash shell</code>会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成<code>退出状态码</code>。</p>\n<h3 id=\"默认退出状态码\"><a href=\"#默认退出状态码\" class=\"headerlink\" title=\"默认退出状态码\"></a>默认退出状态码</h3><p>默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量<code>$?</code>来确定函数的退出状态码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> greet &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\"># ls -l badfile</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello, World!&quot;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">ls</span> -l badfile</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">greet</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;the exit status is: $?&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果注释掉第一个<code>ls</code>命令，由于函数的最后一条语句<code>echo</code>运行成功，该函数的退出状态是<code>0</code>，尽管前一个命令没有运行成功。</p>\n<h3 id=\"使用return命令\"><a href=\"#使用return命令\" class=\"headerlink\" title=\"使用return命令\"></a>使用return命令</h3><p><code>bash shell</code>使用<code>return</code>命令来退出函数并返回特定的退出状态码。<code>return</code>命令允许指定一个整数值来定义函数的<code>退出状态码</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># using the return command in a function</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> dbl &#123;</span><br><span class=\"line\"><span class=\"built_in\">read</span> -p <span class=\"string\">&quot;Enter a value: &quot;</span> value</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;doubling the value&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">return</span> $[ <span class=\"variable\">$value</span> * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dbl</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The new value is $?&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>dbl</code>函数会将<code>$value</code>变量中用户输入的值翻倍，然后用<code>return</code>命令返回结果。脚本用<code>$?</code>变量显示了该值。当使用该方法从函数中获取返回值时有两个要点：</p>\n<ol>\n<li>函数一结束就取返回值</li>\n<li>退出状态码必须是0~255</li>\n</ol>\n<p>如果在用<code>$?</code>变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，<code>$?</code>变量会返回执行的最后一条命令的退出状态码。<br>第二个问题界定了返回值的取值范围。由于退出状态码必须<code>小于256</code>，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ bash test.sh</span><br><span class=\"line\">Enter a value: 200</span><br><span class=\"line\">doubling the value</span><br><span class=\"line\">The new value is 144</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用函数输出\"><a href=\"#使用函数输出\" class=\"headerlink\" title=\"使用函数输出\"></a>使用函数输出</h3><p>正如可以将命令的输出保存到shell变量中一样，也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result=`dbl`</span><br></pre></td></tr></table></figure>\n\n<p>这个命令会将<code>dbl</code>函数的输出赋给<code>$result</code>变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># using the echo to return a value</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> dbl &#123;</span><br><span class=\"line\"><span class=\"built_in\">read</span> -p <span class=\"string\">&quot;Enter a value: &quot;</span> value</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $[ <span class=\"variable\">$value</span> * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result=`dbl`</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The new value is <span class=\"variable\">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ bash test.sh</span><br><span class=\"line\">Enter a value: 200</span><br><span class=\"line\">value = 400</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数中使用变量\"><a href=\"#函数中使用变量\" class=\"headerlink\" title=\"函数中使用变量\"></a>函数中使用变量</h2><h3 id=\"向函数传递参数\"><a href=\"#向函数传递参数\" class=\"headerlink\" title=\"向函数传递参数\"></a>向函数传递参数</h3><p>bash shell会将函数当作小型脚本来对待。这意味着可以像普通脚本那样向函数传递参数。</p>\n<p>函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在<code>$0</code>变量中定义，函数命令行上的任何参数都会通过<code>$1</code>、<code>$2</code>等定义。也可以用特殊变量<code>$#</code>来判断传给函数的参数数目。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个函数，接收两个参数并输出它们</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> print_two_args &#123;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;第一个参数是：<span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;第二个参数是：<span class=\"variable\">$2</span>&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用函数，并传递两个参数</span></span><br><span class=\"line\">print_two_args <span class=\"string\">&quot;hello&quot;</span> <span class=\"string\">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一个参数是：hello</span><br><span class=\"line\">第二个参数是：world</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在函数中处理变量\"><a href=\"#在函数中处理变量\" class=\"headerlink\" title=\"在函数中处理变量\"></a>在函数中处理变量</h3><p>作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同。也就是说，对脚本的其他部分而言，它们是隐藏的。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>对于全局变量，可以直接在函数中使用或修改。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义全局变量</span></span><br><span class=\"line\">name=<span class=\"string\">&quot;Tom&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">my_func</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>&quot;</span></span><br><span class=\"line\">  name=<span class=\"string\">&quot;Jerry&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用函数</span></span><br><span class=\"line\">my_func</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Name is <span class=\"variable\">$name</span>&quot;</span> <span class=\"comment\"># 输出 &quot;Name is Jerry&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">my_func</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"comment\"># 定义局部变量</span></span><br><span class=\"line\">  <span class=\"built_in\">local</span> count=0</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 修改局部变量</span></span><br><span class=\"line\">  count=$[ <span class=\"variable\">$count</span> + 1 ]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 输出局部变量</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Count is <span class=\"variable\">$count</span>&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用函数</span></span><br><span class=\"line\">my_func <span class=\"comment\"># 输出 &quot;Count is 1&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，在函数中使用局部变量时，变量名前必须加上 **<code>local</code>**关键字，否则会被认为是全局变量。如果函数中定义了一个与全局变量同名的局部变量，则在函数中访问该变量时，会优先使用局部变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># 在函数中使用局部变量不会影响到脚本主体中的全局变量的值</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> func1 &#123;</span><br><span class=\"line\"><span class=\"built_in\">local</span> temp=$[ <span class=\"variable\">$value</span> + 5 ]</span><br><span class=\"line\">result=$[ <span class=\"variable\">$temp</span> * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">temp=4</span><br><span class=\"line\">value=6</span><br><span class=\"line\">func1</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The result is <span class=\"variable\">$result</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$temp</span> -gt <span class=\"variable\">$value</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;temp is larger&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;temp is smaller&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在命令行上使用函数\"><a href=\"#在命令行上使用函数\" class=\"headerlink\" title=\"在命令行上使用函数\"></a>在命令行上使用函数</h2><p>可以用脚本函数来执行一些十分复杂的操作。有时也很有必要在命令行界面的提示符下直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在<code>PATH</code>环境变量里。重点在于让shell能够识别这些函数。</p>\n<h3 id=\"在命令行上创建函数\"><a href=\"#在命令行上创建函数\" class=\"headerlink\" title=\"在命令行上创建函数\"></a>在命令行上创建函数</h3><ul>\n<li>单行方式定义函数</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ <span class=\"keyword\">function</span> addem &#123; <span class=\"built_in\">echo</span> $[ <span class=\"variable\">$1</span> + <span class=\"variable\">$2</span> ]; &#125;</span><br><span class=\"line\">ubuntu@sh:~$ addem 1 2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>多行方式定义函数</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ <span class=\"keyword\">function</span> multem &#123;</span><br><span class=\"line\">&gt; <span class=\"built_in\">echo</span> $[ <span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> ]</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">ubuntu@sh:~$ multem 2 4</span><br><span class=\"line\">8</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n\n<p>在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。</p>\n<h3 id=\"在-bashrc文件中定义函数\"><a href=\"#在-bashrc文件中定义函数\" class=\"headerlink\" title=\"在.bashrc文件中定义函数\"></a>在.bashrc文件中定义函数</h3><p>在命令行上直接定义<code>shell</code>函数的明显缺点是退出<code>shell</code>时，函数就消失了，这对于一些复杂函数并不适用。此时可以将函数写入一个特定位置并且在<code>shell</code>启动时由<code>shell</code>重新载入。<code>.bashrc</code>文件会在每次<code>shell</code>启动时在主目录下被查找并调用，因此可以在主目录下的.<code>bashrc</code>文件中定义函数。</p>\n<p>将以下内容写入到<code>.bashrc</code>文件的末尾：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addem &#123;</span><br><span class=\"line\">echo $[ $1 + $2 ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建库\"><a href=\"#创建库\" class=\"headerlink\" title=\"创建库\"></a>创建库</h2><p>通过创建函数库文件可以方便在多个脚本中使用同一段代码。以下代码保存在myfuncs文件中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> addem &#123;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $[ <span class=\"variable\">$1</span> + <span class=\"variable\">$2</span> ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> multem &#123;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $[ <span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> divem &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$2</span> -ne 0 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> $[ <span class=\"variable\">$1</span> / <span class=\"variable\">$2</span> ]</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在另一个脚本中执行<code>myfuncs</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># using a library file the wrong way</span></span><br><span class=\"line\">./myfuncs</span><br><span class=\"line\">result=$(adem 10 15)</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The result is <span class=\"variable\">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addem: command not found</span><br><span class=\"line\">The result is</span><br></pre></td></tr></table></figure>\n\n<p>使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># using functions defined in a library file</span></span><br><span class=\"line\">. ./myfuncs</span><br><span class=\"line\">value1=10</span><br><span class=\"line\">value2=5</span><br><span class=\"line\">result1=$(addem <span class=\"variable\">$value1</span> <span class=\"variable\">$value2</span>)</span><br><span class=\"line\">result2=$(multem <span class=\"variable\">$value1</span> <span class=\"variable\">$value2</span>)</span><br><span class=\"line\">result3=$(divem <span class=\"variable\">$value1</span> <span class=\"variable\">$value2</span>)</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The result of adding them is: <span class=\"variable\">$result1</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The result of multiplying them is: <span class=\"variable\">$result2</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The result of dividing them is: <span class=\"variable\">$result3</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"通过函数体实现加减运算\"><a href=\"#通过函数体实现加减运算\" class=\"headerlink\" title=\"通过函数体实现加减运算\"></a>通过函数体实现加减运算</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> calculate &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"variable\">$op</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"string\">&quot;+&quot;</span>)</span><br><span class=\"line\">            result=</span><br><span class=\"line\">            ;;</span><br><span class=\"line\">        <span class=\"string\">&quot;-&quot;</span>)</span><br><span class=\"line\">            result=</span><br><span class=\"line\">            ;;</span><br><span class=\"line\">        *)</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Error: unsupported operator.&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> 1</span><br><span class=\"line\">            ;;</span><br><span class=\"line\">    <span class=\"keyword\">esac</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Result: <span class=\"variable\">$result</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>编写shell脚本时，经常需要在多个地方使用了同一段代码。如果只是一小段代码，一般也无关紧要。但要在shell脚本中多次重写大块代码段就太累人了。bash shell提供的用户自定义函数功能可以解决这个问题。可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用。</p>\n<p>函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块时，只要使用所起的函数名就行了（这个过程称为调用函数）。</p>\n<h2 id=\"基本脚本函数\"><a href=\"#基本脚本函数\" class=\"headerlink\" title=\"基本脚本函数\"></a>基本脚本函数</h2><h3 id=\"创建函数、调用函数\"><a href=\"#创建函数、调用函数\" class=\"headerlink\" title=\"创建函数、调用函数\"></a>创建函数、调用函数</h3><ol>\n<li><p>第一种方式采用function关键字，后面跟函数名以及代码块</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function 函数名 &#123;</span><br><span class=\"line\">    函数体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。</p>\n</li>\n<li><p>第二种方式更接近其他编程语言的定义方式</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数名() &#123;</span><br><span class=\"line\">    函数体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet</span><br><span class=\"line\"><span class=\"keyword\">function</span> greet &#123;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello, World!&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当函数在被定义之前使用的话会产生错误信息</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># using a function located in the middle of a script</span></span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This line comes before the function definition&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> func1 &#123;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This is an exam,rple of a function&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$count</span> -le 5 ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">func1</span><br><span class=\"line\">count=$[ <span class=\"variable\">$count</span> + 1 ]</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This is the end of the loop&quot;</span></span><br><span class=\"line\">func2</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Now this is the end of the script&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> func2 &#123;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;This is an example of a function&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p><code>bash shell</code>会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成<code>退出状态码</code>。</p>\n<h3 id=\"默认退出状态码\"><a href=\"#默认退出状态码\" class=\"headerlink\" title=\"默认退出状态码\"></a>默认退出状态码</h3><p>默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量<code>$?</code>来确定函数的退出状态码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> greet &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\"># ls -l badfile</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello, World!&quot;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">ls</span> -l badfile</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">greet</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;the exit status is: $?&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果注释掉第一个<code>ls</code>命令，由于函数的最后一条语句<code>echo</code>运行成功，该函数的退出状态是<code>0</code>，尽管前一个命令没有运行成功。</p>\n<h3 id=\"使用return命令\"><a href=\"#使用return命令\" class=\"headerlink\" title=\"使用return命令\"></a>使用return命令</h3><p><code>bash shell</code>使用<code>return</code>命令来退出函数并返回特定的退出状态码。<code>return</code>命令允许指定一个整数值来定义函数的<code>退出状态码</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># using the return command in a function</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> dbl &#123;</span><br><span class=\"line\"><span class=\"built_in\">read</span> -p <span class=\"string\">&quot;Enter a value: &quot;</span> value</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;doubling the value&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">return</span> $[ <span class=\"variable\">$value</span> * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dbl</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The new value is $?&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>dbl</code>函数会将<code>$value</code>变量中用户输入的值翻倍，然后用<code>return</code>命令返回结果。脚本用<code>$?</code>变量显示了该值。当使用该方法从函数中获取返回值时有两个要点：</p>\n<ol>\n<li>函数一结束就取返回值</li>\n<li>退出状态码必须是0~255</li>\n</ol>\n<p>如果在用<code>$?</code>变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，<code>$?</code>变量会返回执行的最后一条命令的退出状态码。<br>第二个问题界定了返回值的取值范围。由于退出状态码必须<code>小于256</code>，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ bash test.sh</span><br><span class=\"line\">Enter a value: 200</span><br><span class=\"line\">doubling the value</span><br><span class=\"line\">The new value is 144</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用函数输出\"><a href=\"#使用函数输出\" class=\"headerlink\" title=\"使用函数输出\"></a>使用函数输出</h3><p>正如可以将命令的输出保存到shell变量中一样，也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result=`dbl`</span><br></pre></td></tr></table></figure>\n\n<p>这个命令会将<code>dbl</code>函数的输出赋给<code>$result</code>变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># using the echo to return a value</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> dbl &#123;</span><br><span class=\"line\"><span class=\"built_in\">read</span> -p <span class=\"string\">&quot;Enter a value: &quot;</span> value</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $[ <span class=\"variable\">$value</span> * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result=`dbl`</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The new value is <span class=\"variable\">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ bash test.sh</span><br><span class=\"line\">Enter a value: 200</span><br><span class=\"line\">value = 400</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数中使用变量\"><a href=\"#函数中使用变量\" class=\"headerlink\" title=\"函数中使用变量\"></a>函数中使用变量</h2><h3 id=\"向函数传递参数\"><a href=\"#向函数传递参数\" class=\"headerlink\" title=\"向函数传递参数\"></a>向函数传递参数</h3><p>bash shell会将函数当作小型脚本来对待。这意味着可以像普通脚本那样向函数传递参数。</p>\n<p>函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在<code>$0</code>变量中定义，函数命令行上的任何参数都会通过<code>$1</code>、<code>$2</code>等定义。也可以用特殊变量<code>$#</code>来判断传给函数的参数数目。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个函数，接收两个参数并输出它们</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> print_two_args &#123;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;第一个参数是：<span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;第二个参数是：<span class=\"variable\">$2</span>&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用函数，并传递两个参数</span></span><br><span class=\"line\">print_two_args <span class=\"string\">&quot;hello&quot;</span> <span class=\"string\">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一个参数是：hello</span><br><span class=\"line\">第二个参数是：world</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在函数中处理变量\"><a href=\"#在函数中处理变量\" class=\"headerlink\" title=\"在函数中处理变量\"></a>在函数中处理变量</h3><p>作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同。也就是说，对脚本的其他部分而言，它们是隐藏的。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>对于全局变量，可以直接在函数中使用或修改。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义全局变量</span></span><br><span class=\"line\">name=<span class=\"string\">&quot;Tom&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">my_func</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello, <span class=\"variable\">$name</span>&quot;</span></span><br><span class=\"line\">  name=<span class=\"string\">&quot;Jerry&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用函数</span></span><br><span class=\"line\">my_func</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Name is <span class=\"variable\">$name</span>&quot;</span> <span class=\"comment\"># 输出 &quot;Name is Jerry&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">my_func</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"comment\"># 定义局部变量</span></span><br><span class=\"line\">  <span class=\"built_in\">local</span> count=0</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 修改局部变量</span></span><br><span class=\"line\">  count=$[ <span class=\"variable\">$count</span> + 1 ]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 输出局部变量</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Count is <span class=\"variable\">$count</span>&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用函数</span></span><br><span class=\"line\">my_func <span class=\"comment\"># 输出 &quot;Count is 1&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，在函数中使用局部变量时，变量名前必须加上 **<code>local</code>**关键字，否则会被认为是全局变量。如果函数中定义了一个与全局变量同名的局部变量，则在函数中访问该变量时，会优先使用局部变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># 在函数中使用局部变量不会影响到脚本主体中的全局变量的值</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> func1 &#123;</span><br><span class=\"line\"><span class=\"built_in\">local</span> temp=$[ <span class=\"variable\">$value</span> + 5 ]</span><br><span class=\"line\">result=$[ <span class=\"variable\">$temp</span> * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">temp=4</span><br><span class=\"line\">value=6</span><br><span class=\"line\">func1</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The result is <span class=\"variable\">$result</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$temp</span> -gt <span class=\"variable\">$value</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;temp is larger&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;temp is smaller&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在命令行上使用函数\"><a href=\"#在命令行上使用函数\" class=\"headerlink\" title=\"在命令行上使用函数\"></a>在命令行上使用函数</h2><p>可以用脚本函数来执行一些十分复杂的操作。有时也很有必要在命令行界面的提示符下直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在<code>PATH</code>环境变量里。重点在于让shell能够识别这些函数。</p>\n<h3 id=\"在命令行上创建函数\"><a href=\"#在命令行上创建函数\" class=\"headerlink\" title=\"在命令行上创建函数\"></a>在命令行上创建函数</h3><ul>\n<li>单行方式定义函数</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ <span class=\"keyword\">function</span> addem &#123; <span class=\"built_in\">echo</span> $[ <span class=\"variable\">$1</span> + <span class=\"variable\">$2</span> ]; &#125;</span><br><span class=\"line\">ubuntu@sh:~$ addem 1 2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>多行方式定义函数</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ <span class=\"keyword\">function</span> multem &#123;</span><br><span class=\"line\">&gt; <span class=\"built_in\">echo</span> $[ <span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> ]</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">ubuntu@sh:~$ multem 2 4</span><br><span class=\"line\">8</span><br><span class=\"line\">ubuntu@sh:~$</span><br></pre></td></tr></table></figure>\n\n<p>在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。</p>\n<h3 id=\"在-bashrc文件中定义函数\"><a href=\"#在-bashrc文件中定义函数\" class=\"headerlink\" title=\"在.bashrc文件中定义函数\"></a>在.bashrc文件中定义函数</h3><p>在命令行上直接定义<code>shell</code>函数的明显缺点是退出<code>shell</code>时，函数就消失了，这对于一些复杂函数并不适用。此时可以将函数写入一个特定位置并且在<code>shell</code>启动时由<code>shell</code>重新载入。<code>.bashrc</code>文件会在每次<code>shell</code>启动时在主目录下被查找并调用，因此可以在主目录下的.<code>bashrc</code>文件中定义函数。</p>\n<p>将以下内容写入到<code>.bashrc</code>文件的末尾：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addem &#123;</span><br><span class=\"line\">echo $[ $1 + $2 ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建库\"><a href=\"#创建库\" class=\"headerlink\" title=\"创建库\"></a>创建库</h2><p>通过创建函数库文件可以方便在多个脚本中使用同一段代码。以下代码保存在myfuncs文件中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> addem &#123;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $[ <span class=\"variable\">$1</span> + <span class=\"variable\">$2</span> ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> multem &#123;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $[ <span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> divem &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$2</span> -ne 0 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> $[ <span class=\"variable\">$1</span> / <span class=\"variable\">$2</span> ]</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在另一个脚本中执行<code>myfuncs</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># using a library file the wrong way</span></span><br><span class=\"line\">./myfuncs</span><br><span class=\"line\">result=$(adem 10 15)</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The result is <span class=\"variable\">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addem: command not found</span><br><span class=\"line\">The result is</span><br></pre></td></tr></table></figure>\n\n<p>使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># using functions defined in a library file</span></span><br><span class=\"line\">. ./myfuncs</span><br><span class=\"line\">value1=10</span><br><span class=\"line\">value2=5</span><br><span class=\"line\">result1=$(addem <span class=\"variable\">$value1</span> <span class=\"variable\">$value2</span>)</span><br><span class=\"line\">result2=$(multem <span class=\"variable\">$value1</span> <span class=\"variable\">$value2</span>)</span><br><span class=\"line\">result3=$(divem <span class=\"variable\">$value1</span> <span class=\"variable\">$value2</span>)</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The result of adding them is: <span class=\"variable\">$result1</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The result of multiplying them is: <span class=\"variable\">$result2</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;The result of dividing them is: <span class=\"variable\">$result3</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"通过函数体实现加减运算\"><a href=\"#通过函数体实现加减运算\" class=\"headerlink\" title=\"通过函数体实现加减运算\"></a>通过函数体实现加减运算</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> calculate &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"variable\">$op</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"string\">&quot;+&quot;</span>)</span><br><span class=\"line\">            result=</span><br><span class=\"line\">            ;;</span><br><span class=\"line\">        <span class=\"string\">&quot;-&quot;</span>)</span><br><span class=\"line\">            result=</span><br><span class=\"line\">            ;;</span><br><span class=\"line\">        *)</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Error: unsupported operator.&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> 1</span><br><span class=\"line\">            ;;</span><br><span class=\"line\">    <span class=\"keyword\">esac</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Result: <span class=\"variable\">$result</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"正则表达式","date":"2023-04-18T03:31:23.000Z","_content":"\n正则表达式定义：由一系列特定字符组成的字符串，用来匹配目标文本中符合指定条件的字符或者字符串。\n\n在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。**正则表达式**\n就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n\n![Untitled](Untitled%2041.png)\n\n如果你想查找某个目录下的所有的Word文档的话，你会搜索`*.doc`。在这里，`*`会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像*010-12345678*或*0376-7654321*)。\n\n## 入门\n\n正则表达式练习平台：[https://tool.oschina.net/regex/](https://tool.oschina.net/regex/)\n\n最简单的正则表达式举例： `hi` ，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是`h`,后一个是`i`。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配*`hi*,*HI*,*Hi*,*hI*`这四种情况中的任意一种。\n\n```bash\nubuntu@sh:~$ echo \"hi,Hi\" |grep -i \"hi\"\nhi,Hi\nubuntu@sh:~$\nubuntu@sh:~$ echo \"hi,Hi,HI,hI\" |grep -i \"hi\"\nhi,Hi,HI,hI\n```\n\n## 元字符\n\n当目标文本中包含很多字符，比如*`him*,*history*,*high*`等等。用hi来查找的话，这里边的*`hi`*也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用`\\bhi\\b`。\\b是正则表达式规定的一个特殊代码（**元字符，metacharacter**），代表着单词的开头或结尾，也就是单词的分界处。\n\n假如要找的是`hi`后面不远处跟着一个`Lucy`，应该用`\\bhi\\b.*\\bLucy\\b`。\n\n这里，`.`是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，`.`*连在一起就意味着任意数量的不包含换行的字符。现在`\\bhi\\b.**\\bLucy\\b`的意思就很明显：先是一个单词`hi`,然后是任意个任意字符(但不能是换行)，最后是`Lucy`这个单词。\n\n```bash\nubuntu@sh:~$ echo \"hi,Hi,HI,hI,Lucy\" |grep -o \"\\bhi\\b.*\\bLucy\\b\"\nhi,Hi,HI,hI,Lucy\n```\n\n`0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d`匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码)。这里的`\\d`是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符。\n\n也可以这样写这个表达式：`0\\d{2}-\\d{8}`。这里`\\d`后面的`{2}({8})`的意思是前面`\\d`必须连续重复匹配`2次(8次)`。\n\n练习1：匹配国际格式的电话号码`+086-185-553-24528` \n\n练习2：匹配国内电话号码`0511-4405222、021-87888822`\n\n- 常用的元字符\n\n| 代码 | 说明 |\n| --- | --- |\n| . | 匹配除换行符以外的任意字符 |\n| \\w | 匹配字母或数字或下划线或汉字 |\n| \\s | 匹配任意的空白符 |\n| \\d | 匹配数字 |\n| \\b | 匹配单词的开始或结束 |\n| ^ | 匹配字符串的开始 |\n| $ | 匹配字符串的结束 |\n\n元字符`^`（和数字6在同一个键位上的符号）和`$`都匹配一个位置，这和`\\b`有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：`^\\d{5,12}$`。\n\n- 常用的限定符\n\n| 代码/语法 | 说明 |\n| --- | --- |\n| * | 重复零次或更多次 |\n| + | 重复一次或更多次 |\n| ? | 重复零次或一次 |\n| {n} | 重复n次 |\n| {n,} | 重复n次或更多次 |\n| {n,m} | 重复n到m次 |\n1. `\\ba\\w*\\b`匹配以字母`a`开头的单词——先是某个单词开始处`(\\b)`，然后是字母`a`,然后是任意数量的字母或数字`(\\w*)`，最后是单词结束处`(\\b)`。\n2. `\\d+`匹配1个或更多连续的数字。这里的`+`是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而`+`则匹配重复1次或更多次。\n3. `\\b\\w{6}\\b` 匹配刚好6个字符的单词。\n\n## 字符转义\n\n如果想查找元字符本身的话，比如查找`.`,或者`*`,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时就得使用`\\`来取消这些字符的特殊意义。因此，应该使用`\\.`和`\\*`。当然，要查找`\\`本身，也得用`\\\\`.\n\n例如：`deerchao\\.cn`匹配`deerchao.cn`，`C:\\\\Windows`匹配`C:\\Windows`。\n\n## 字符类\n\n要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果想匹配没有预定义元字符的字符集合，需要在方括号中列出他们：`[aeiou]`就匹配任何一个英文元音字母，`[.?!]`匹配标点符号(.或?或!)。\n\n练习3：匹配*(010)88886666*，或*022-22334455*，或*02912345678。*\n\n## 分组\n\n想要重复多个字符又该怎么办？可以用小括号来指定**子表达式**(也叫做**分组**)，然后就可以指定这个子表达式的重复次数了。`(\\d{1,3}\\.){3}\\d{1,3}`是一个简单的IP地址匹配表达式。要理解这个表达式，按下列顺序分析它：\n\n1. `\\d{1,3}`匹配1到3位的数字\n2. `(\\d{1,3}\\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个**分组**)重复3次\n3. 最后再加上一个一到三位的数字`(\\d{1,3})`。\n\n它也将匹配*`256.300.888.999`*这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：`((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)`。\n\n理解这个表达式的关键是理解`2[0-4]\\d|25[0-5]|[01]?\\d\\d?`。\n\n## 反义\n\n有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到**反义。**\n\n| 代码/语法 | 说明 |\n| --- | --- |\n| \\W | 匹配任意不是字母，数字，下划线，汉字的字符 |\n| \\S | 匹配任意不是空白符的字符 |\n| \\D | 匹配任意非数字的字符 |\n| \\B | 匹配不是单词开头或结束的位置 |\n| [^x] | 匹配除了x以外的任意字符 |\n| [^aeiou] | 匹配除了aeiou这几个字母以外的任意字符 |\n\n例子：`\\S+`匹配不包含空白符的字符串。\n\n`<a[^>]+>`匹配用尖括号括起来的以a开头的字符串。\n\n## 贪婪与懒惰\n\n当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：`a.*b`，它将会匹配最长的以`a`开始，以`b`结束的字符串。如果用它来搜索*`aabab`*的话，它会匹配整个字符串`aabab`。这被称为**贪婪**匹配。\n\n有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号`?`。这样`.*?`就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。\n\n举例：`a.*?b`匹配最短的，以`a`开始，以`b`结束的字符串。如果把它应用于*`aabab`*的话，它会匹配`aab`（第一到第三个字符）和`ab`（第四到第五个字符）。\n\n| 代码/语法 | 说明 |\n| --- | --- |\n| *? | 重复任意次，但尽可能少重复 |\n| +? | 重复1次或更多次，但尽可能少重复 |\n| ?? | 重复0次或1次，但尽可能少重复 |\n| {n,m}? | 重复n到m次，但尽可能少重复 |\n| {n,}? | 重复n次以上，但尽可能少重复 |\n\n## grep命令\n\n### grep基本用法\n\n`Linux grep (global regular expression)` 命令用于查找文件里符合条件的字符串或正则表达式。\n\ngrep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 **`-`**，则 grep 指令会从标准输入设备读取数据。\n\n- 基于目标文件进行查找\n    \n    ```bash\n    ubuntu@sh:~$ grep \"ubuntu\" /etc/passwd\n    ubuntu:x:1000:1000:ubuntu,,,:/home/ubuntu:/bin/bash\n    ```\n    \n- 基于标准输入进行查找\n    \n    ```bash\n    ubuntu@sh:~$ ps -aux |grep ssh\n    root        864  0.0  0.1  65508  5424 ?        Ss   Mar26   0:00 /usr/sbin/sshd -D\n    root      18851  0.0  0.1  92796  6836 ?        Ss   Apr06   0:00 sshd: ubuntu [priv]\n    ubuntu    18878  0.0  0.0  92796  3988 ?        S    Apr06   0:02 sshd: ubuntu@pts/0\n    ubuntu    23726  0.0  0.0  14220  1028 pts/0    S+   21:08   0:00 grep --color=auto ssh\n    ```\n    \n- 常用选项\n    - `i`：忽略大小写进行匹配。\n    - `v`：反向查找，只打印不匹配的行。\n    - `n`：显示匹配行的行号。\n    - `r`：递归查找子目录中的文件。\n    - `l`：只打印匹配的文件名。\n    - `c`：只打印匹配的行数。\n\n### grep结合正则表达式用法\n\n- 已有文本文件`example.txt`，其中存储了一些人的信息，包括姓名、年龄和职业，每行一个人的信息：\n    \n    ```bash\n    John Smith, 25, Engineer\n    Alice Brown, 30, Teacher\n    Bob Johnson, 40, Lawyer\n    ```\n    \n    查找年龄在 30 岁及以上的人的信息，可以使用以下命令：\n    \n    ```bash\n    grep '[3-9][0-9],.*' example.txt\n    ```\n    \n- 找出`~`目录下以`.sh`结尾的文件名\n    \n    ```bash\n    find ~ -name \"*.sh\" |grep -Eo \"[^/]+\\.sh\"\n    ```\n    \n\n练习4：显示/etc/passwd中不以`/bin/bash`结尾的行\n\n‘\n\n练习1答案：`\\+\\d{3}-\\d{3}-\\d{3}-\\d{5}`\n\n练习2答案：`0\\d{3}-\\d{7}|0\\d{2}-\\d{8}`\n\n练习3答案：`\\(?0\\d{2}[)-]?\\d{8}`\n\n练习4答案：`cat /etc/passwd |grep -Ev \"(/bin/bash)$”`","source":"_posts/linux_shell/8.正则表达式.md","raw":"---\ntitle: 正则表达式\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n正则表达式定义：由一系列特定字符组成的字符串，用来匹配目标文本中符合指定条件的字符或者字符串。\n\n在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。**正则表达式**\n就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n\n![Untitled](Untitled%2041.png)\n\n如果你想查找某个目录下的所有的Word文档的话，你会搜索`*.doc`。在这里，`*`会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像*010-12345678*或*0376-7654321*)。\n\n## 入门\n\n正则表达式练习平台：[https://tool.oschina.net/regex/](https://tool.oschina.net/regex/)\n\n最简单的正则表达式举例： `hi` ，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是`h`,后一个是`i`。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配*`hi*,*HI*,*Hi*,*hI*`这四种情况中的任意一种。\n\n```bash\nubuntu@sh:~$ echo \"hi,Hi\" |grep -i \"hi\"\nhi,Hi\nubuntu@sh:~$\nubuntu@sh:~$ echo \"hi,Hi,HI,hI\" |grep -i \"hi\"\nhi,Hi,HI,hI\n```\n\n## 元字符\n\n当目标文本中包含很多字符，比如*`him*,*history*,*high*`等等。用hi来查找的话，这里边的*`hi`*也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用`\\bhi\\b`。\\b是正则表达式规定的一个特殊代码（**元字符，metacharacter**），代表着单词的开头或结尾，也就是单词的分界处。\n\n假如要找的是`hi`后面不远处跟着一个`Lucy`，应该用`\\bhi\\b.*\\bLucy\\b`。\n\n这里，`.`是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，`.`*连在一起就意味着任意数量的不包含换行的字符。现在`\\bhi\\b.**\\bLucy\\b`的意思就很明显：先是一个单词`hi`,然后是任意个任意字符(但不能是换行)，最后是`Lucy`这个单词。\n\n```bash\nubuntu@sh:~$ echo \"hi,Hi,HI,hI,Lucy\" |grep -o \"\\bhi\\b.*\\bLucy\\b\"\nhi,Hi,HI,hI,Lucy\n```\n\n`0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d`匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码)。这里的`\\d`是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符。\n\n也可以这样写这个表达式：`0\\d{2}-\\d{8}`。这里`\\d`后面的`{2}({8})`的意思是前面`\\d`必须连续重复匹配`2次(8次)`。\n\n练习1：匹配国际格式的电话号码`+086-185-553-24528` \n\n练习2：匹配国内电话号码`0511-4405222、021-87888822`\n\n- 常用的元字符\n\n| 代码 | 说明 |\n| --- | --- |\n| . | 匹配除换行符以外的任意字符 |\n| \\w | 匹配字母或数字或下划线或汉字 |\n| \\s | 匹配任意的空白符 |\n| \\d | 匹配数字 |\n| \\b | 匹配单词的开始或结束 |\n| ^ | 匹配字符串的开始 |\n| $ | 匹配字符串的结束 |\n\n元字符`^`（和数字6在同一个键位上的符号）和`$`都匹配一个位置，这和`\\b`有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：`^\\d{5,12}$`。\n\n- 常用的限定符\n\n| 代码/语法 | 说明 |\n| --- | --- |\n| * | 重复零次或更多次 |\n| + | 重复一次或更多次 |\n| ? | 重复零次或一次 |\n| {n} | 重复n次 |\n| {n,} | 重复n次或更多次 |\n| {n,m} | 重复n到m次 |\n1. `\\ba\\w*\\b`匹配以字母`a`开头的单词——先是某个单词开始处`(\\b)`，然后是字母`a`,然后是任意数量的字母或数字`(\\w*)`，最后是单词结束处`(\\b)`。\n2. `\\d+`匹配1个或更多连续的数字。这里的`+`是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而`+`则匹配重复1次或更多次。\n3. `\\b\\w{6}\\b` 匹配刚好6个字符的单词。\n\n## 字符转义\n\n如果想查找元字符本身的话，比如查找`.`,或者`*`,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时就得使用`\\`来取消这些字符的特殊意义。因此，应该使用`\\.`和`\\*`。当然，要查找`\\`本身，也得用`\\\\`.\n\n例如：`deerchao\\.cn`匹配`deerchao.cn`，`C:\\\\Windows`匹配`C:\\Windows`。\n\n## 字符类\n\n要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果想匹配没有预定义元字符的字符集合，需要在方括号中列出他们：`[aeiou]`就匹配任何一个英文元音字母，`[.?!]`匹配标点符号(.或?或!)。\n\n练习3：匹配*(010)88886666*，或*022-22334455*，或*02912345678。*\n\n## 分组\n\n想要重复多个字符又该怎么办？可以用小括号来指定**子表达式**(也叫做**分组**)，然后就可以指定这个子表达式的重复次数了。`(\\d{1,3}\\.){3}\\d{1,3}`是一个简单的IP地址匹配表达式。要理解这个表达式，按下列顺序分析它：\n\n1. `\\d{1,3}`匹配1到3位的数字\n2. `(\\d{1,3}\\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个**分组**)重复3次\n3. 最后再加上一个一到三位的数字`(\\d{1,3})`。\n\n它也将匹配*`256.300.888.999`*这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：`((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)`。\n\n理解这个表达式的关键是理解`2[0-4]\\d|25[0-5]|[01]?\\d\\d?`。\n\n## 反义\n\n有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到**反义。**\n\n| 代码/语法 | 说明 |\n| --- | --- |\n| \\W | 匹配任意不是字母，数字，下划线，汉字的字符 |\n| \\S | 匹配任意不是空白符的字符 |\n| \\D | 匹配任意非数字的字符 |\n| \\B | 匹配不是单词开头或结束的位置 |\n| [^x] | 匹配除了x以外的任意字符 |\n| [^aeiou] | 匹配除了aeiou这几个字母以外的任意字符 |\n\n例子：`\\S+`匹配不包含空白符的字符串。\n\n`<a[^>]+>`匹配用尖括号括起来的以a开头的字符串。\n\n## 贪婪与懒惰\n\n当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：`a.*b`，它将会匹配最长的以`a`开始，以`b`结束的字符串。如果用它来搜索*`aabab`*的话，它会匹配整个字符串`aabab`。这被称为**贪婪**匹配。\n\n有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号`?`。这样`.*?`就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。\n\n举例：`a.*?b`匹配最短的，以`a`开始，以`b`结束的字符串。如果把它应用于*`aabab`*的话，它会匹配`aab`（第一到第三个字符）和`ab`（第四到第五个字符）。\n\n| 代码/语法 | 说明 |\n| --- | --- |\n| *? | 重复任意次，但尽可能少重复 |\n| +? | 重复1次或更多次，但尽可能少重复 |\n| ?? | 重复0次或1次，但尽可能少重复 |\n| {n,m}? | 重复n到m次，但尽可能少重复 |\n| {n,}? | 重复n次以上，但尽可能少重复 |\n\n## grep命令\n\n### grep基本用法\n\n`Linux grep (global regular expression)` 命令用于查找文件里符合条件的字符串或正则表达式。\n\ngrep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 **`-`**，则 grep 指令会从标准输入设备读取数据。\n\n- 基于目标文件进行查找\n    \n    ```bash\n    ubuntu@sh:~$ grep \"ubuntu\" /etc/passwd\n    ubuntu:x:1000:1000:ubuntu,,,:/home/ubuntu:/bin/bash\n    ```\n    \n- 基于标准输入进行查找\n    \n    ```bash\n    ubuntu@sh:~$ ps -aux |grep ssh\n    root        864  0.0  0.1  65508  5424 ?        Ss   Mar26   0:00 /usr/sbin/sshd -D\n    root      18851  0.0  0.1  92796  6836 ?        Ss   Apr06   0:00 sshd: ubuntu [priv]\n    ubuntu    18878  0.0  0.0  92796  3988 ?        S    Apr06   0:02 sshd: ubuntu@pts/0\n    ubuntu    23726  0.0  0.0  14220  1028 pts/0    S+   21:08   0:00 grep --color=auto ssh\n    ```\n    \n- 常用选项\n    - `i`：忽略大小写进行匹配。\n    - `v`：反向查找，只打印不匹配的行。\n    - `n`：显示匹配行的行号。\n    - `r`：递归查找子目录中的文件。\n    - `l`：只打印匹配的文件名。\n    - `c`：只打印匹配的行数。\n\n### grep结合正则表达式用法\n\n- 已有文本文件`example.txt`，其中存储了一些人的信息，包括姓名、年龄和职业，每行一个人的信息：\n    \n    ```bash\n    John Smith, 25, Engineer\n    Alice Brown, 30, Teacher\n    Bob Johnson, 40, Lawyer\n    ```\n    \n    查找年龄在 30 岁及以上的人的信息，可以使用以下命令：\n    \n    ```bash\n    grep '[3-9][0-9],.*' example.txt\n    ```\n    \n- 找出`~`目录下以`.sh`结尾的文件名\n    \n    ```bash\n    find ~ -name \"*.sh\" |grep -Eo \"[^/]+\\.sh\"\n    ```\n    \n\n练习4：显示/etc/passwd中不以`/bin/bash`结尾的行\n\n‘\n\n练习1答案：`\\+\\d{3}-\\d{3}-\\d{3}-\\d{5}`\n\n练习2答案：`0\\d{3}-\\d{7}|0\\d{2}-\\d{8}`\n\n练习3答案：`\\(?0\\d{2}[)-]?\\d{8}`\n\n练习4答案：`cat /etc/passwd |grep -Ev \"(/bin/bash)$”`","slug":"linux_shell/8.正则表达式","published":1,"updated":"2023-06-10T08:09:30.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cliuf72wh0009j1nz7gqj0389","content":"<p>正则表达式定义：由一系列特定字符组成的字符串，用来匹配目标文本中符合指定条件的字符或者字符串。</p>\n<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。<strong>正则表达式</strong><br>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>\n<p><img src=\"/Untitled%2041.png\" alt=\"Untitled\"></p>\n<p>如果你想查找某个目录下的所有的Word文档的话，你会搜索<code>*.doc</code>。在这里，<code>*</code>会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像<em>010-12345678</em>或<em>0376-7654321</em>)。</p>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>正则表达式练习平台：<a href=\"https://tool.oschina.net/regex/\">https://tool.oschina.net/regex/</a></p>\n<p>最简单的正则表达式举例： <code>hi</code> ，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是<code>h</code>,后一个是<code>i</code>。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配*<code>hi*,*HI*,*Hi*,*hI*</code>这四种情况中的任意一种。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ <span class=\"built_in\">echo</span> <span class=\"string\">&quot;hi,Hi&quot;</span> |grep -i <span class=\"string\">&quot;hi&quot;</span></span><br><span class=\"line\">hi,Hi</span><br><span class=\"line\">ubuntu@sh:~$</span><br><span class=\"line\">ubuntu@sh:~$ <span class=\"built_in\">echo</span> <span class=\"string\">&quot;hi,Hi,HI,hI&quot;</span> |grep -i <span class=\"string\">&quot;hi&quot;</span></span><br><span class=\"line\">hi,Hi,HI,hI</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><p>当目标文本中包含很多字符，比如*<code>him*,*history*,*high*</code>等等。用hi来查找的话，这里边的*<code>hi</code>*也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用<code>\\bhi\\b</code>。\\b是正则表达式规定的一个特殊代码（<strong>元字符，metacharacter</strong>），代表着单词的开头或结尾，也就是单词的分界处。</p>\n<p>假如要找的是<code>hi</code>后面不远处跟着一个<code>Lucy</code>，应该用<code>\\bhi\\b.*\\bLucy\\b</code>。</p>\n<p>这里，<code>.</code>是另一个元字符，匹配除了换行符以外的任意字符。<em>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定</em>前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，<code>.</code>*连在一起就意味着任意数量的不包含换行的字符。现在<code>\\bhi\\b.**\\bLucy\\b</code>的意思就很明显：先是一个单词<code>hi</code>,然后是任意个任意字符(但不能是换行)，最后是<code>Lucy</code>这个单词。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ <span class=\"built_in\">echo</span> <span class=\"string\">&quot;hi,Hi,HI,hI,Lucy&quot;</span> |grep -o <span class=\"string\">&quot;\\bhi\\b.*\\bLucy\\b&quot;</span></span><br><span class=\"line\">hi,Hi,HI,hI,Lucy</span><br></pre></td></tr></table></figure>\n\n<p><code>0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d</code>匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码)。这里的<code>\\d</code>是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符。</p>\n<p>也可以这样写这个表达式：<code>0\\d&#123;2&#125;-\\d&#123;8&#125;</code>。这里<code>\\d</code>后面的<code>&#123;2&#125;(&#123;8&#125;)</code>的意思是前面<code>\\d</code>必须连续重复匹配<code>2次(8次)</code>。</p>\n<p>练习1：匹配国际格式的电话号码<code>+086-185-553-24528</code> </p>\n<p>练习2：匹配国内电话号码<code>0511-4405222、021-87888822</code></p>\n<ul>\n<li>常用的元字符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>.</td>\n<td>匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母或数字或下划线或汉字</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任意的空白符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配数字</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配字符串的开始</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配字符串的结束</td>\n</tr>\n</tbody></table>\n<p>元字符<code>^</code>（和数字6在同一个键位上的符号）和<code>$</code>都匹配一个位置，这和<code>\\b</code>有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：<code>^\\d&#123;5,12&#125;$</code>。</p>\n<ul>\n<li>常用的限定符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码&#x2F;语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>重复零次或更多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td>重复一次或更多次</td>\n</tr>\n<tr>\n<td>?</td>\n<td>重复零次或一次</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>重复n次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>重复n次或更多次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>重复n到m次</td>\n</tr>\n</tbody></table>\n<ol>\n<li><code>\\ba\\w*\\b</code>匹配以字母<code>a</code>开头的单词——先是某个单词开始处<code>(\\b)</code>，然后是字母<code>a</code>,然后是任意数量的字母或数字<code>(\\w*)</code>，最后是单词结束处<code>(\\b)</code>。</li>\n<li><code>\\d+</code>匹配1个或更多连续的数字。这里的<code>+</code>是和<em>类似的元字符，不同的是</em>匹配重复任意次(可能是0次)，而<code>+</code>则匹配重复1次或更多次。</li>\n<li><code>\\b\\w&#123;6&#125;\\b</code> 匹配刚好6个字符的单词。</li>\n</ol>\n<h2 id=\"字符转义\"><a href=\"#字符转义\" class=\"headerlink\" title=\"字符转义\"></a>字符转义</h2><p>如果想查找元字符本身的话，比如查找<code>.</code>,或者<code>*</code>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时就得使用<code>\\</code>来取消这些字符的特殊意义。因此，应该使用<code>\\.</code>和<code>\\*</code>。当然，要查找<code>\\</code>本身，也得用<code>\\\\</code>.</p>\n<p>例如：<code>deerchao\\.cn</code>匹配<code>deerchao.cn</code>，<code>C:\\\\Windows</code>匹配<code>C:\\Windows</code>。</p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果想匹配没有预定义元字符的字符集合，需要在方括号中列出他们：<code>[aeiou]</code>就匹配任何一个英文元音字母，<code>[.?!]</code>匹配标点符号(.或?或!)。</p>\n<p>练习3：匹配*(010)88886666<em>，或</em>022-22334455<em>，或</em>02912345678。*</p>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>想要重复多个字符又该怎么办？可以用小括号来指定<strong>子表达式</strong>(也叫做<strong>分组</strong>)，然后就可以指定这个子表达式的重复次数了。<code>(\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;</code>是一个简单的IP地址匹配表达式。要理解这个表达式，按下列顺序分析它：</p>\n<ol>\n<li><code>\\d&#123;1,3&#125;</code>匹配1到3位的数字</li>\n<li><code>(\\d&#123;1,3&#125;\\.)&#123;3&#125;</code>匹配三位数字加上一个英文句号(这个整体也就是这个<strong>分组</strong>)重复3次</li>\n<li>最后再加上一个一到三位的数字<code>(\\d&#123;1,3&#125;)</code>。</li>\n</ol>\n<p>它也将匹配*<code>256.300.888.999</code>*这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：<code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code>。</p>\n<p>理解这个表达式的关键是理解<code>2[0-4]\\d|25[0-5]|[01]?\\d\\d?</code>。</p>\n<h2 id=\"反义\"><a href=\"#反义\" class=\"headerlink\" title=\"反义\"></a>反义</h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到<strong>反义。</strong></p>\n<table>\n<thead>\n<tr>\n<th>代码&#x2F;语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\W</td>\n<td>匹配任意不是字母，数字，下划线，汉字的字符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任意不是空白符的字符</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配任意非数字的字符</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配不是单词开头或结束的位置</td>\n</tr>\n<tr>\n<td>[^x]</td>\n<td>匹配除了x以外的任意字符</td>\n</tr>\n<tr>\n<td>[^aeiou]</td>\n<td>匹配除了aeiou这几个字母以外的任意字符</td>\n</tr>\n</tbody></table>\n<p>例子：<code>\\S+</code>匹配不包含空白符的字符串。</p>\n<p><code>&lt;a[^&gt;]+&gt;</code>匹配用尖括号括起来的以a开头的字符串。</p>\n<h2 id=\"贪婪与懒惰\"><a href=\"#贪婪与懒惰\" class=\"headerlink\" title=\"贪婪与懒惰\"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以<code>a</code>开始，以<code>b</code>结束的字符串。如果用它来搜索*<code>aabab</code>*的话，它会匹配整个字符串<code>aabab</code>。这被称为<strong>贪婪</strong>匹配。</p>\n<p>有时，我们更需要<strong>懒惰</strong>匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>。这样<code>.*?</code>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p>\n<p>举例：<code>a.*?b</code>匹配最短的，以<code>a</code>开始，以<code>b</code>结束的字符串。如果把它应用于*<code>aabab</code>*的话，它会匹配<code>aab</code>（第一到第三个字符）和<code>ab</code>（第四到第五个字符）。</p>\n<table>\n<thead>\n<tr>\n<th>代码&#x2F;语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*?</td>\n<td>重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>+?</td>\n<td>重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>??</td>\n<td>重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,m}?</td>\n<td>重复n到m次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,}?</td>\n<td>重复n次以上，但尽可能少重复</td>\n</tr>\n</tbody></table>\n<h2 id=\"grep命令\"><a href=\"#grep命令\" class=\"headerlink\" title=\"grep命令\"></a>grep命令</h2><h3 id=\"grep基本用法\"><a href=\"#grep基本用法\" class=\"headerlink\" title=\"grep基本用法\"></a>grep基本用法</h3><p><code>Linux grep (global regular expression)</code> 命令用于查找文件里符合条件的字符串或正则表达式。</p>\n<p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 **<code>-</code>**，则 grep 指令会从标准输入设备读取数据。</p>\n<ul>\n<li><p>基于目标文件进行查找</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ grep <span class=\"string\">&quot;ubuntu&quot;</span> /etc/passwd</span><br><span class=\"line\">ubuntu:x:1000:1000:ubuntu,,,:/home/ubuntu:/bin/bash</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>基于标准输入进行查找</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ ps -aux |grep ssh</span><br><span class=\"line\">root        864  0.0  0.1  65508  5424 ?        Ss   Mar26   0:00 /usr/sbin/sshd -D</span><br><span class=\"line\">root      18851  0.0  0.1  92796  6836 ?        Ss   Apr06   0:00 sshd: ubuntu [priv]</span><br><span class=\"line\">ubuntu    18878  0.0  0.0  92796  3988 ?        S    Apr06   0:02 sshd: ubuntu@pts/0</span><br><span class=\"line\">ubuntu    23726  0.0  0.0  14220  1028 pts/0    S+   21:08   0:00 grep --color=auto ssh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用选项</p>\n<ul>\n<li><code>i</code>：忽略大小写进行匹配。</li>\n<li><code>v</code>：反向查找，只打印不匹配的行。</li>\n<li><code>n</code>：显示匹配行的行号。</li>\n<li><code>r</code>：递归查找子目录中的文件。</li>\n<li><code>l</code>：只打印匹配的文件名。</li>\n<li><code>c</code>：只打印匹配的行数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"grep结合正则表达式用法\"><a href=\"#grep结合正则表达式用法\" class=\"headerlink\" title=\"grep结合正则表达式用法\"></a>grep结合正则表达式用法</h3><ul>\n<li><p>已有文本文件<code>example.txt</code>，其中存储了一些人的信息，包括姓名、年龄和职业，每行一个人的信息：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">John Smith, 25, Engineer</span><br><span class=\"line\">Alice Brown, 30, Teacher</span><br><span class=\"line\">Bob Johnson, 40, Lawyer</span><br></pre></td></tr></table></figure>\n<p>  查找年龄在 30 岁及以上的人的信息，可以使用以下命令：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep <span class=\"string\">&#x27;[3-9][0-9],.*&#x27;</span> example.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找出<code>~</code>目录下以<code>.sh</code>结尾的文件名</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find ~ -name <span class=\"string\">&quot;*.sh&quot;</span> |grep -Eo <span class=\"string\">&quot;[^/]+\\.sh&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>练习4：显示&#x2F;etc&#x2F;passwd中不以<code>/bin/bash</code>结尾的行</p>\n<p>‘</p>\n<p>练习1答案：<code>\\+\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;5&#125;</code></p>\n<p>练习2答案：<code>0\\d&#123;3&#125;-\\d&#123;7&#125;|0\\d&#123;2&#125;-\\d&#123;8&#125;</code></p>\n<p>练习3答案：<code>\\(?0\\d&#123;2&#125;[)-]?\\d&#123;8&#125;</code></p>\n<p>练习4答案：<code>cat /etc/passwd |grep -Ev &quot;(/bin/bash)$”</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>正则表达式定义：由一系列特定字符组成的字符串，用来匹配目标文本中符合指定条件的字符或者字符串。</p>\n<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。<strong>正则表达式</strong><br>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>\n<p><img src=\"/Untitled%2041.png\" alt=\"Untitled\"></p>\n<p>如果你想查找某个目录下的所有的Word文档的话，你会搜索<code>*.doc</code>。在这里，<code>*</code>会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像<em>010-12345678</em>或<em>0376-7654321</em>)。</p>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>正则表达式练习平台：<a href=\"https://tool.oschina.net/regex/\">https://tool.oschina.net/regex/</a></p>\n<p>最简单的正则表达式举例： <code>hi</code> ，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是<code>h</code>,后一个是<code>i</code>。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配*<code>hi*,*HI*,*Hi*,*hI*</code>这四种情况中的任意一种。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ <span class=\"built_in\">echo</span> <span class=\"string\">&quot;hi,Hi&quot;</span> |grep -i <span class=\"string\">&quot;hi&quot;</span></span><br><span class=\"line\">hi,Hi</span><br><span class=\"line\">ubuntu@sh:~$</span><br><span class=\"line\">ubuntu@sh:~$ <span class=\"built_in\">echo</span> <span class=\"string\">&quot;hi,Hi,HI,hI&quot;</span> |grep -i <span class=\"string\">&quot;hi&quot;</span></span><br><span class=\"line\">hi,Hi,HI,hI</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><p>当目标文本中包含很多字符，比如*<code>him*,*history*,*high*</code>等等。用hi来查找的话，这里边的*<code>hi</code>*也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用<code>\\bhi\\b</code>。\\b是正则表达式规定的一个特殊代码（<strong>元字符，metacharacter</strong>），代表着单词的开头或结尾，也就是单词的分界处。</p>\n<p>假如要找的是<code>hi</code>后面不远处跟着一个<code>Lucy</code>，应该用<code>\\bhi\\b.*\\bLucy\\b</code>。</p>\n<p>这里，<code>.</code>是另一个元字符，匹配除了换行符以外的任意字符。<em>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定</em>前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，<code>.</code>*连在一起就意味着任意数量的不包含换行的字符。现在<code>\\bhi\\b.**\\bLucy\\b</code>的意思就很明显：先是一个单词<code>hi</code>,然后是任意个任意字符(但不能是换行)，最后是<code>Lucy</code>这个单词。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ <span class=\"built_in\">echo</span> <span class=\"string\">&quot;hi,Hi,HI,hI,Lucy&quot;</span> |grep -o <span class=\"string\">&quot;\\bhi\\b.*\\bLucy\\b&quot;</span></span><br><span class=\"line\">hi,Hi,HI,hI,Lucy</span><br></pre></td></tr></table></figure>\n\n<p><code>0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d</code>匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码)。这里的<code>\\d</code>是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符。</p>\n<p>也可以这样写这个表达式：<code>0\\d&#123;2&#125;-\\d&#123;8&#125;</code>。这里<code>\\d</code>后面的<code>&#123;2&#125;(&#123;8&#125;)</code>的意思是前面<code>\\d</code>必须连续重复匹配<code>2次(8次)</code>。</p>\n<p>练习1：匹配国际格式的电话号码<code>+086-185-553-24528</code> </p>\n<p>练习2：匹配国内电话号码<code>0511-4405222、021-87888822</code></p>\n<ul>\n<li>常用的元字符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>.</td>\n<td>匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母或数字或下划线或汉字</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任意的空白符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配数字</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配字符串的开始</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配字符串的结束</td>\n</tr>\n</tbody></table>\n<p>元字符<code>^</code>（和数字6在同一个键位上的符号）和<code>$</code>都匹配一个位置，这和<code>\\b</code>有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：<code>^\\d&#123;5,12&#125;$</code>。</p>\n<ul>\n<li>常用的限定符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码&#x2F;语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>重复零次或更多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td>重复一次或更多次</td>\n</tr>\n<tr>\n<td>?</td>\n<td>重复零次或一次</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>重复n次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>重复n次或更多次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>重复n到m次</td>\n</tr>\n</tbody></table>\n<ol>\n<li><code>\\ba\\w*\\b</code>匹配以字母<code>a</code>开头的单词——先是某个单词开始处<code>(\\b)</code>，然后是字母<code>a</code>,然后是任意数量的字母或数字<code>(\\w*)</code>，最后是单词结束处<code>(\\b)</code>。</li>\n<li><code>\\d+</code>匹配1个或更多连续的数字。这里的<code>+</code>是和<em>类似的元字符，不同的是</em>匹配重复任意次(可能是0次)，而<code>+</code>则匹配重复1次或更多次。</li>\n<li><code>\\b\\w&#123;6&#125;\\b</code> 匹配刚好6个字符的单词。</li>\n</ol>\n<h2 id=\"字符转义\"><a href=\"#字符转义\" class=\"headerlink\" title=\"字符转义\"></a>字符转义</h2><p>如果想查找元字符本身的话，比如查找<code>.</code>,或者<code>*</code>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时就得使用<code>\\</code>来取消这些字符的特殊意义。因此，应该使用<code>\\.</code>和<code>\\*</code>。当然，要查找<code>\\</code>本身，也得用<code>\\\\</code>.</p>\n<p>例如：<code>deerchao\\.cn</code>匹配<code>deerchao.cn</code>，<code>C:\\\\Windows</code>匹配<code>C:\\Windows</code>。</p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果想匹配没有预定义元字符的字符集合，需要在方括号中列出他们：<code>[aeiou]</code>就匹配任何一个英文元音字母，<code>[.?!]</code>匹配标点符号(.或?或!)。</p>\n<p>练习3：匹配*(010)88886666<em>，或</em>022-22334455<em>，或</em>02912345678。*</p>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>想要重复多个字符又该怎么办？可以用小括号来指定<strong>子表达式</strong>(也叫做<strong>分组</strong>)，然后就可以指定这个子表达式的重复次数了。<code>(\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;</code>是一个简单的IP地址匹配表达式。要理解这个表达式，按下列顺序分析它：</p>\n<ol>\n<li><code>\\d&#123;1,3&#125;</code>匹配1到3位的数字</li>\n<li><code>(\\d&#123;1,3&#125;\\.)&#123;3&#125;</code>匹配三位数字加上一个英文句号(这个整体也就是这个<strong>分组</strong>)重复3次</li>\n<li>最后再加上一个一到三位的数字<code>(\\d&#123;1,3&#125;)</code>。</li>\n</ol>\n<p>它也将匹配*<code>256.300.888.999</code>*这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：<code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code>。</p>\n<p>理解这个表达式的关键是理解<code>2[0-4]\\d|25[0-5]|[01]?\\d\\d?</code>。</p>\n<h2 id=\"反义\"><a href=\"#反义\" class=\"headerlink\" title=\"反义\"></a>反义</h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到<strong>反义。</strong></p>\n<table>\n<thead>\n<tr>\n<th>代码&#x2F;语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\W</td>\n<td>匹配任意不是字母，数字，下划线，汉字的字符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任意不是空白符的字符</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配任意非数字的字符</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配不是单词开头或结束的位置</td>\n</tr>\n<tr>\n<td>[^x]</td>\n<td>匹配除了x以外的任意字符</td>\n</tr>\n<tr>\n<td>[^aeiou]</td>\n<td>匹配除了aeiou这几个字母以外的任意字符</td>\n</tr>\n</tbody></table>\n<p>例子：<code>\\S+</code>匹配不包含空白符的字符串。</p>\n<p><code>&lt;a[^&gt;]+&gt;</code>匹配用尖括号括起来的以a开头的字符串。</p>\n<h2 id=\"贪婪与懒惰\"><a href=\"#贪婪与懒惰\" class=\"headerlink\" title=\"贪婪与懒惰\"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以<code>a</code>开始，以<code>b</code>结束的字符串。如果用它来搜索*<code>aabab</code>*的话，它会匹配整个字符串<code>aabab</code>。这被称为<strong>贪婪</strong>匹配。</p>\n<p>有时，我们更需要<strong>懒惰</strong>匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>。这样<code>.*?</code>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p>\n<p>举例：<code>a.*?b</code>匹配最短的，以<code>a</code>开始，以<code>b</code>结束的字符串。如果把它应用于*<code>aabab</code>*的话，它会匹配<code>aab</code>（第一到第三个字符）和<code>ab</code>（第四到第五个字符）。</p>\n<table>\n<thead>\n<tr>\n<th>代码&#x2F;语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*?</td>\n<td>重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>+?</td>\n<td>重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>??</td>\n<td>重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,m}?</td>\n<td>重复n到m次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,}?</td>\n<td>重复n次以上，但尽可能少重复</td>\n</tr>\n</tbody></table>\n<h2 id=\"grep命令\"><a href=\"#grep命令\" class=\"headerlink\" title=\"grep命令\"></a>grep命令</h2><h3 id=\"grep基本用法\"><a href=\"#grep基本用法\" class=\"headerlink\" title=\"grep基本用法\"></a>grep基本用法</h3><p><code>Linux grep (global regular expression)</code> 命令用于查找文件里符合条件的字符串或正则表达式。</p>\n<p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 **<code>-</code>**，则 grep 指令会从标准输入设备读取数据。</p>\n<ul>\n<li><p>基于目标文件进行查找</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ grep <span class=\"string\">&quot;ubuntu&quot;</span> /etc/passwd</span><br><span class=\"line\">ubuntu:x:1000:1000:ubuntu,,,:/home/ubuntu:/bin/bash</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>基于标准输入进行查找</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu@sh:~$ ps -aux |grep ssh</span><br><span class=\"line\">root        864  0.0  0.1  65508  5424 ?        Ss   Mar26   0:00 /usr/sbin/sshd -D</span><br><span class=\"line\">root      18851  0.0  0.1  92796  6836 ?        Ss   Apr06   0:00 sshd: ubuntu [priv]</span><br><span class=\"line\">ubuntu    18878  0.0  0.0  92796  3988 ?        S    Apr06   0:02 sshd: ubuntu@pts/0</span><br><span class=\"line\">ubuntu    23726  0.0  0.0  14220  1028 pts/0    S+   21:08   0:00 grep --color=auto ssh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用选项</p>\n<ul>\n<li><code>i</code>：忽略大小写进行匹配。</li>\n<li><code>v</code>：反向查找，只打印不匹配的行。</li>\n<li><code>n</code>：显示匹配行的行号。</li>\n<li><code>r</code>：递归查找子目录中的文件。</li>\n<li><code>l</code>：只打印匹配的文件名。</li>\n<li><code>c</code>：只打印匹配的行数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"grep结合正则表达式用法\"><a href=\"#grep结合正则表达式用法\" class=\"headerlink\" title=\"grep结合正则表达式用法\"></a>grep结合正则表达式用法</h3><ul>\n<li><p>已有文本文件<code>example.txt</code>，其中存储了一些人的信息，包括姓名、年龄和职业，每行一个人的信息：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">John Smith, 25, Engineer</span><br><span class=\"line\">Alice Brown, 30, Teacher</span><br><span class=\"line\">Bob Johnson, 40, Lawyer</span><br></pre></td></tr></table></figure>\n<p>  查找年龄在 30 岁及以上的人的信息，可以使用以下命令：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep <span class=\"string\">&#x27;[3-9][0-9],.*&#x27;</span> example.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找出<code>~</code>目录下以<code>.sh</code>结尾的文件名</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find ~ -name <span class=\"string\">&quot;*.sh&quot;</span> |grep -Eo <span class=\"string\">&quot;[^/]+\\.sh&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>练习4：显示&#x2F;etc&#x2F;passwd中不以<code>/bin/bash</code>结尾的行</p>\n<p>‘</p>\n<p>练习1答案：<code>\\+\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;5&#125;</code></p>\n<p>练习2答案：<code>0\\d&#123;3&#125;-\\d&#123;7&#125;|0\\d&#123;2&#125;-\\d&#123;8&#125;</code></p>\n<p>练习3答案：<code>\\(?0\\d&#123;2&#125;[)-]?\\d&#123;8&#125;</code></p>\n<p>练习4答案：<code>cat /etc/passwd |grep -Ev &quot;(/bin/bash)$”</code></p>\n"},{"title":"流编辑器sed","date":"2023-04-18T03:31:23.000Z","_content":"\n## sed编辑器定义\n\n用于处理文本文件中的数据流。它是一种非交互式的编辑器，可以从标准输入（stdin）或文件中读取输入，然后将文本进行转换、替换、删除、添加等操作，最后将处理后的文本输出到标准输出（stdout）或文件中。它的名字来源于“流编辑器（stream editor）”。\n\n## sed编辑器特点\n\n与传统的文本编辑器（如vi和emacs）不同，sed对文件进行的修改是非常快速和高效的，因为它不需要打开文件并读取整个文件内容，而是按行处理文件，只处理必要的部分。此外，sed支持正则表达式，可以在文本文件中进行高级搜索和替换操作。\n\n## sed编辑器的工作流程\n\n1. 一次从输入中读取一行数据\n2. 根据所提供的编辑器命令匹配数据\n3. 按照命令修改流中的数据\n4. 将新的数据输出到STDOUT\n\n在执行过程中，sed编辑器使用的是基于行的处理方式，即每次处理一行数据。而指令则是根据正则表达式来匹配和处理数据的。通过指令的组合使用，可以实现很多文本处理和编辑的功能，比如替换、删除、插入等操作。\n\n## sed编辑器基础\n\n### sed命令格式\n\n```bash\nsed options 'command' inputfile\n```\n\n其中，**`options`**是可选项，**`command`**是sed命令，**`inputfile`**是要处理的文件名。如果不指定**`inputfile`**，sed将从标准输入读取数据。\n\n### 基本用法\n\n```bash\nsed 's/oldstring/newstring/' inputfile\n```\n\n其中，**`s`**表示替换操作，**`oldstring`**表示要被替换的字符串，**`newstring`**表示替换后的字符串，**`inputfile`**表示要处理的文件名。此命令将替换文件中的第一个匹配项。如果要替换所有匹配项，则需要使用**`g`**选项，如下所示：\n\n```bash\nsed 's/oldstring/newstring/g' inputfile\n```\n\n除了**`s`**命令，sed还有其他命令，如**`p`**命令（打印指定的行）、**`d`**命令（删除指定的行）、**`a`**命令（在指定行后添加一行文本）等。这些命令可以组合使用，构成一个完整的sed脚本，用于对文本进行复杂的处理。\n\n- 双引号和单引号的区别\n    \n    在使用 **`sed`** 命令时，单引号和双引号的使用是有区别的。在单引号中，所有的特殊字符都会被视为普通字符，而在双引号中，除了 **`$`** 和**```**之外，其他的特殊字符都会被视为普通字符。\n    \n    具体来说，在单引号中，变量和命令替换不会被执行，而在双引号中，会先进行变量和命令替换，然后再执行 **`sed`** 命令。\n    \n    ```bash\n    $ name=\"universe\"\n    $ sed \"s/world/$name/\" test.txt\n    ```\n    \n- 常见选项\n    - **`n`**：取消默认输出，使用print命令完成输出。\n    - **`e`**：允许多个 sed 命令被执行。\n        \n        ```bash\n        sed -e 's/apple/orange/g' -e 's/\\s*$//' file.txt\n        ```\n        \n    - **`f`**：指定 sed 命令文件。\n        \n        ```bash\n        sed -f commands.sed file.txt\n        ```\n        \n        commands.sed文件内容：\n        \n        ```\n        s/Hello/Hi/\n        s/World/There/\n        ```\n        \n    - **`i`**：直接修改文件，而不是输出到终端。\n    - **`r`** 或 **`E`**：使用扩展正则表达式。\n- 常见命令\n    - `**s**`：替换字符\n        \n        ```bash\n        # 将文件中的 apple 替换为 banana\n        sed 's/apple/banana/g' file.txt\n        \n        # 将每行的第一个 apple 替换为 banana\n        sed 's/apple/banana/' file.txt\n        ```\n        \n    - `**d**`：删除命令，用于删除文件中的指定行或指定模式。\n        \n        ```bash\n        # 删除匹配模式的行\n        sed '/pattern/d' file.txt\n        \n        # 删除 :10 到 20 行\n        sed '10,20d' file.txt\n        \n        # 删除空行\n        sed '/^$/d' file.txt\n        ```\n        \n    - `**a**`：添加命令，用于在文件中的指定行后面添加新的内容。\n        \n        ```bash\n        # 在匹配模式所在行的下一行添加新的内容\n        sed '/pattern/a new line' file.txt\n        \n        # 在指定行号的下一行添加新的内容\n        sed '3a new line' file.txt\n        ```\n        \n    - `**i**`：插入命令，用于在文件中的指定行前面插入新的内容。\n        \n        ```bash\n        # 在匹配模式所在行的上一行插入新的内容\n        sed '/pattern/i new line' file.txt\n        \n        # 在指定行号的上一行插入新的内容\n        sed '3i new line' file.txt\n        \n        # 在文件中插入新的文本行：\n        sed '1i\\New Text' filename\n        ```\n        \n    - `**c**`：替换命令，用于将指定行替换为新的内容。\n        \n        ```bash\n        # 将匹配模式所在行替换为新的内容\n        sed '/pattern/c new line' file.txt\n        \n        # 将指定行号替换为新的内容\n        sed '3c new line' file.txt\n        ```\n        \n\n## sed正则表达式用法\n\n1. 删除文件中的空行：\n    \n    ```bash\n    sed '/^$/d' filename\n    ```\n    \n    使用正则表达式匹配空行（以行首和行尾之间没有任何字符的行），然后使用 **`d`** 命令删除这些行。\n    \n2. 删除文件中的注释行：\n    \n    ```bash\n    sed '/^#/d' filename\n    ```\n    \n    使用正则表达式匹配以 **`#`**开头的行，然后使用 **`d`**命令删除这些行。\n    \n3. 按照指定格式输出文件内容：\n    \n    ```bash\n    sed 's/\\(.*\\)/<p>\\1<\\/p>/' filename\n    ```\n    \n4. 指定行前添加#号：\n    \n    ```bash\n    sed -r '1,5s/(.*)/#\\1/' filename\n    ```\n    \n5. 将文本文件中的每一行都替换为该行的第一个单词：\n    \n    ```bash\n    sed 's/\\([a-zA-Z]*\\).*/\\1/' test.txt\n    ```\n    \n6. 提取文本文件中的URL：\n    \n    ```bash\n    sed -nE 's#.*(https?://[^ ]*).*#\\1#p' test.txt\n    ```\n    \n\n## vim中的sed用法\n\n1. 替换文件中的指定字符串\n    \n    在Vim中，可以使用“:%s/old/new/g”命令来替换文件中的指定字符串，其中“%”表示对整个文件进行操作，“s”表示替换，“/”用于分隔替换前、替换后的内容，“g”表示全局替换。\n    \n2. 删除文件中的指定行\n    \n    在Vim中，可以使用“:g/pattern/d”命令来删除文件中包含指定字符串的行，其中“g”表示全局匹配，“pattern”表示要匹配的字符串，“d”表示删除操作。\n    \n3. 在文件中插入指定字符串\n    \n    在Vim中，可以使用“:1,$s/^/string/”命令在文件的每一行前插入指定字符串，其中“1,$”表示对整个文件进行操作，“^”表示行首，“string”表示要插入的字符串。","source":"_posts/linux_shell/9.流编辑器sed.md","raw":"---\ntitle: 流编辑器sed\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n## sed编辑器定义\n\n用于处理文本文件中的数据流。它是一种非交互式的编辑器，可以从标准输入（stdin）或文件中读取输入，然后将文本进行转换、替换、删除、添加等操作，最后将处理后的文本输出到标准输出（stdout）或文件中。它的名字来源于“流编辑器（stream editor）”。\n\n## sed编辑器特点\n\n与传统的文本编辑器（如vi和emacs）不同，sed对文件进行的修改是非常快速和高效的，因为它不需要打开文件并读取整个文件内容，而是按行处理文件，只处理必要的部分。此外，sed支持正则表达式，可以在文本文件中进行高级搜索和替换操作。\n\n## sed编辑器的工作流程\n\n1. 一次从输入中读取一行数据\n2. 根据所提供的编辑器命令匹配数据\n3. 按照命令修改流中的数据\n4. 将新的数据输出到STDOUT\n\n在执行过程中，sed编辑器使用的是基于行的处理方式，即每次处理一行数据。而指令则是根据正则表达式来匹配和处理数据的。通过指令的组合使用，可以实现很多文本处理和编辑的功能，比如替换、删除、插入等操作。\n\n## sed编辑器基础\n\n### sed命令格式\n\n```bash\nsed options 'command' inputfile\n```\n\n其中，**`options`**是可选项，**`command`**是sed命令，**`inputfile`**是要处理的文件名。如果不指定**`inputfile`**，sed将从标准输入读取数据。\n\n### 基本用法\n\n```bash\nsed 's/oldstring/newstring/' inputfile\n```\n\n其中，**`s`**表示替换操作，**`oldstring`**表示要被替换的字符串，**`newstring`**表示替换后的字符串，**`inputfile`**表示要处理的文件名。此命令将替换文件中的第一个匹配项。如果要替换所有匹配项，则需要使用**`g`**选项，如下所示：\n\n```bash\nsed 's/oldstring/newstring/g' inputfile\n```\n\n除了**`s`**命令，sed还有其他命令，如**`p`**命令（打印指定的行）、**`d`**命令（删除指定的行）、**`a`**命令（在指定行后添加一行文本）等。这些命令可以组合使用，构成一个完整的sed脚本，用于对文本进行复杂的处理。\n\n- 双引号和单引号的区别\n    \n    在使用 **`sed`** 命令时，单引号和双引号的使用是有区别的。在单引号中，所有的特殊字符都会被视为普通字符，而在双引号中，除了 **`$`** 和**```**之外，其他的特殊字符都会被视为普通字符。\n    \n    具体来说，在单引号中，变量和命令替换不会被执行，而在双引号中，会先进行变量和命令替换，然后再执行 **`sed`** 命令。\n    \n    ```bash\n    $ name=\"universe\"\n    $ sed \"s/world/$name/\" test.txt\n    ```\n    \n- 常见选项\n    - **`n`**：取消默认输出，使用print命令完成输出。\n    - **`e`**：允许多个 sed 命令被执行。\n        \n        ```bash\n        sed -e 's/apple/orange/g' -e 's/\\s*$//' file.txt\n        ```\n        \n    - **`f`**：指定 sed 命令文件。\n        \n        ```bash\n        sed -f commands.sed file.txt\n        ```\n        \n        commands.sed文件内容：\n        \n        ```\n        s/Hello/Hi/\n        s/World/There/\n        ```\n        \n    - **`i`**：直接修改文件，而不是输出到终端。\n    - **`r`** 或 **`E`**：使用扩展正则表达式。\n- 常见命令\n    - `**s**`：替换字符\n        \n        ```bash\n        # 将文件中的 apple 替换为 banana\n        sed 's/apple/banana/g' file.txt\n        \n        # 将每行的第一个 apple 替换为 banana\n        sed 's/apple/banana/' file.txt\n        ```\n        \n    - `**d**`：删除命令，用于删除文件中的指定行或指定模式。\n        \n        ```bash\n        # 删除匹配模式的行\n        sed '/pattern/d' file.txt\n        \n        # 删除 :10 到 20 行\n        sed '10,20d' file.txt\n        \n        # 删除空行\n        sed '/^$/d' file.txt\n        ```\n        \n    - `**a**`：添加命令，用于在文件中的指定行后面添加新的内容。\n        \n        ```bash\n        # 在匹配模式所在行的下一行添加新的内容\n        sed '/pattern/a new line' file.txt\n        \n        # 在指定行号的下一行添加新的内容\n        sed '3a new line' file.txt\n        ```\n        \n    - `**i**`：插入命令，用于在文件中的指定行前面插入新的内容。\n        \n        ```bash\n        # 在匹配模式所在行的上一行插入新的内容\n        sed '/pattern/i new line' file.txt\n        \n        # 在指定行号的上一行插入新的内容\n        sed '3i new line' file.txt\n        \n        # 在文件中插入新的文本行：\n        sed '1i\\New Text' filename\n        ```\n        \n    - `**c**`：替换命令，用于将指定行替换为新的内容。\n        \n        ```bash\n        # 将匹配模式所在行替换为新的内容\n        sed '/pattern/c new line' file.txt\n        \n        # 将指定行号替换为新的内容\n        sed '3c new line' file.txt\n        ```\n        \n\n## sed正则表达式用法\n\n1. 删除文件中的空行：\n    \n    ```bash\n    sed '/^$/d' filename\n    ```\n    \n    使用正则表达式匹配空行（以行首和行尾之间没有任何字符的行），然后使用 **`d`** 命令删除这些行。\n    \n2. 删除文件中的注释行：\n    \n    ```bash\n    sed '/^#/d' filename\n    ```\n    \n    使用正则表达式匹配以 **`#`**开头的行，然后使用 **`d`**命令删除这些行。\n    \n3. 按照指定格式输出文件内容：\n    \n    ```bash\n    sed 's/\\(.*\\)/<p>\\1<\\/p>/' filename\n    ```\n    \n4. 指定行前添加#号：\n    \n    ```bash\n    sed -r '1,5s/(.*)/#\\1/' filename\n    ```\n    \n5. 将文本文件中的每一行都替换为该行的第一个单词：\n    \n    ```bash\n    sed 's/\\([a-zA-Z]*\\).*/\\1/' test.txt\n    ```\n    \n6. 提取文本文件中的URL：\n    \n    ```bash\n    sed -nE 's#.*(https?://[^ ]*).*#\\1#p' test.txt\n    ```\n    \n\n## vim中的sed用法\n\n1. 替换文件中的指定字符串\n    \n    在Vim中，可以使用“:%s/old/new/g”命令来替换文件中的指定字符串，其中“%”表示对整个文件进行操作，“s”表示替换，“/”用于分隔替换前、替换后的内容，“g”表示全局替换。\n    \n2. 删除文件中的指定行\n    \n    在Vim中，可以使用“:g/pattern/d”命令来删除文件中包含指定字符串的行，其中“g”表示全局匹配，“pattern”表示要匹配的字符串，“d”表示删除操作。\n    \n3. 在文件中插入指定字符串\n    \n    在Vim中，可以使用“:1,$s/^/string/”命令在文件的每一行前插入指定字符串，其中“1,$”表示对整个文件进行操作，“^”表示行首，“string”表示要插入的字符串。","slug":"linux_shell/9.流编辑器sed","published":1,"updated":"2023-06-10T08:09:30.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cliuf72wk000aj1nz3d2ddb25","content":"<h2 id=\"sed编辑器定义\"><a href=\"#sed编辑器定义\" class=\"headerlink\" title=\"sed编辑器定义\"></a>sed编辑器定义</h2><p>用于处理文本文件中的数据流。它是一种非交互式的编辑器，可以从标准输入（stdin）或文件中读取输入，然后将文本进行转换、替换、删除、添加等操作，最后将处理后的文本输出到标准输出（stdout）或文件中。它的名字来源于“流编辑器（stream editor）”。</p>\n<h2 id=\"sed编辑器特点\"><a href=\"#sed编辑器特点\" class=\"headerlink\" title=\"sed编辑器特点\"></a>sed编辑器特点</h2><p>与传统的文本编辑器（如vi和emacs）不同，sed对文件进行的修改是非常快速和高效的，因为它不需要打开文件并读取整个文件内容，而是按行处理文件，只处理必要的部分。此外，sed支持正则表达式，可以在文本文件中进行高级搜索和替换操作。</p>\n<h2 id=\"sed编辑器的工作流程\"><a href=\"#sed编辑器的工作流程\" class=\"headerlink\" title=\"sed编辑器的工作流程\"></a>sed编辑器的工作流程</h2><ol>\n<li>一次从输入中读取一行数据</li>\n<li>根据所提供的编辑器命令匹配数据</li>\n<li>按照命令修改流中的数据</li>\n<li>将新的数据输出到STDOUT</li>\n</ol>\n<p>在执行过程中，sed编辑器使用的是基于行的处理方式，即每次处理一行数据。而指令则是根据正则表达式来匹配和处理数据的。通过指令的组合使用，可以实现很多文本处理和编辑的功能，比如替换、删除、插入等操作。</p>\n<h2 id=\"sed编辑器基础\"><a href=\"#sed编辑器基础\" class=\"headerlink\" title=\"sed编辑器基础\"></a>sed编辑器基础</h2><h3 id=\"sed命令格式\"><a href=\"#sed命令格式\" class=\"headerlink\" title=\"sed命令格式\"></a>sed命令格式</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed options <span class=\"string\">&#x27;command&#x27;</span> inputfile</span><br></pre></td></tr></table></figure>\n\n<p>其中，**<code>options</code><strong>是可选项，</strong><code>command</code><strong>是sed命令，</strong><code>inputfile</code><strong>是要处理的文件名。如果不指定</strong><code>inputfile</code>**，sed将从标准输入读取数据。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;s/oldstring/newstring/&#x27;</span> inputfile</span><br></pre></td></tr></table></figure>\n\n<p>其中，**<code>s</code><strong>表示替换操作，</strong><code>oldstring</code><strong>表示要被替换的字符串，</strong><code>newstring</code><strong>表示替换后的字符串，</strong><code>inputfile</code><strong>表示要处理的文件名。此命令将替换文件中的第一个匹配项。如果要替换所有匹配项，则需要使用</strong><code>g</code>**选项，如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;s/oldstring/newstring/g&#x27;</span> inputfile</span><br></pre></td></tr></table></figure>\n\n<p>除了**<code>s</code><strong>命令，sed还有其他命令，如</strong><code>p</code><strong>命令（打印指定的行）、</strong><code>d</code><strong>命令（删除指定的行）、</strong><code>a</code>**命令（在指定行后添加一行文本）等。这些命令可以组合使用，构成一个完整的sed脚本，用于对文本进行复杂的处理。</p>\n<ul>\n<li><p>双引号和单引号的区别</p>\n<p>  在使用 <strong><code>sed</code></strong> 命令时，单引号和双引号的使用是有区别的。在单引号中，所有的特殊字符都会被视为普通字符，而在双引号中，除了 <strong><code>$</code></strong> 和**&#96;&#96;&#96;**之外，其他的特殊字符都会被视为普通字符。</p>\n<p>  具体来说，在单引号中，变量和命令替换不会被执行，而在双引号中，会先进行变量和命令替换，然后再执行 <strong><code>sed</code></strong> 命令。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ name=<span class=\"string\">&quot;universe&quot;</span></span><br><span class=\"line\">$ sed <span class=\"string\">&quot;s/world/<span class=\"variable\">$name</span>/&quot;</span> test.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常见选项</p>\n<ul>\n<li><p>**<code>n</code>**：取消默认输出，使用print命令完成输出。</p>\n</li>\n<li><p>**<code>e</code>**：允许多个 sed 命令被执行。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -e <span class=\"string\">&#x27;s/apple/orange/g&#x27;</span> -e <span class=\"string\">&#x27;s/\\s*$//&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>**<code>f</code>**：指定 sed 命令文件。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -f commands.sed file.txt</span><br></pre></td></tr></table></figure>\n<p>  commands.sed文件内容：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/Hello/Hi/</span><br><span class=\"line\">s/World/There/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>**<code>i</code>**：直接修改文件，而不是输出到终端。</p>\n</li>\n<li><p><strong><code>r</code></strong> 或 **<code>E</code>**：使用扩展正则表达式。</p>\n</li>\n</ul>\n</li>\n<li><p>常见命令</p>\n<ul>\n<li><p><code>**s**</code>：替换字符</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将文件中的 apple 替换为 banana</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;s/apple/banana/g&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将每行的第一个 apple 替换为 banana</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;s/apple/banana/&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>**d**</code>：删除命令，用于删除文件中的指定行或指定模式。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除匹配模式的行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/pattern/d&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 :10 到 20 行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;10,20d&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除空行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/^$/d&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>**a**</code>：添加命令，用于在文件中的指定行后面添加新的内容。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在匹配模式所在行的下一行添加新的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/pattern/a new line&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在指定行号的下一行添加新的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;3a new line&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>**i**</code>：插入命令，用于在文件中的指定行前面插入新的内容。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在匹配模式所在行的上一行插入新的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/pattern/i new line&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在指定行号的上一行插入新的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;3i new line&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在文件中插入新的文本行：</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;1i\\New Text&#x27;</span> filename</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>**c**</code>：替换命令，用于将指定行替换为新的内容。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将匹配模式所在行替换为新的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/pattern/c new line&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将指定行号替换为新的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;3c new line&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"sed正则表达式用法\"><a href=\"#sed正则表达式用法\" class=\"headerlink\" title=\"sed正则表达式用法\"></a>sed正则表达式用法</h2><ol>\n<li><p>删除文件中的空行：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;/^$/d&#x27;</span> filename</span><br></pre></td></tr></table></figure>\n<p> 使用正则表达式匹配空行（以行首和行尾之间没有任何字符的行），然后使用 <strong><code>d</code></strong> 命令删除这些行。</p>\n</li>\n<li><p>删除文件中的注释行：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;/^#/d&#x27;</span> filename</span><br></pre></td></tr></table></figure>\n<p> 使用正则表达式匹配以 **<code>#</code>**开头的行，然后使用 **<code>d</code>**命令删除这些行。</p>\n</li>\n<li><p>按照指定格式输出文件内容：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;s/\\(.*\\)/&lt;p&gt;\\1&lt;\\/p&gt;/&#x27;</span> filename</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定行前添加#号：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -r <span class=\"string\">&#x27;1,5s/(.*)/#\\1/&#x27;</span> filename</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将文本文件中的每一行都替换为该行的第一个单词：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;s/\\([a-zA-Z]*\\).*/\\1/&#x27;</span> test.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提取文本文件中的URL：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -nE <span class=\"string\">&#x27;s#.*(https?://[^ ]*).*#\\1#p&#x27;</span> test.txt</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"vim中的sed用法\"><a href=\"#vim中的sed用法\" class=\"headerlink\" title=\"vim中的sed用法\"></a>vim中的sed用法</h2><ol>\n<li><p>替换文件中的指定字符串</p>\n<p> 在Vim中，可以使用“:%s&#x2F;old&#x2F;new&#x2F;g”命令来替换文件中的指定字符串，其中“%”表示对整个文件进行操作，“s”表示替换，“&#x2F;”用于分隔替换前、替换后的内容，“g”表示全局替换。</p>\n</li>\n<li><p>删除文件中的指定行</p>\n<p> 在Vim中，可以使用“:g&#x2F;pattern&#x2F;d”命令来删除文件中包含指定字符串的行，其中“g”表示全局匹配，“pattern”表示要匹配的字符串，“d”表示删除操作。</p>\n</li>\n<li><p>在文件中插入指定字符串</p>\n<p> 在Vim中，可以使用“:1,$s&#x2F;^&#x2F;string&#x2F;”命令在文件的每一行前插入指定字符串，其中“1,$”表示对整个文件进行操作，“^”表示行首，“string”表示要插入的字符串。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"sed编辑器定义\"><a href=\"#sed编辑器定义\" class=\"headerlink\" title=\"sed编辑器定义\"></a>sed编辑器定义</h2><p>用于处理文本文件中的数据流。它是一种非交互式的编辑器，可以从标准输入（stdin）或文件中读取输入，然后将文本进行转换、替换、删除、添加等操作，最后将处理后的文本输出到标准输出（stdout）或文件中。它的名字来源于“流编辑器（stream editor）”。</p>\n<h2 id=\"sed编辑器特点\"><a href=\"#sed编辑器特点\" class=\"headerlink\" title=\"sed编辑器特点\"></a>sed编辑器特点</h2><p>与传统的文本编辑器（如vi和emacs）不同，sed对文件进行的修改是非常快速和高效的，因为它不需要打开文件并读取整个文件内容，而是按行处理文件，只处理必要的部分。此外，sed支持正则表达式，可以在文本文件中进行高级搜索和替换操作。</p>\n<h2 id=\"sed编辑器的工作流程\"><a href=\"#sed编辑器的工作流程\" class=\"headerlink\" title=\"sed编辑器的工作流程\"></a>sed编辑器的工作流程</h2><ol>\n<li>一次从输入中读取一行数据</li>\n<li>根据所提供的编辑器命令匹配数据</li>\n<li>按照命令修改流中的数据</li>\n<li>将新的数据输出到STDOUT</li>\n</ol>\n<p>在执行过程中，sed编辑器使用的是基于行的处理方式，即每次处理一行数据。而指令则是根据正则表达式来匹配和处理数据的。通过指令的组合使用，可以实现很多文本处理和编辑的功能，比如替换、删除、插入等操作。</p>\n<h2 id=\"sed编辑器基础\"><a href=\"#sed编辑器基础\" class=\"headerlink\" title=\"sed编辑器基础\"></a>sed编辑器基础</h2><h3 id=\"sed命令格式\"><a href=\"#sed命令格式\" class=\"headerlink\" title=\"sed命令格式\"></a>sed命令格式</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed options <span class=\"string\">&#x27;command&#x27;</span> inputfile</span><br></pre></td></tr></table></figure>\n\n<p>其中，**<code>options</code><strong>是可选项，</strong><code>command</code><strong>是sed命令，</strong><code>inputfile</code><strong>是要处理的文件名。如果不指定</strong><code>inputfile</code>**，sed将从标准输入读取数据。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;s/oldstring/newstring/&#x27;</span> inputfile</span><br></pre></td></tr></table></figure>\n\n<p>其中，**<code>s</code><strong>表示替换操作，</strong><code>oldstring</code><strong>表示要被替换的字符串，</strong><code>newstring</code><strong>表示替换后的字符串，</strong><code>inputfile</code><strong>表示要处理的文件名。此命令将替换文件中的第一个匹配项。如果要替换所有匹配项，则需要使用</strong><code>g</code>**选项，如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;s/oldstring/newstring/g&#x27;</span> inputfile</span><br></pre></td></tr></table></figure>\n\n<p>除了**<code>s</code><strong>命令，sed还有其他命令，如</strong><code>p</code><strong>命令（打印指定的行）、</strong><code>d</code><strong>命令（删除指定的行）、</strong><code>a</code>**命令（在指定行后添加一行文本）等。这些命令可以组合使用，构成一个完整的sed脚本，用于对文本进行复杂的处理。</p>\n<ul>\n<li><p>双引号和单引号的区别</p>\n<p>  在使用 <strong><code>sed</code></strong> 命令时，单引号和双引号的使用是有区别的。在单引号中，所有的特殊字符都会被视为普通字符，而在双引号中，除了 <strong><code>$</code></strong> 和**&#96;&#96;&#96;**之外，其他的特殊字符都会被视为普通字符。</p>\n<p>  具体来说，在单引号中，变量和命令替换不会被执行，而在双引号中，会先进行变量和命令替换，然后再执行 <strong><code>sed</code></strong> 命令。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ name=<span class=\"string\">&quot;universe&quot;</span></span><br><span class=\"line\">$ sed <span class=\"string\">&quot;s/world/<span class=\"variable\">$name</span>/&quot;</span> test.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常见选项</p>\n<ul>\n<li><p>**<code>n</code>**：取消默认输出，使用print命令完成输出。</p>\n</li>\n<li><p>**<code>e</code>**：允许多个 sed 命令被执行。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -e <span class=\"string\">&#x27;s/apple/orange/g&#x27;</span> -e <span class=\"string\">&#x27;s/\\s*$//&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>**<code>f</code>**：指定 sed 命令文件。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -f commands.sed file.txt</span><br></pre></td></tr></table></figure>\n<p>  commands.sed文件内容：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/Hello/Hi/</span><br><span class=\"line\">s/World/There/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>**<code>i</code>**：直接修改文件，而不是输出到终端。</p>\n</li>\n<li><p><strong><code>r</code></strong> 或 **<code>E</code>**：使用扩展正则表达式。</p>\n</li>\n</ul>\n</li>\n<li><p>常见命令</p>\n<ul>\n<li><p><code>**s**</code>：替换字符</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将文件中的 apple 替换为 banana</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;s/apple/banana/g&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将每行的第一个 apple 替换为 banana</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;s/apple/banana/&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>**d**</code>：删除命令，用于删除文件中的指定行或指定模式。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除匹配模式的行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/pattern/d&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 :10 到 20 行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;10,20d&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除空行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/^$/d&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>**a**</code>：添加命令，用于在文件中的指定行后面添加新的内容。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在匹配模式所在行的下一行添加新的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/pattern/a new line&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在指定行号的下一行添加新的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;3a new line&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>**i**</code>：插入命令，用于在文件中的指定行前面插入新的内容。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在匹配模式所在行的上一行插入新的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/pattern/i new line&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在指定行号的上一行插入新的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;3i new line&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在文件中插入新的文本行：</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;1i\\New Text&#x27;</span> filename</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>**c**</code>：替换命令，用于将指定行替换为新的内容。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将匹配模式所在行替换为新的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/pattern/c new line&#x27;</span> file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将指定行号替换为新的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;3c new line&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"sed正则表达式用法\"><a href=\"#sed正则表达式用法\" class=\"headerlink\" title=\"sed正则表达式用法\"></a>sed正则表达式用法</h2><ol>\n<li><p>删除文件中的空行：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;/^$/d&#x27;</span> filename</span><br></pre></td></tr></table></figure>\n<p> 使用正则表达式匹配空行（以行首和行尾之间没有任何字符的行），然后使用 <strong><code>d</code></strong> 命令删除这些行。</p>\n</li>\n<li><p>删除文件中的注释行：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;/^#/d&#x27;</span> filename</span><br></pre></td></tr></table></figure>\n<p> 使用正则表达式匹配以 **<code>#</code>**开头的行，然后使用 **<code>d</code>**命令删除这些行。</p>\n</li>\n<li><p>按照指定格式输出文件内容：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;s/\\(.*\\)/&lt;p&gt;\\1&lt;\\/p&gt;/&#x27;</span> filename</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定行前添加#号：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -r <span class=\"string\">&#x27;1,5s/(.*)/#\\1/&#x27;</span> filename</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将文本文件中的每一行都替换为该行的第一个单词：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;s/\\([a-zA-Z]*\\).*/\\1/&#x27;</span> test.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提取文本文件中的URL：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -nE <span class=\"string\">&#x27;s#.*(https?://[^ ]*).*#\\1#p&#x27;</span> test.txt</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"vim中的sed用法\"><a href=\"#vim中的sed用法\" class=\"headerlink\" title=\"vim中的sed用法\"></a>vim中的sed用法</h2><ol>\n<li><p>替换文件中的指定字符串</p>\n<p> 在Vim中，可以使用“:%s&#x2F;old&#x2F;new&#x2F;g”命令来替换文件中的指定字符串，其中“%”表示对整个文件进行操作，“s”表示替换，“&#x2F;”用于分隔替换前、替换后的内容，“g”表示全局替换。</p>\n</li>\n<li><p>删除文件中的指定行</p>\n<p> 在Vim中，可以使用“:g&#x2F;pattern&#x2F;d”命令来删除文件中包含指定字符串的行，其中“g”表示全局匹配，“pattern”表示要匹配的字符串，“d”表示删除操作。</p>\n</li>\n<li><p>在文件中插入指定字符串</p>\n<p> 在Vim中，可以使用“:1,$s&#x2F;^&#x2F;string&#x2F;”命令在文件的每一行前插入指定字符串，其中“1,$”表示对整个文件进行操作，“^”表示行首，“string”表示要插入的字符串。</p>\n</li>\n</ol>\n"},{"title":"第一周","date":"2023-06-09T03:31:25.000Z","_content":"\n## 名词解释\n\n1. 高级语言、低级语言、机器语言\n    1. 高级语言（High-Level Language）：\n    高级语言是一种相对抽象和易于理解的编程语言，其目的是提供更高层次的抽象和功能，使程序员能够更容易地编写复杂的程序。高级语言使用人类可读的语法和结构，使用更高级别的概念和抽象，使得程序的编写更容易、更快速。高级语言通常需要通过编译或解释器转换为机器语言才能在计算机上执行。常见的高级语言包括C、C++、Java、Python和JavaScript等。\n    2. 低级语言（Low-Level Language）：\n    低级语言是与计算机硬件更接近的编程语言，它使用更接近机器语言的语法和结构。低级语言通常直接操作计算机的底层硬件和资源，提供了对硬件细节的更多控制。低级语言可以更高效地利用计算机的资源，但编写和理解低级语言程序相对更困难。汇编语言和机器语言都属于低级语言。\n    3. 机器语言（Machine Language）：\n    机器语言是计算机硬件直接能理解和执行的语言。它由二进制位组成，表示计算机指令和数据。机器语言是计算机可以直接执行的最底层的语言。每个计算机的机器语言是特定于该计算机体系结构的。编写机器语言程序需要对机器指令和二进制表示有深入的了解。由于机器语言的复杂性和难以理解，通常使用高级语言来编写程序，然后通过编译器或解释器将其转换为机器语言。\n\n2. 解释型语言和编译型语\n\n    ![1.第一周-2023-06-09-10-53-51](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-10-53-51.png)\n\n    Python 如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得 Python 程序相较于 C 程序而言更加易于移植。\n\n3. C语言源代码到可执行文件的过程\n\n    1. C源代码：\n    程序员使用C语言编写源代码，源代码以**`.c`**为扩展名。源代码包含了程序的逻辑和功能的定义。\n    2. 预处理：\n    在编译之前，C预处理器会处理源代码。预处理器执行宏展开、条件编译等操作，生成经过预处理的源代码。\n    3. 编译：\n    经过预处理的源代码会被编译器翻译成汇编代码。编译器将C源代码转换为汇编语言表示，生成汇编代码文件（**`.s`**文件）。\n    4. 汇编：\n    汇编器将汇编代码转换为机器码指令。它将汇编代码文件翻译成机器可执行的指令，并生成目标文件（**`.o`**文件）。\n    5. 链接：\n    链接器将目标文件与其他必要的库文件进行链接，生成最终的可执行文件。链接器解析目标文件中的符号引用，并将其与库函数和其他目标文件中的符号定义进行关联。链接器生成一个包含所有必要信息的可执行文件。\n    6. 可执行文件：\n    最终的可执行文件是操作系统可以直接执行的二进制文件。它包含了程序的机器码指令、数据和其他必要的信息。可执行文件可以通过命令行或操作系统的运行环境来执行。\n\n4. 静态语言和动态语言\n\n    1. 静态语言（Static Language）：\n    静态语言是在编译时进行类型检查的语言。在静态语言中，变量的类型在编译时确定，并且编译器会对类型进行检查。在编译过程中，变量的类型和使用方法需要在代码中明确声明和定义。静态语言的编译器会检查变量的类型是否与其使用方式相匹配，以避免类型错误。常见的静态语言包括C、C++、Java等。\n\n        优点：\n        1. 更早地发现类型错误，提前检测潜在的编程错误。\n        2. 在编译时进行类型检查，提高代码的稳定性和可靠性。\n        3. 性能较好，由于类型已经确定，编译器可以进行更多的优化。\n\n        缺点：\n        1. 代码相对冗长，需要显式声明和定义类型。\n        2. 编译时间较长，需要进行较多的类型检查和编译过程。\n\n    2. 动态语言（Dynamic Language）：\n    动态语言是在运行时进行类型检查的语言。在动态语言中，变量的类型可以根据其赋值进行推断，并且可以在运行时动态地改变变量的类型。动态语言的编译器或解释器在运行时进行类型检查和解析。常见的动态语言包括Python、JavaScript、Ruby等。\n\n        优点：\n\n        1. 灵活性高，可以在运行时动态地改变变量的类型和行为。\n        2. 代码相对简洁，无需显式声明和定义类型，灵活性提高了开发效率。\n\n        缺点：\n\n        1. 需要在运行时进行类型检查和解析，性能可能相对较低。\n        2. 容易出现运行时类型错误，只能在运行时才能发现。\n\n    需要注意的是，静态语言和动态语言并非绝对的对立关系，很多语言在某些方面可以具备静态语言和动态语言的特性。例如，Java是静态语言，但具备一些动态语言的特性，如反射和动态代理。同样，Python是动态语言，但也可以通过类型注解等方式实现静态类型检查。\n\n## C语言开发环境\n\n1. 在线运行平台（一键运行）：\n    1. [https://www.nhooo.com/tool/c/](https://www.nhooo.com/tool/c/)\n    2. [https://www.bejson.com/runcode/c740/](https://www.bejson.com/runcode/c740/)\n2. IDE（集成开发环境）：\n    1. Visual Studio（一站式安装，一键编译运行）\n\n        [Visual Studio下载地址](https://visualstudio.microsoft.com/zh-hans/)，[中文安装教程](https://zhuanlan.zhihu.com/p/71110525)\n\n    2. VSCode + mingw（配置灵活且繁琐，一键编译运行）\n\n        [VSCode下载地址，](https://code.visualstudio.com/download)[mingw下载地址](https://github.com/msys2/msys2-installer/releases/download/2023-05-26/msys2-x86_64-20230526.exe)，[使用教程](https://zhuanlan.zhihu.com/p/354400717)\n\n3. Linux环境（vim+gcc）\n\n    编译命令`gcc -o 目标文件名 源文件`\n\n    例：`gcc -o test test.c` 将名为`test.c`的源文件编译成名为`test`的目标文件\n\n## C语言程序的结构\n\n- 简单的C程序实例\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void)\n    {\n        /* 定义一个名为num的变量 */\n        int num;\n        /* 为num赋一个值 */\n        num = 1;\n    \n        /* 使用printf()函数 */\n        printf(\"I am a simple \");\n        printf(\"computer.\\n\");\n        printf(\"My favorite number is %d because it is first.\\n\", num);\n    \n        return 0;\n    }\n    ```\n\n1. `#include`指令和头文件\n\n    `#include`这行代码是一条C预处理器指令。通常，C编译器在编译前会对源代码做一些准备工作，即预处理。\n\n    `#include <stdio.h>`的作用相当于把`stdio.h`文件中的所有内容都输入该行所在的位置。实际上，这是一种“拷贝-粘贴”的操作。\n\n2. `main()`函数\n\n    C程序从`main()`函数开始执行。除了`main()`函数，你可以任意命名其他函数，而且main()函数必须是开始的函数。`int`是main()函数的返回类型。这表明main()函数返回的值是整数。返回到哪里？返回给操作系统通常，函数名后面的圆括号中包含一些传入函数的信息。该例中没有传递任何信息。因此，圆括号内是单词`void` 。\n\n    ```c\n    //错误的main函数定义1\n    main()\n    \n    //错误的main函数定义2\n    void main()\n    \n    //正确的main函数定义1\n    int main(void)\n    \n    //正确的main函数定义2\n    int main(int argc, char *argv[])\n    ```\n\n    **`int main(int argc, char *argv[])`** 是C语言中常见的**`main`**函数的定义方式，它用于接收命令行参数。\n\n    参数解释：\n\n    - **`int argc`**：表示命令行参数的数量（Argument Count）。\n    - **`char *argv[]`**：表示命令行参数的数组（Argument Vector），是一个指针数组，每个指针指向一个以null结尾的字符串，即命令行参数的值。\n\n    使用这种方式定义的**`main`**函数可以接收命令行传递的参数，如下所示：\n\n    ```c\n    #include <stdio.h>\n    \n    int main(int argc, char *argv[]) {\n        printf(\"argc: %d\\n\", argc);\n    \n        for (int i = 0; i < argc; i++) {\n            printf(\"argv[%d]: %s\\n\", i, argv[i]);\n        }\n    \n        return 0;\n    }\n    ```\n\n    运行该程序并传递参数，例如：\n\n    ```bash\n    ./program arg1 arg2 arg3\n    ```\n\n    程序运行结果会输出命令行参数的数量以及每个参数的值，如：\n\n    ```text\n    argc: 4\n    argv[0]: ./program\n    argv[1]: arg1\n    argv[2]: arg2\n    argv[3]: arg3\n    ```\n\n3. 注释\n\n    在程序中，被两个`/* */`符号括起来的部分是程序的注释。写注释能让他人（包括自己）更容易明白你所写的程序。C 语言注释的好处之一是，可将注释放在任意的地方，甚至是与要解释的内容在同一行。较长的注释可单独放一行或多行。所有的注释都会被编译器忽略。\n\n    ```c\n    /* 这是一条C注释。 */\n    /* 这也是一条注释，\n    被分成两行。*/\n    /*\n    也可以这样写注释。\n    */\n    /* 这条注释无效，因为缺少了结束标记。\n    \n    // 这种注释只能写成一行\n    ```\n\n4. 花括号、函数体和块\n\n    花括号把main()函数括起来。一般而言，所有的C函数都使用`花括号`标记`函数体的开始和结束`。这是规定，不能省略。只有花括号（{}）能起这种作用，圆括号（()）和方括号（[]）都不行。花括号还可用于把函数中的多条语句`合并`为一个`单元或块`。\n\n5. 声明（declaration）\n\n    声明是C语言最重要的特性之一。在该例中，声明完成了两件事。其一，在函数中有一个名为\n    num的变量（`variable`）。其二，`int`表明`num`是一个`整数`（即，没有小数点或小数部分的数）。`int`是一种数据类型。编译器使用这些信息为`num`变量在内存中分配存储空间。\n\n6. 赋值\n\n    赋值是C语言的基本操作之一。该行代码的意思是“把值1赋给变量num”。在执行int num;声明时，编译器在计算机内存中为变量num预留了空间，然后在执行这行赋值表达式语句时，把值储存在之前预留的位置。可以给num赋不同的值，这就是num之所以被称为变量（variable）的原因。\n\n7. `printf()`函数\n\n    示例代码中有3行代码都使用了C语言的一个标准函数：`printf()`。圆括号表明printf是一个函数名。圆括号中的内容是从main()函数传递给printf()函数的信息。例如，上面的第1行把`I am a simple`传递给printf()函数。该信息被称为参数。\n\n    换行符是一个转义序列（escape sequence）。转义序列用于代表难以表示或无法输入的字符。如，\\t代表Tab键，\\b代表Backspace键（退格键）。每个转义序列都以反斜杠字符（\\）开始\n\n8. `return`语句\n\n    return语句是示例程序中的最后一条语句。`int main(void)`中的int表明main()函数应返回一个`整数`。C标准要求main()这样做。有返回值的C函数要有return语句。该语句以return关键字开始，后面是待返回的值，并以分号结尾。如果遗漏 main()函数中的 return 语句，程序在运行至最外面的右花括号（}）时会返回0。因此，可以省略main()函数末尾的return语句。但是，不要在其他有返回值的函数中漏掉它。\n\n## C语言源程序的书写格式\n\n1. 缩进：使用适当的缩进来表示代码块的层次结构，常见的缩进为4个空格或一个制表符（Tab）。\n2. 大括号：对于控制结构、函数等代码块，使用大括号将其括起来，以表示代码块的开始和结束。\n\n    ```c\n    if (condition) {\n        // 代码块\n        // ...\n    }\n    ```\n\n3. 空格：在运算符、逗号、分号等符号周围添加适当的空格，以提高代码的可读性。\n\n    ```c\n    int sum = a + b;\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", i);\n    }\n    ```\n\n4. 注释：使用注释来解释代码的功能、目的、算法等，以增加代码的可读性和可维护性。\n\n    ```c\n    // 计算两个数的和\n    int sum = a + b;\n    ```\n\n5. 命名规范：使用有意义的变量名、函数名和常量名，遵循命名规范，以提高代码的可读性和可维护性。\n\n    ```c\n    int numberOfStudents = 10;\n    void printMessage() {\n        // 函数体\n    }\n    ```\n\n6. 换行：在较长的语句中，适当地进行换行，以保持代码的可读性。\n\n    ```c\n    longResult = (longValue1 + longValue2 + longValue3) /\n                 (longValue4 - longValue5);\n    ```\n\n## C语言数据类型\n\n1. 整型（Integer）：\n    - **`int`**：表示整数类型。通常占用4个字节。\n    - **`short`**：表示短整数类型。通常占用2个字节。\n    - **`long`**：表示长整数类型。通常占用4个或8个字节，取决于编译器和操作系统。\n\n    示例代码：\n\n    ```c\n    int num1 = 10;\n    short num2 = 20;\n    long num3 = 30L;  // 后缀L表示长整数类型\n    ```\n\n2. 浮点型（Floating-point）：\n    - **`float`**：表示单精度浮点数类型。通常占用4个字节。\n    - **`double`**：表示双精度浮点数类型。通常占用8个字节。\n\n    示例代码：\n\n    ```c\n    float num1 = 3.14f;  // 后缀f表示单精度浮点数类型\n    double num2 = 2.71828;\n    ```\n\n3. 字符型（Character）：\n    - **`char`**：表示字符类型。通常占用1个字节。\n\n    示例代码：\n\n    ```c\n    char ch1 = 'A';\n    char ch2 = 'B';\n    ```\n\n4. 布尔型（Boolean）：\n    - **`bool`**：表示布尔类型，只能取**`true`**（非零值）或**`false`**（零值）。\n\n    示例代码：\n\n    ```c\n    #include <stdbool.h>  // 需要包含stdbool.h头文件\n    \n    bool flag1 = true;\n    bool flag2 = false;\n    ```\n\n\n### 数据类型示例代码\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n\nint main(void) {\n    // 整型示例\n    int num1 = 10;\n    printf(\"整数num1 = %d，整型大小: %u 字节\\n\", num1, sizeof(num1));\n\n    short num2 = 20;\n    printf(\"短整数num2 = %hd，短整数大小: %u 字节\\n\", num2, sizeof(num2));\n\n    long num3 = 30L;\n    printf(\"长整数num3 = %ld，长整数大小: %u 字节\\n\", num3, sizeof(num3));\n\n    // 浮点型示例\n    float num4 = 3.14f;\n    printf(\"单精度浮点数num4 = %f，单精度浮点数大小: %u 字节\\n\", num4, sizeof(num4));\n\n    double num5 = 2.71828;\n    printf(\"双精度浮点数num5 = %lf，双精度浮点数大小: %u 字节\\n\", num5, sizeof(num5));\n\n    // 字符型示例\n    char ch1 = 'A';\n    printf(\"字符ch1 = %c，字符大小: %u 字节\\n\", ch1, sizeof(ch1));\n\n    char ch2 = 66;  // ASCII码值\n    printf(\"字符ch2 = %c，字符大小: %u 字节\\n\", ch2, sizeof(ch2));\n\n    // 布尔型示例\n    bool flag1 = true;\n    printf(\"布尔数flag1 = %d，布尔值大小: %u 字节\\n\", flag1, sizeof(flag1));\n\n    bool flag2 = false;\n    printf(\"布尔数flag2 = %d，布尔值大小: %u 字节\\n\", flag2, sizeof(flag2));\n\n    return 0;\n}\n```\n\n## C语言的运算符\n\nC语言中有多种类型的运算符，用于执行各种算术、逻辑和位操作。以下是C语言中常见的运算符类型：\n\n1. 算术运算符：用于执行基本的算术操作，如加法、减法、乘法、除法、取模等。\n    - **`+`**：加法运算\n    - `-`：减法运算\n    - *：乘法运算\n    - **`/`**：除法运算\n    - **`%`**：取模（取余）运算\n2. 关系运算符：用于比较两个值之间的关系，返回一个布尔值（1表示真，0表示假）。\n    - **`==`**：等于\n    - **`!=`**：不等于\n    - **`<`**：小于\n    - **`>`**：大于\n    - **`<=`**：小于等于\n    - **`>=`**：大于等于\n3. 逻辑运算符：用于执行逻辑操作，对布尔值进行组合和求反。\n    - **`&&`**：逻辑与（与）\n    - **`||`**：逻辑或（或）\n    - **`!`**：逻辑非（非）\n4. 位运算符：用于对二进制数据的位进行操作。\n    - **`&`**：按位与\n    - **`|`**：按位或\n    - **`^`**：按位异或\n    - **`~`**：按位取反\n    - **`<<`**：左移\n    - **`>>`**：右移\n5. 赋值运算符：用于给变量赋值。\n    - **`=`**：简单赋值\n    - **`+=`**：加法赋值\n    - **`=`**：减法赋值\n    - **`=`**：乘法赋值\n    - **`/=`**：除法赋值\n    - **`%=`**：取模赋值\n    - **`<<=`**：左移赋值\n    - **`>>=`**：右移赋值\n    - **`&=`**：按位与赋值\n    - **`|=`**：按位或赋值\n    - **`^=`**：按位异或赋值\n6. 自增和自减运算符：用于对变量进行递增或递减操作。\n    - **`++`**：自增\n    - **`-`**：自减\n7. 条件运算符：用于根据条件选择不同的值。\n    - **`? :`**：条件表达式，也称为三元运算符。\n8. 其他运算符：还有一些其他类型的运算符，如指针运算符、sizeof运算符、类型转换运算符等。\n\n### 运算符优先级\n\n![1.第一周-2023-06-09-11-36-00](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-00.png)\n\n![1.第一周-2023-06-09-11-36-08](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-08.png)\n\n![1.第一周-2023-06-09-11-36-21](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-21.png)\n\n### 运算符优先级示例代码\n\n```\n#include <stdio.h>\n\nint main() {\n    int a = 5, b = 3, c = 7;\n    int result1 = a + b * c;        // 5 + 3 * 7 = 26\n    int result2 = (a + b) * c;      // (5 + 3) * 7 = 56\n    int result3 = a * b / c;        // 5 * 3 / 7 = 2\n    int result4 = a * (b / c);      // 5 * (3 / 7) = 0\n    int result5 = a % b + c;        // 5 % 3 + 7 = 9\n    int result6 = a << b + c;       // 5 << (3 + 7) = 512\n    int result7 = (a << b) + c;     // (5 << 3) + 7 = 47\n    int result8 = a < b && b < c;   // 5 < 3 && 3 < 7 = 0 (false)\n    int result9 = a < b || b < c;   // 5 < 3 || 3 < 7 = 1 (true)\n    int result10 = a == b ? c : a;  // 5 == 3 ? 7 : 5 = 5\n\n    printf(\"Result 1: %d\\n\", result1);\n    printf(\"Result 2: %d\\n\", result2);\n    printf(\"Result 3: %d\\n\", result3);\n    printf(\"Result 4: %d\\n\", result4);\n    printf(\"Result 5: %d\\n\", result5);\n    printf(\"Result 6: %d\\n\", result6);\n    printf(\"Result 7: %d\\n\", result7);\n    printf(\"Result 8: %d\\n\", result8);\n    printf(\"Result 9: %d\\n\", result9);\n    printf(\"Result 10: %d\\n\", result10);\n\n    return 0;\n}\n```\n","source":"_posts/c_program/1.第一周.md","raw":"---\ntitle: 第一周\ndate: 2023-06-09 11:31:25\ntags: \n---\n\n## 名词解释\n\n1. 高级语言、低级语言、机器语言\n    1. 高级语言（High-Level Language）：\n    高级语言是一种相对抽象和易于理解的编程语言，其目的是提供更高层次的抽象和功能，使程序员能够更容易地编写复杂的程序。高级语言使用人类可读的语法和结构，使用更高级别的概念和抽象，使得程序的编写更容易、更快速。高级语言通常需要通过编译或解释器转换为机器语言才能在计算机上执行。常见的高级语言包括C、C++、Java、Python和JavaScript等。\n    2. 低级语言（Low-Level Language）：\n    低级语言是与计算机硬件更接近的编程语言，它使用更接近机器语言的语法和结构。低级语言通常直接操作计算机的底层硬件和资源，提供了对硬件细节的更多控制。低级语言可以更高效地利用计算机的资源，但编写和理解低级语言程序相对更困难。汇编语言和机器语言都属于低级语言。\n    3. 机器语言（Machine Language）：\n    机器语言是计算机硬件直接能理解和执行的语言。它由二进制位组成，表示计算机指令和数据。机器语言是计算机可以直接执行的最底层的语言。每个计算机的机器语言是特定于该计算机体系结构的。编写机器语言程序需要对机器指令和二进制表示有深入的了解。由于机器语言的复杂性和难以理解，通常使用高级语言来编写程序，然后通过编译器或解释器将其转换为机器语言。\n\n2. 解释型语言和编译型语\n\n    ![1.第一周-2023-06-09-10-53-51](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-10-53-51.png)\n\n    Python 如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得 Python 程序相较于 C 程序而言更加易于移植。\n\n3. C语言源代码到可执行文件的过程\n\n    1. C源代码：\n    程序员使用C语言编写源代码，源代码以**`.c`**为扩展名。源代码包含了程序的逻辑和功能的定义。\n    2. 预处理：\n    在编译之前，C预处理器会处理源代码。预处理器执行宏展开、条件编译等操作，生成经过预处理的源代码。\n    3. 编译：\n    经过预处理的源代码会被编译器翻译成汇编代码。编译器将C源代码转换为汇编语言表示，生成汇编代码文件（**`.s`**文件）。\n    4. 汇编：\n    汇编器将汇编代码转换为机器码指令。它将汇编代码文件翻译成机器可执行的指令，并生成目标文件（**`.o`**文件）。\n    5. 链接：\n    链接器将目标文件与其他必要的库文件进行链接，生成最终的可执行文件。链接器解析目标文件中的符号引用，并将其与库函数和其他目标文件中的符号定义进行关联。链接器生成一个包含所有必要信息的可执行文件。\n    6. 可执行文件：\n    最终的可执行文件是操作系统可以直接执行的二进制文件。它包含了程序的机器码指令、数据和其他必要的信息。可执行文件可以通过命令行或操作系统的运行环境来执行。\n\n4. 静态语言和动态语言\n\n    1. 静态语言（Static Language）：\n    静态语言是在编译时进行类型检查的语言。在静态语言中，变量的类型在编译时确定，并且编译器会对类型进行检查。在编译过程中，变量的类型和使用方法需要在代码中明确声明和定义。静态语言的编译器会检查变量的类型是否与其使用方式相匹配，以避免类型错误。常见的静态语言包括C、C++、Java等。\n\n        优点：\n        1. 更早地发现类型错误，提前检测潜在的编程错误。\n        2. 在编译时进行类型检查，提高代码的稳定性和可靠性。\n        3. 性能较好，由于类型已经确定，编译器可以进行更多的优化。\n\n        缺点：\n        1. 代码相对冗长，需要显式声明和定义类型。\n        2. 编译时间较长，需要进行较多的类型检查和编译过程。\n\n    2. 动态语言（Dynamic Language）：\n    动态语言是在运行时进行类型检查的语言。在动态语言中，变量的类型可以根据其赋值进行推断，并且可以在运行时动态地改变变量的类型。动态语言的编译器或解释器在运行时进行类型检查和解析。常见的动态语言包括Python、JavaScript、Ruby等。\n\n        优点：\n\n        1. 灵活性高，可以在运行时动态地改变变量的类型和行为。\n        2. 代码相对简洁，无需显式声明和定义类型，灵活性提高了开发效率。\n\n        缺点：\n\n        1. 需要在运行时进行类型检查和解析，性能可能相对较低。\n        2. 容易出现运行时类型错误，只能在运行时才能发现。\n\n    需要注意的是，静态语言和动态语言并非绝对的对立关系，很多语言在某些方面可以具备静态语言和动态语言的特性。例如，Java是静态语言，但具备一些动态语言的特性，如反射和动态代理。同样，Python是动态语言，但也可以通过类型注解等方式实现静态类型检查。\n\n## C语言开发环境\n\n1. 在线运行平台（一键运行）：\n    1. [https://www.nhooo.com/tool/c/](https://www.nhooo.com/tool/c/)\n    2. [https://www.bejson.com/runcode/c740/](https://www.bejson.com/runcode/c740/)\n2. IDE（集成开发环境）：\n    1. Visual Studio（一站式安装，一键编译运行）\n\n        [Visual Studio下载地址](https://visualstudio.microsoft.com/zh-hans/)，[中文安装教程](https://zhuanlan.zhihu.com/p/71110525)\n\n    2. VSCode + mingw（配置灵活且繁琐，一键编译运行）\n\n        [VSCode下载地址，](https://code.visualstudio.com/download)[mingw下载地址](https://github.com/msys2/msys2-installer/releases/download/2023-05-26/msys2-x86_64-20230526.exe)，[使用教程](https://zhuanlan.zhihu.com/p/354400717)\n\n3. Linux环境（vim+gcc）\n\n    编译命令`gcc -o 目标文件名 源文件`\n\n    例：`gcc -o test test.c` 将名为`test.c`的源文件编译成名为`test`的目标文件\n\n## C语言程序的结构\n\n- 简单的C程序实例\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void)\n    {\n        /* 定义一个名为num的变量 */\n        int num;\n        /* 为num赋一个值 */\n        num = 1;\n    \n        /* 使用printf()函数 */\n        printf(\"I am a simple \");\n        printf(\"computer.\\n\");\n        printf(\"My favorite number is %d because it is first.\\n\", num);\n    \n        return 0;\n    }\n    ```\n\n1. `#include`指令和头文件\n\n    `#include`这行代码是一条C预处理器指令。通常，C编译器在编译前会对源代码做一些准备工作，即预处理。\n\n    `#include <stdio.h>`的作用相当于把`stdio.h`文件中的所有内容都输入该行所在的位置。实际上，这是一种“拷贝-粘贴”的操作。\n\n2. `main()`函数\n\n    C程序从`main()`函数开始执行。除了`main()`函数，你可以任意命名其他函数，而且main()函数必须是开始的函数。`int`是main()函数的返回类型。这表明main()函数返回的值是整数。返回到哪里？返回给操作系统通常，函数名后面的圆括号中包含一些传入函数的信息。该例中没有传递任何信息。因此，圆括号内是单词`void` 。\n\n    ```c\n    //错误的main函数定义1\n    main()\n    \n    //错误的main函数定义2\n    void main()\n    \n    //正确的main函数定义1\n    int main(void)\n    \n    //正确的main函数定义2\n    int main(int argc, char *argv[])\n    ```\n\n    **`int main(int argc, char *argv[])`** 是C语言中常见的**`main`**函数的定义方式，它用于接收命令行参数。\n\n    参数解释：\n\n    - **`int argc`**：表示命令行参数的数量（Argument Count）。\n    - **`char *argv[]`**：表示命令行参数的数组（Argument Vector），是一个指针数组，每个指针指向一个以null结尾的字符串，即命令行参数的值。\n\n    使用这种方式定义的**`main`**函数可以接收命令行传递的参数，如下所示：\n\n    ```c\n    #include <stdio.h>\n    \n    int main(int argc, char *argv[]) {\n        printf(\"argc: %d\\n\", argc);\n    \n        for (int i = 0; i < argc; i++) {\n            printf(\"argv[%d]: %s\\n\", i, argv[i]);\n        }\n    \n        return 0;\n    }\n    ```\n\n    运行该程序并传递参数，例如：\n\n    ```bash\n    ./program arg1 arg2 arg3\n    ```\n\n    程序运行结果会输出命令行参数的数量以及每个参数的值，如：\n\n    ```text\n    argc: 4\n    argv[0]: ./program\n    argv[1]: arg1\n    argv[2]: arg2\n    argv[3]: arg3\n    ```\n\n3. 注释\n\n    在程序中，被两个`/* */`符号括起来的部分是程序的注释。写注释能让他人（包括自己）更容易明白你所写的程序。C 语言注释的好处之一是，可将注释放在任意的地方，甚至是与要解释的内容在同一行。较长的注释可单独放一行或多行。所有的注释都会被编译器忽略。\n\n    ```c\n    /* 这是一条C注释。 */\n    /* 这也是一条注释，\n    被分成两行。*/\n    /*\n    也可以这样写注释。\n    */\n    /* 这条注释无效，因为缺少了结束标记。\n    \n    // 这种注释只能写成一行\n    ```\n\n4. 花括号、函数体和块\n\n    花括号把main()函数括起来。一般而言，所有的C函数都使用`花括号`标记`函数体的开始和结束`。这是规定，不能省略。只有花括号（{}）能起这种作用，圆括号（()）和方括号（[]）都不行。花括号还可用于把函数中的多条语句`合并`为一个`单元或块`。\n\n5. 声明（declaration）\n\n    声明是C语言最重要的特性之一。在该例中，声明完成了两件事。其一，在函数中有一个名为\n    num的变量（`variable`）。其二，`int`表明`num`是一个`整数`（即，没有小数点或小数部分的数）。`int`是一种数据类型。编译器使用这些信息为`num`变量在内存中分配存储空间。\n\n6. 赋值\n\n    赋值是C语言的基本操作之一。该行代码的意思是“把值1赋给变量num”。在执行int num;声明时，编译器在计算机内存中为变量num预留了空间，然后在执行这行赋值表达式语句时，把值储存在之前预留的位置。可以给num赋不同的值，这就是num之所以被称为变量（variable）的原因。\n\n7. `printf()`函数\n\n    示例代码中有3行代码都使用了C语言的一个标准函数：`printf()`。圆括号表明printf是一个函数名。圆括号中的内容是从main()函数传递给printf()函数的信息。例如，上面的第1行把`I am a simple`传递给printf()函数。该信息被称为参数。\n\n    换行符是一个转义序列（escape sequence）。转义序列用于代表难以表示或无法输入的字符。如，\\t代表Tab键，\\b代表Backspace键（退格键）。每个转义序列都以反斜杠字符（\\）开始\n\n8. `return`语句\n\n    return语句是示例程序中的最后一条语句。`int main(void)`中的int表明main()函数应返回一个`整数`。C标准要求main()这样做。有返回值的C函数要有return语句。该语句以return关键字开始，后面是待返回的值，并以分号结尾。如果遗漏 main()函数中的 return 语句，程序在运行至最外面的右花括号（}）时会返回0。因此，可以省略main()函数末尾的return语句。但是，不要在其他有返回值的函数中漏掉它。\n\n## C语言源程序的书写格式\n\n1. 缩进：使用适当的缩进来表示代码块的层次结构，常见的缩进为4个空格或一个制表符（Tab）。\n2. 大括号：对于控制结构、函数等代码块，使用大括号将其括起来，以表示代码块的开始和结束。\n\n    ```c\n    if (condition) {\n        // 代码块\n        // ...\n    }\n    ```\n\n3. 空格：在运算符、逗号、分号等符号周围添加适当的空格，以提高代码的可读性。\n\n    ```c\n    int sum = a + b;\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", i);\n    }\n    ```\n\n4. 注释：使用注释来解释代码的功能、目的、算法等，以增加代码的可读性和可维护性。\n\n    ```c\n    // 计算两个数的和\n    int sum = a + b;\n    ```\n\n5. 命名规范：使用有意义的变量名、函数名和常量名，遵循命名规范，以提高代码的可读性和可维护性。\n\n    ```c\n    int numberOfStudents = 10;\n    void printMessage() {\n        // 函数体\n    }\n    ```\n\n6. 换行：在较长的语句中，适当地进行换行，以保持代码的可读性。\n\n    ```c\n    longResult = (longValue1 + longValue2 + longValue3) /\n                 (longValue4 - longValue5);\n    ```\n\n## C语言数据类型\n\n1. 整型（Integer）：\n    - **`int`**：表示整数类型。通常占用4个字节。\n    - **`short`**：表示短整数类型。通常占用2个字节。\n    - **`long`**：表示长整数类型。通常占用4个或8个字节，取决于编译器和操作系统。\n\n    示例代码：\n\n    ```c\n    int num1 = 10;\n    short num2 = 20;\n    long num3 = 30L;  // 后缀L表示长整数类型\n    ```\n\n2. 浮点型（Floating-point）：\n    - **`float`**：表示单精度浮点数类型。通常占用4个字节。\n    - **`double`**：表示双精度浮点数类型。通常占用8个字节。\n\n    示例代码：\n\n    ```c\n    float num1 = 3.14f;  // 后缀f表示单精度浮点数类型\n    double num2 = 2.71828;\n    ```\n\n3. 字符型（Character）：\n    - **`char`**：表示字符类型。通常占用1个字节。\n\n    示例代码：\n\n    ```c\n    char ch1 = 'A';\n    char ch2 = 'B';\n    ```\n\n4. 布尔型（Boolean）：\n    - **`bool`**：表示布尔类型，只能取**`true`**（非零值）或**`false`**（零值）。\n\n    示例代码：\n\n    ```c\n    #include <stdbool.h>  // 需要包含stdbool.h头文件\n    \n    bool flag1 = true;\n    bool flag2 = false;\n    ```\n\n\n### 数据类型示例代码\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n\nint main(void) {\n    // 整型示例\n    int num1 = 10;\n    printf(\"整数num1 = %d，整型大小: %u 字节\\n\", num1, sizeof(num1));\n\n    short num2 = 20;\n    printf(\"短整数num2 = %hd，短整数大小: %u 字节\\n\", num2, sizeof(num2));\n\n    long num3 = 30L;\n    printf(\"长整数num3 = %ld，长整数大小: %u 字节\\n\", num3, sizeof(num3));\n\n    // 浮点型示例\n    float num4 = 3.14f;\n    printf(\"单精度浮点数num4 = %f，单精度浮点数大小: %u 字节\\n\", num4, sizeof(num4));\n\n    double num5 = 2.71828;\n    printf(\"双精度浮点数num5 = %lf，双精度浮点数大小: %u 字节\\n\", num5, sizeof(num5));\n\n    // 字符型示例\n    char ch1 = 'A';\n    printf(\"字符ch1 = %c，字符大小: %u 字节\\n\", ch1, sizeof(ch1));\n\n    char ch2 = 66;  // ASCII码值\n    printf(\"字符ch2 = %c，字符大小: %u 字节\\n\", ch2, sizeof(ch2));\n\n    // 布尔型示例\n    bool flag1 = true;\n    printf(\"布尔数flag1 = %d，布尔值大小: %u 字节\\n\", flag1, sizeof(flag1));\n\n    bool flag2 = false;\n    printf(\"布尔数flag2 = %d，布尔值大小: %u 字节\\n\", flag2, sizeof(flag2));\n\n    return 0;\n}\n```\n\n## C语言的运算符\n\nC语言中有多种类型的运算符，用于执行各种算术、逻辑和位操作。以下是C语言中常见的运算符类型：\n\n1. 算术运算符：用于执行基本的算术操作，如加法、减法、乘法、除法、取模等。\n    - **`+`**：加法运算\n    - `-`：减法运算\n    - *：乘法运算\n    - **`/`**：除法运算\n    - **`%`**：取模（取余）运算\n2. 关系运算符：用于比较两个值之间的关系，返回一个布尔值（1表示真，0表示假）。\n    - **`==`**：等于\n    - **`!=`**：不等于\n    - **`<`**：小于\n    - **`>`**：大于\n    - **`<=`**：小于等于\n    - **`>=`**：大于等于\n3. 逻辑运算符：用于执行逻辑操作，对布尔值进行组合和求反。\n    - **`&&`**：逻辑与（与）\n    - **`||`**：逻辑或（或）\n    - **`!`**：逻辑非（非）\n4. 位运算符：用于对二进制数据的位进行操作。\n    - **`&`**：按位与\n    - **`|`**：按位或\n    - **`^`**：按位异或\n    - **`~`**：按位取反\n    - **`<<`**：左移\n    - **`>>`**：右移\n5. 赋值运算符：用于给变量赋值。\n    - **`=`**：简单赋值\n    - **`+=`**：加法赋值\n    - **`=`**：减法赋值\n    - **`=`**：乘法赋值\n    - **`/=`**：除法赋值\n    - **`%=`**：取模赋值\n    - **`<<=`**：左移赋值\n    - **`>>=`**：右移赋值\n    - **`&=`**：按位与赋值\n    - **`|=`**：按位或赋值\n    - **`^=`**：按位异或赋值\n6. 自增和自减运算符：用于对变量进行递增或递减操作。\n    - **`++`**：自增\n    - **`-`**：自减\n7. 条件运算符：用于根据条件选择不同的值。\n    - **`? :`**：条件表达式，也称为三元运算符。\n8. 其他运算符：还有一些其他类型的运算符，如指针运算符、sizeof运算符、类型转换运算符等。\n\n### 运算符优先级\n\n![1.第一周-2023-06-09-11-36-00](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-00.png)\n\n![1.第一周-2023-06-09-11-36-08](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-08.png)\n\n![1.第一周-2023-06-09-11-36-21](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-21.png)\n\n### 运算符优先级示例代码\n\n```\n#include <stdio.h>\n\nint main() {\n    int a = 5, b = 3, c = 7;\n    int result1 = a + b * c;        // 5 + 3 * 7 = 26\n    int result2 = (a + b) * c;      // (5 + 3) * 7 = 56\n    int result3 = a * b / c;        // 5 * 3 / 7 = 2\n    int result4 = a * (b / c);      // 5 * (3 / 7) = 0\n    int result5 = a % b + c;        // 5 % 3 + 7 = 9\n    int result6 = a << b + c;       // 5 << (3 + 7) = 512\n    int result7 = (a << b) + c;     // (5 << 3) + 7 = 47\n    int result8 = a < b && b < c;   // 5 < 3 && 3 < 7 = 0 (false)\n    int result9 = a < b || b < c;   // 5 < 3 || 3 < 7 = 1 (true)\n    int result10 = a == b ? c : a;  // 5 == 3 ? 7 : 5 = 5\n\n    printf(\"Result 1: %d\\n\", result1);\n    printf(\"Result 2: %d\\n\", result2);\n    printf(\"Result 3: %d\\n\", result3);\n    printf(\"Result 4: %d\\n\", result4);\n    printf(\"Result 5: %d\\n\", result5);\n    printf(\"Result 6: %d\\n\", result6);\n    printf(\"Result 7: %d\\n\", result7);\n    printf(\"Result 8: %d\\n\", result8);\n    printf(\"Result 9: %d\\n\", result9);\n    printf(\"Result 10: %d\\n\", result10);\n\n    return 0;\n}\n```\n","slug":"c_program/1.第一周","published":1,"updated":"2023-06-10T08:09:30.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cliuf72wl000bj1nz9o3036vj","content":"<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><ol>\n<li><p>高级语言、低级语言、机器语言</p>\n<ol>\n<li>高级语言（High-Level Language）：<br> 高级语言是一种相对抽象和易于理解的编程语言，其目的是提供更高层次的抽象和功能，使程序员能够更容易地编写复杂的程序。高级语言使用人类可读的语法和结构，使用更高级别的概念和抽象，使得程序的编写更容易、更快速。高级语言通常需要通过编译或解释器转换为机器语言才能在计算机上执行。常见的高级语言包括C、C++、Java、Python和JavaScript等。</li>\n<li>低级语言（Low-Level Language）：<br> 低级语言是与计算机硬件更接近的编程语言，它使用更接近机器语言的语法和结构。低级语言通常直接操作计算机的底层硬件和资源，提供了对硬件细节的更多控制。低级语言可以更高效地利用计算机的资源，但编写和理解低级语言程序相对更困难。汇编语言和机器语言都属于低级语言。</li>\n<li>机器语言（Machine Language）：<br> 机器语言是计算机硬件直接能理解和执行的语言。它由二进制位组成，表示计算机指令和数据。机器语言是计算机可以直接执行的最底层的语言。每个计算机的机器语言是特定于该计算机体系结构的。编写机器语言程序需要对机器指令和二进制表示有深入的了解。由于机器语言的复杂性和难以理解，通常使用高级语言来编写程序，然后通过编译器或解释器将其转换为机器语言。</li>\n</ol>\n</li>\n<li><p>解释型语言和编译型语</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-10-53-51.png\" alt=\"1.第一周-2023-06-09-10-53-51\"></p>\n<p> Python 如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得 Python 程序相较于 C 程序而言更加易于移植。</p>\n</li>\n<li><p>C语言源代码到可执行文件的过程</p>\n<ol>\n<li>C源代码：<br> 程序员使用C语言编写源代码，源代码以**<code>.c</code>**为扩展名。源代码包含了程序的逻辑和功能的定义。</li>\n<li>预处理：<br> 在编译之前，C预处理器会处理源代码。预处理器执行宏展开、条件编译等操作，生成经过预处理的源代码。</li>\n<li>编译：<br> 经过预处理的源代码会被编译器翻译成汇编代码。编译器将C源代码转换为汇编语言表示，生成汇编代码文件（**<code>.s</code>**文件）。</li>\n<li>汇编：<br> 汇编器将汇编代码转换为机器码指令。它将汇编代码文件翻译成机器可执行的指令，并生成目标文件（**<code>.o</code>**文件）。</li>\n<li>链接：<br> 链接器将目标文件与其他必要的库文件进行链接，生成最终的可执行文件。链接器解析目标文件中的符号引用，并将其与库函数和其他目标文件中的符号定义进行关联。链接器生成一个包含所有必要信息的可执行文件。</li>\n<li>可执行文件：<br> 最终的可执行文件是操作系统可以直接执行的二进制文件。它包含了程序的机器码指令、数据和其他必要的信息。可执行文件可以通过命令行或操作系统的运行环境来执行。</li>\n</ol>\n</li>\n<li><p>静态语言和动态语言</p>\n<ol>\n<li><p>静态语言（Static Language）：<br> 静态语言是在编译时进行类型检查的语言。在静态语言中，变量的类型在编译时确定，并且编译器会对类型进行检查。在编译过程中，变量的类型和使用方法需要在代码中明确声明和定义。静态语言的编译器会检查变量的类型是否与其使用方式相匹配，以避免类型错误。常见的静态语言包括C、C++、Java等。</p>\n<p> 优点：</p>\n<ol>\n<li>更早地发现类型错误，提前检测潜在的编程错误。</li>\n<li>在编译时进行类型检查，提高代码的稳定性和可靠性。</li>\n<li>性能较好，由于类型已经确定，编译器可以进行更多的优化。</li>\n</ol>\n<p> 缺点：</p>\n<ol>\n<li>代码相对冗长，需要显式声明和定义类型。</li>\n<li>编译时间较长，需要进行较多的类型检查和编译过程。</li>\n</ol>\n</li>\n<li><p>动态语言（Dynamic Language）：<br> 动态语言是在运行时进行类型检查的语言。在动态语言中，变量的类型可以根据其赋值进行推断，并且可以在运行时动态地改变变量的类型。动态语言的编译器或解释器在运行时进行类型检查和解析。常见的动态语言包括Python、JavaScript、Ruby等。</p>\n<p> 优点：</p>\n<ol>\n<li>灵活性高，可以在运行时动态地改变变量的类型和行为。</li>\n<li>代码相对简洁，无需显式声明和定义类型，灵活性提高了开发效率。</li>\n</ol>\n<p> 缺点：</p>\n<ol>\n<li>需要在运行时进行类型检查和解析，性能可能相对较低。</li>\n<li>容易出现运行时类型错误，只能在运行时才能发现。</li>\n</ol>\n</li>\n</ol>\n<p> 需要注意的是，静态语言和动态语言并非绝对的对立关系，很多语言在某些方面可以具备静态语言和动态语言的特性。例如，Java是静态语言，但具备一些动态语言的特性，如反射和动态代理。同样，Python是动态语言，但也可以通过类型注解等方式实现静态类型检查。</p>\n</li>\n</ol>\n<h2 id=\"C语言开发环境\"><a href=\"#C语言开发环境\" class=\"headerlink\" title=\"C语言开发环境\"></a>C语言开发环境</h2><ol>\n<li><p>在线运行平台（一键运行）：</p>\n<ol>\n<li><a href=\"https://www.nhooo.com/tool/c/\">https://www.nhooo.com/tool/c/</a></li>\n<li><a href=\"https://www.bejson.com/runcode/c740/\">https://www.bejson.com/runcode/c740/</a></li>\n</ol>\n</li>\n<li><p>IDE（集成开发环境）：</p>\n<ol>\n<li><p>Visual Studio（一站式安装，一键编译运行）</p>\n<p> <a href=\"https://visualstudio.microsoft.com/zh-hans/\">Visual Studio下载地址</a>，<a href=\"https://zhuanlan.zhihu.com/p/71110525\">中文安装教程</a></p>\n</li>\n<li><p>VSCode + mingw（配置灵活且繁琐，一键编译运行）</p>\n<p> <a href=\"https://code.visualstudio.com/download\">VSCode下载地址，</a><a href=\"https://github.com/msys2/msys2-installer/releases/download/2023-05-26/msys2-x86_64-20230526.exe\">mingw下载地址</a>，<a href=\"https://zhuanlan.zhihu.com/p/354400717\">使用教程</a></p>\n</li>\n</ol>\n</li>\n<li><p>Linux环境（vim+gcc）</p>\n<p> 编译命令<code>gcc -o 目标文件名 源文件</code></p>\n<p> 例：<code>gcc -o test test.c</code> 将名为<code>test.c</code>的源文件编译成名为<code>test</code>的目标文件</p>\n</li>\n</ol>\n<h2 id=\"C语言程序的结构\"><a href=\"#C语言程序的结构\" class=\"headerlink\" title=\"C语言程序的结构\"></a>C语言程序的结构</h2><ul>\n<li><p>简单的C程序实例</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 定义一个名为num的变量 */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> num;</span><br><span class=\"line\">    <span class=\"comment\">/* 为num赋一个值 */</span></span><br><span class=\"line\">    num = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 使用printf()函数 */</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;I am a simple &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;computer.\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;My favorite number is %d because it is first.\\n&quot;</span>, num);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol>\n<li><p><code>#include</code>指令和头文件</p>\n<p> <code>#include</code>这行代码是一条C预处理器指令。通常，C编译器在编译前会对源代码做一些准备工作，即预处理。</p>\n<p> <code>#include &lt;stdio.h&gt;</code>的作用相当于把<code>stdio.h</code>文件中的所有内容都输入该行所在的位置。实际上，这是一种“拷贝-粘贴”的操作。</p>\n</li>\n<li><p><code>main()</code>函数</p>\n<p> C程序从<code>main()</code>函数开始执行。除了<code>main()</code>函数，你可以任意命名其他函数，而且main()函数必须是开始的函数。<code>int</code>是main()函数的返回类型。这表明main()函数返回的值是整数。返回到哪里？返回给操作系统通常，函数名后面的圆括号中包含一些传入函数的信息。该例中没有传递任何信息。因此，圆括号内是单词<code>void</code> 。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//错误的main函数定义1</span></span><br><span class=\"line\">main()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//错误的main函数定义2</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//正确的main函数定义1</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//正确的main函数定义2</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br></pre></td></tr></table></figure>\n\n<p> <strong><code>int main(int argc, char *argv[])</code></strong> 是C语言中常见的**<code>main</code>**函数的定义方式，它用于接收命令行参数。</p>\n<p> 参数解释：</p>\n<ul>\n<li>**<code>int argc</code>**：表示命令行参数的数量（Argument Count）。</li>\n<li>**<code>char *argv[]</code>**：表示命令行参数的数组（Argument Vector），是一个指针数组，每个指针指向一个以null结尾的字符串，即命令行参数的值。</li>\n</ul>\n<p> 使用这种方式定义的**<code>main</code>**函数可以接收命令行传递的参数，如下所示：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;argc: %d\\n&quot;</span>, argc);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; argc; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;argv[%d]: %s\\n&quot;</span>, i, argv[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 运行该程序并传递参数，例如：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./program arg1 arg2 arg3</span><br></pre></td></tr></table></figure>\n\n<p> 程序运行结果会输出命令行参数的数量以及每个参数的值，如：</p>\n <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">argc: 4</span><br><span class=\"line\">argv[0]: ./program</span><br><span class=\"line\">argv[1]: arg1</span><br><span class=\"line\">argv[2]: arg2</span><br><span class=\"line\">argv[3]: arg3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注释</p>\n<p> 在程序中，被两个<code>/* */</code>符号括起来的部分是程序的注释。写注释能让他人（包括自己）更容易明白你所写的程序。C 语言注释的好处之一是，可将注释放在任意的地方，甚至是与要解释的内容在同一行。较长的注释可单独放一行或多行。所有的注释都会被编译器忽略。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 这是一条C注释。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 这也是一条注释，</span></span><br><span class=\"line\"><span class=\"comment\">被分成两行。*/</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">也可以这样写注释。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">/* 这条注释无效，因为缺少了结束标记。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">// 这种注释只能写成一行</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>花括号、函数体和块</p>\n<p> 花括号把main()函数括起来。一般而言，所有的C函数都使用<code>花括号</code>标记<code>函数体的开始和结束</code>。这是规定，不能省略。只有花括号（{}）能起这种作用，圆括号（()）和方括号（[]）都不行。花括号还可用于把函数中的多条语句<code>合并</code>为一个<code>单元或块</code>。</p>\n</li>\n<li><p>声明（declaration）</p>\n<p> 声明是C语言最重要的特性之一。在该例中，声明完成了两件事。其一，在函数中有一个名为<br> num的变量（<code>variable</code>）。其二，<code>int</code>表明<code>num</code>是一个<code>整数</code>（即，没有小数点或小数部分的数）。<code>int</code>是一种数据类型。编译器使用这些信息为<code>num</code>变量在内存中分配存储空间。</p>\n</li>\n<li><p>赋值</p>\n<p> 赋值是C语言的基本操作之一。该行代码的意思是“把值1赋给变量num”。在执行int num;声明时，编译器在计算机内存中为变量num预留了空间，然后在执行这行赋值表达式语句时，把值储存在之前预留的位置。可以给num赋不同的值，这就是num之所以被称为变量（variable）的原因。</p>\n</li>\n<li><p><code>printf()</code>函数</p>\n<p> 示例代码中有3行代码都使用了C语言的一个标准函数：<code>printf()</code>。圆括号表明printf是一个函数名。圆括号中的内容是从main()函数传递给printf()函数的信息。例如，上面的第1行把<code>I am a simple</code>传递给printf()函数。该信息被称为参数。</p>\n<p> 换行符是一个转义序列（escape sequence）。转义序列用于代表难以表示或无法输入的字符。如，\\t代表Tab键，\\b代表Backspace键（退格键）。每个转义序列都以反斜杠字符（\\）开始</p>\n</li>\n<li><p><code>return</code>语句</p>\n<p> return语句是示例程序中的最后一条语句。<code>int main(void)</code>中的int表明main()函数应返回一个<code>整数</code>。C标准要求main()这样做。有返回值的C函数要有return语句。该语句以return关键字开始，后面是待返回的值，并以分号结尾。如果遗漏 main()函数中的 return 语句，程序在运行至最外面的右花括号（}）时会返回0。因此，可以省略main()函数末尾的return语句。但是，不要在其他有返回值的函数中漏掉它。</p>\n</li>\n</ol>\n<h2 id=\"C语言源程序的书写格式\"><a href=\"#C语言源程序的书写格式\" class=\"headerlink\" title=\"C语言源程序的书写格式\"></a>C语言源程序的书写格式</h2><ol>\n<li><p>缩进：使用适当的缩进来表示代码块的层次结构，常见的缩进为4个空格或一个制表符（Tab）。</p>\n</li>\n<li><p>大括号：对于控制结构、函数等代码块，使用大括号将其括起来，以表示代码块的开始和结束。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 代码块</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>空格：在运算符、逗号、分号等符号周围添加适当的空格，以提高代码的可读性。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> sum = a + b;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注释：使用注释来解释代码的功能、目的、算法等，以增加代码的可读性和可维护性。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算两个数的和</span></span><br><span class=\"line\"><span class=\"type\">int</span> sum = a + b;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命名规范：使用有意义的变量名、函数名和常量名，遵循命名规范，以提高代码的可读性和可维护性。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> numberOfStudents = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">printMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 函数体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>换行：在较长的语句中，适当地进行换行，以保持代码的可读性。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longResult = (longValue1 + longValue2 + longValue3) /</span><br><span class=\"line\">             (longValue4 - longValue5);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"C语言数据类型\"><a href=\"#C语言数据类型\" class=\"headerlink\" title=\"C语言数据类型\"></a>C语言数据类型</h2><ol>\n<li><p>整型（Integer）：</p>\n<ul>\n<li>**<code>int</code>**：表示整数类型。通常占用4个字节。</li>\n<li>**<code>short</code>**：表示短整数类型。通常占用2个字节。</li>\n<li>**<code>long</code>**：表示长整数类型。通常占用4个或8个字节，取决于编译器和操作系统。</li>\n</ul>\n<p> 示例代码：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> num1 = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">short</span> num2 = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"type\">long</span> num3 = <span class=\"number\">30L</span>;  <span class=\"comment\">// 后缀L表示长整数类型</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>浮点型（Floating-point）：</p>\n<ul>\n<li>**<code>float</code>**：表示单精度浮点数类型。通常占用4个字节。</li>\n<li>**<code>double</code>**：表示双精度浮点数类型。通常占用8个字节。</li>\n</ul>\n<p> 示例代码：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> num1 = <span class=\"number\">3.14f</span>;  <span class=\"comment\">// 后缀f表示单精度浮点数类型</span></span><br><span class=\"line\"><span class=\"type\">double</span> num2 = <span class=\"number\">2.71828</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符型（Character）：</p>\n<ul>\n<li>**<code>char</code>**：表示字符类型。通常占用1个字节。</li>\n</ul>\n<p> 示例代码：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> ch1 = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> ch2 = <span class=\"string\">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>布尔型（Boolean）：</p>\n<ul>\n<li>**<code>bool</code><strong>：表示布尔类型，只能取</strong><code>true</code><strong>（非零值）或</strong><code>false</code>**（零值）。</li>\n</ul>\n<p> 示例代码：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdbool.h&gt;</span>  <span class=\"comment\">// 需要包含stdbool.h头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> flag1 = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"type\">bool</span> flag2 = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"数据类型示例代码\"><a href=\"#数据类型示例代码\" class=\"headerlink\" title=\"数据类型示例代码\"></a>数据类型示例代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 整型示例</span></span><br><span class=\"line\">    <span class=\"type\">int</span> num1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;整数num1 = %d，整型大小: %u 字节\\n&quot;</span>, num1, <span class=\"keyword\">sizeof</span>(num1));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">short</span> num2 = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;短整数num2 = %hd，短整数大小: %u 字节\\n&quot;</span>, num2, <span class=\"keyword\">sizeof</span>(num2));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> num3 = <span class=\"number\">30L</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;长整数num3 = %ld，长整数大小: %u 字节\\n&quot;</span>, num3, <span class=\"keyword\">sizeof</span>(num3));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 浮点型示例</span></span><br><span class=\"line\">    <span class=\"type\">float</span> num4 = <span class=\"number\">3.14f</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;单精度浮点数num4 = %f，单精度浮点数大小: %u 字节\\n&quot;</span>, num4, <span class=\"keyword\">sizeof</span>(num4));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">double</span> num5 = <span class=\"number\">2.71828</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;双精度浮点数num5 = %lf，双精度浮点数大小: %u 字节\\n&quot;</span>, num5, <span class=\"keyword\">sizeof</span>(num5));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 字符型示例</span></span><br><span class=\"line\">    <span class=\"type\">char</span> ch1 = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;字符ch1 = %c，字符大小: %u 字节\\n&quot;</span>, ch1, <span class=\"keyword\">sizeof</span>(ch1));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span> ch2 = <span class=\"number\">66</span>;  <span class=\"comment\">// ASCII码值</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;字符ch2 = %c，字符大小: %u 字节\\n&quot;</span>, ch2, <span class=\"keyword\">sizeof</span>(ch2));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 布尔型示例</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> flag1 = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;布尔数flag1 = %d，布尔值大小: %u 字节\\n&quot;</span>, flag1, <span class=\"keyword\">sizeof</span>(flag1));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> flag2 = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;布尔数flag2 = %d，布尔值大小: %u 字节\\n&quot;</span>, flag2, <span class=\"keyword\">sizeof</span>(flag2));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C语言的运算符\"><a href=\"#C语言的运算符\" class=\"headerlink\" title=\"C语言的运算符\"></a>C语言的运算符</h2><p>C语言中有多种类型的运算符，用于执行各种算术、逻辑和位操作。以下是C语言中常见的运算符类型：</p>\n<ol>\n<li>算术运算符：用于执行基本的算术操作，如加法、减法、乘法、除法、取模等。<ul>\n<li>**<code>+</code>**：加法运算</li>\n<li><code>-</code>：减法运算</li>\n<li>*：乘法运算</li>\n<li>**<code>/</code>**：除法运算</li>\n<li>**<code>%</code>**：取模（取余）运算</li>\n</ul>\n</li>\n<li>关系运算符：用于比较两个值之间的关系，返回一个布尔值（1表示真，0表示假）。<ul>\n<li>**<code>==</code>**：等于</li>\n<li>**<code>!=</code>**：不等于</li>\n<li>**<code>&lt;</code>**：小于</li>\n<li>**<code>&gt;</code>**：大于</li>\n<li>**<code>&lt;=</code>**：小于等于</li>\n<li>**<code>&gt;=</code>**：大于等于</li>\n</ul>\n</li>\n<li>逻辑运算符：用于执行逻辑操作，对布尔值进行组合和求反。<ul>\n<li>**<code>&amp;&amp;</code>**：逻辑与（与）</li>\n<li>**<code>||</code>**：逻辑或（或）</li>\n<li>**<code>!</code>**：逻辑非（非）</li>\n</ul>\n</li>\n<li>位运算符：用于对二进制数据的位进行操作。<ul>\n<li>**<code>&amp;</code>**：按位与</li>\n<li>**<code>|</code>**：按位或</li>\n<li>**<code>^</code>**：按位异或</li>\n<li>**<code>~</code>**：按位取反</li>\n<li>**<code>&lt;&lt;</code>**：左移</li>\n<li>**<code>&gt;&gt;</code>**：右移</li>\n</ul>\n</li>\n<li>赋值运算符：用于给变量赋值。<ul>\n<li>**<code>=</code>**：简单赋值</li>\n<li>**<code>+=</code>**：加法赋值</li>\n<li>**<code>=</code>**：减法赋值</li>\n<li>**<code>=</code>**：乘法赋值</li>\n<li>**<code>/=</code>**：除法赋值</li>\n<li>**<code>%=</code>**：取模赋值</li>\n<li>**<code>&lt;&lt;=</code>**：左移赋值</li>\n<li>**<code>&gt;&gt;=</code>**：右移赋值</li>\n<li>**<code>&amp;=</code>**：按位与赋值</li>\n<li>**<code>|=</code>**：按位或赋值</li>\n<li>**<code>^=</code>**：按位异或赋值</li>\n</ul>\n</li>\n<li>自增和自减运算符：用于对变量进行递增或递减操作。<ul>\n<li>**<code>++</code>**：自增</li>\n<li>**<code>-</code>**：自减</li>\n</ul>\n</li>\n<li>条件运算符：用于根据条件选择不同的值。<ul>\n<li>**<code>? :</code>**：条件表达式，也称为三元运算符。</li>\n</ul>\n</li>\n<li>其他运算符：还有一些其他类型的运算符，如指针运算符、sizeof运算符、类型转换运算符等。</li>\n</ol>\n<h3 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-00.png\" alt=\"1.第一周-2023-06-09-11-36-00\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-08.png\" alt=\"1.第一周-2023-06-09-11-36-08\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-21.png\" alt=\"1.第一周-2023-06-09-11-36-21\"></p>\n<h3 id=\"运算符优先级示例代码\"><a href=\"#运算符优先级示例代码\" class=\"headerlink\" title=\"运算符优先级示例代码\"></a>运算符优先级示例代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int a = 5, b = 3, c = 7;</span><br><span class=\"line\">    int result1 = a + b * c;        // 5 + 3 * 7 = 26</span><br><span class=\"line\">    int result2 = (a + b) * c;      // (5 + 3) * 7 = 56</span><br><span class=\"line\">    int result3 = a * b / c;        // 5 * 3 / 7 = 2</span><br><span class=\"line\">    int result4 = a * (b / c);      // 5 * (3 / 7) = 0</span><br><span class=\"line\">    int result5 = a % b + c;        // 5 % 3 + 7 = 9</span><br><span class=\"line\">    int result6 = a &lt;&lt; b + c;       // 5 &lt;&lt; (3 + 7) = 512</span><br><span class=\"line\">    int result7 = (a &lt;&lt; b) + c;     // (5 &lt;&lt; 3) + 7 = 47</span><br><span class=\"line\">    int result8 = a &lt; b &amp;&amp; b &lt; c;   // 5 &lt; 3 &amp;&amp; 3 &lt; 7 = 0 (false)</span><br><span class=\"line\">    int result9 = a &lt; b || b &lt; c;   // 5 &lt; 3 || 3 &lt; 7 = 1 (true)</span><br><span class=\"line\">    int result10 = a == b ? c : a;  // 5 == 3 ? 7 : 5 = 5</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;Result 1: %d\\n&quot;, result1);</span><br><span class=\"line\">    printf(&quot;Result 2: %d\\n&quot;, result2);</span><br><span class=\"line\">    printf(&quot;Result 3: %d\\n&quot;, result3);</span><br><span class=\"line\">    printf(&quot;Result 4: %d\\n&quot;, result4);</span><br><span class=\"line\">    printf(&quot;Result 5: %d\\n&quot;, result5);</span><br><span class=\"line\">    printf(&quot;Result 6: %d\\n&quot;, result6);</span><br><span class=\"line\">    printf(&quot;Result 7: %d\\n&quot;, result7);</span><br><span class=\"line\">    printf(&quot;Result 8: %d\\n&quot;, result8);</span><br><span class=\"line\">    printf(&quot;Result 9: %d\\n&quot;, result9);</span><br><span class=\"line\">    printf(&quot;Result 10: %d\\n&quot;, result10);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><ol>\n<li><p>高级语言、低级语言、机器语言</p>\n<ol>\n<li>高级语言（High-Level Language）：<br> 高级语言是一种相对抽象和易于理解的编程语言，其目的是提供更高层次的抽象和功能，使程序员能够更容易地编写复杂的程序。高级语言使用人类可读的语法和结构，使用更高级别的概念和抽象，使得程序的编写更容易、更快速。高级语言通常需要通过编译或解释器转换为机器语言才能在计算机上执行。常见的高级语言包括C、C++、Java、Python和JavaScript等。</li>\n<li>低级语言（Low-Level Language）：<br> 低级语言是与计算机硬件更接近的编程语言，它使用更接近机器语言的语法和结构。低级语言通常直接操作计算机的底层硬件和资源，提供了对硬件细节的更多控制。低级语言可以更高效地利用计算机的资源，但编写和理解低级语言程序相对更困难。汇编语言和机器语言都属于低级语言。</li>\n<li>机器语言（Machine Language）：<br> 机器语言是计算机硬件直接能理解和执行的语言。它由二进制位组成，表示计算机指令和数据。机器语言是计算机可以直接执行的最底层的语言。每个计算机的机器语言是特定于该计算机体系结构的。编写机器语言程序需要对机器指令和二进制表示有深入的了解。由于机器语言的复杂性和难以理解，通常使用高级语言来编写程序，然后通过编译器或解释器将其转换为机器语言。</li>\n</ol>\n</li>\n<li><p>解释型语言和编译型语</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-10-53-51.png\" alt=\"1.第一周-2023-06-09-10-53-51\"></p>\n<p> Python 如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得 Python 程序相较于 C 程序而言更加易于移植。</p>\n</li>\n<li><p>C语言源代码到可执行文件的过程</p>\n<ol>\n<li>C源代码：<br> 程序员使用C语言编写源代码，源代码以**<code>.c</code>**为扩展名。源代码包含了程序的逻辑和功能的定义。</li>\n<li>预处理：<br> 在编译之前，C预处理器会处理源代码。预处理器执行宏展开、条件编译等操作，生成经过预处理的源代码。</li>\n<li>编译：<br> 经过预处理的源代码会被编译器翻译成汇编代码。编译器将C源代码转换为汇编语言表示，生成汇编代码文件（**<code>.s</code>**文件）。</li>\n<li>汇编：<br> 汇编器将汇编代码转换为机器码指令。它将汇编代码文件翻译成机器可执行的指令，并生成目标文件（**<code>.o</code>**文件）。</li>\n<li>链接：<br> 链接器将目标文件与其他必要的库文件进行链接，生成最终的可执行文件。链接器解析目标文件中的符号引用，并将其与库函数和其他目标文件中的符号定义进行关联。链接器生成一个包含所有必要信息的可执行文件。</li>\n<li>可执行文件：<br> 最终的可执行文件是操作系统可以直接执行的二进制文件。它包含了程序的机器码指令、数据和其他必要的信息。可执行文件可以通过命令行或操作系统的运行环境来执行。</li>\n</ol>\n</li>\n<li><p>静态语言和动态语言</p>\n<ol>\n<li><p>静态语言（Static Language）：<br> 静态语言是在编译时进行类型检查的语言。在静态语言中，变量的类型在编译时确定，并且编译器会对类型进行检查。在编译过程中，变量的类型和使用方法需要在代码中明确声明和定义。静态语言的编译器会检查变量的类型是否与其使用方式相匹配，以避免类型错误。常见的静态语言包括C、C++、Java等。</p>\n<p> 优点：</p>\n<ol>\n<li>更早地发现类型错误，提前检测潜在的编程错误。</li>\n<li>在编译时进行类型检查，提高代码的稳定性和可靠性。</li>\n<li>性能较好，由于类型已经确定，编译器可以进行更多的优化。</li>\n</ol>\n<p> 缺点：</p>\n<ol>\n<li>代码相对冗长，需要显式声明和定义类型。</li>\n<li>编译时间较长，需要进行较多的类型检查和编译过程。</li>\n</ol>\n</li>\n<li><p>动态语言（Dynamic Language）：<br> 动态语言是在运行时进行类型检查的语言。在动态语言中，变量的类型可以根据其赋值进行推断，并且可以在运行时动态地改变变量的类型。动态语言的编译器或解释器在运行时进行类型检查和解析。常见的动态语言包括Python、JavaScript、Ruby等。</p>\n<p> 优点：</p>\n<ol>\n<li>灵活性高，可以在运行时动态地改变变量的类型和行为。</li>\n<li>代码相对简洁，无需显式声明和定义类型，灵活性提高了开发效率。</li>\n</ol>\n<p> 缺点：</p>\n<ol>\n<li>需要在运行时进行类型检查和解析，性能可能相对较低。</li>\n<li>容易出现运行时类型错误，只能在运行时才能发现。</li>\n</ol>\n</li>\n</ol>\n<p> 需要注意的是，静态语言和动态语言并非绝对的对立关系，很多语言在某些方面可以具备静态语言和动态语言的特性。例如，Java是静态语言，但具备一些动态语言的特性，如反射和动态代理。同样，Python是动态语言，但也可以通过类型注解等方式实现静态类型检查。</p>\n</li>\n</ol>\n<h2 id=\"C语言开发环境\"><a href=\"#C语言开发环境\" class=\"headerlink\" title=\"C语言开发环境\"></a>C语言开发环境</h2><ol>\n<li><p>在线运行平台（一键运行）：</p>\n<ol>\n<li><a href=\"https://www.nhooo.com/tool/c/\">https://www.nhooo.com/tool/c/</a></li>\n<li><a href=\"https://www.bejson.com/runcode/c740/\">https://www.bejson.com/runcode/c740/</a></li>\n</ol>\n</li>\n<li><p>IDE（集成开发环境）：</p>\n<ol>\n<li><p>Visual Studio（一站式安装，一键编译运行）</p>\n<p> <a href=\"https://visualstudio.microsoft.com/zh-hans/\">Visual Studio下载地址</a>，<a href=\"https://zhuanlan.zhihu.com/p/71110525\">中文安装教程</a></p>\n</li>\n<li><p>VSCode + mingw（配置灵活且繁琐，一键编译运行）</p>\n<p> <a href=\"https://code.visualstudio.com/download\">VSCode下载地址，</a><a href=\"https://github.com/msys2/msys2-installer/releases/download/2023-05-26/msys2-x86_64-20230526.exe\">mingw下载地址</a>，<a href=\"https://zhuanlan.zhihu.com/p/354400717\">使用教程</a></p>\n</li>\n</ol>\n</li>\n<li><p>Linux环境（vim+gcc）</p>\n<p> 编译命令<code>gcc -o 目标文件名 源文件</code></p>\n<p> 例：<code>gcc -o test test.c</code> 将名为<code>test.c</code>的源文件编译成名为<code>test</code>的目标文件</p>\n</li>\n</ol>\n<h2 id=\"C语言程序的结构\"><a href=\"#C语言程序的结构\" class=\"headerlink\" title=\"C语言程序的结构\"></a>C语言程序的结构</h2><ul>\n<li><p>简单的C程序实例</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 定义一个名为num的变量 */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> num;</span><br><span class=\"line\">    <span class=\"comment\">/* 为num赋一个值 */</span></span><br><span class=\"line\">    num = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 使用printf()函数 */</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;I am a simple &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;computer.\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;My favorite number is %d because it is first.\\n&quot;</span>, num);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol>\n<li><p><code>#include</code>指令和头文件</p>\n<p> <code>#include</code>这行代码是一条C预处理器指令。通常，C编译器在编译前会对源代码做一些准备工作，即预处理。</p>\n<p> <code>#include &lt;stdio.h&gt;</code>的作用相当于把<code>stdio.h</code>文件中的所有内容都输入该行所在的位置。实际上，这是一种“拷贝-粘贴”的操作。</p>\n</li>\n<li><p><code>main()</code>函数</p>\n<p> C程序从<code>main()</code>函数开始执行。除了<code>main()</code>函数，你可以任意命名其他函数，而且main()函数必须是开始的函数。<code>int</code>是main()函数的返回类型。这表明main()函数返回的值是整数。返回到哪里？返回给操作系统通常，函数名后面的圆括号中包含一些传入函数的信息。该例中没有传递任何信息。因此，圆括号内是单词<code>void</code> 。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//错误的main函数定义1</span></span><br><span class=\"line\">main()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//错误的main函数定义2</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//正确的main函数定义1</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//正确的main函数定义2</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br></pre></td></tr></table></figure>\n\n<p> <strong><code>int main(int argc, char *argv[])</code></strong> 是C语言中常见的**<code>main</code>**函数的定义方式，它用于接收命令行参数。</p>\n<p> 参数解释：</p>\n<ul>\n<li>**<code>int argc</code>**：表示命令行参数的数量（Argument Count）。</li>\n<li>**<code>char *argv[]</code>**：表示命令行参数的数组（Argument Vector），是一个指针数组，每个指针指向一个以null结尾的字符串，即命令行参数的值。</li>\n</ul>\n<p> 使用这种方式定义的**<code>main</code>**函数可以接收命令行传递的参数，如下所示：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;argc: %d\\n&quot;</span>, argc);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; argc; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;argv[%d]: %s\\n&quot;</span>, i, argv[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 运行该程序并传递参数，例如：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./program arg1 arg2 arg3</span><br></pre></td></tr></table></figure>\n\n<p> 程序运行结果会输出命令行参数的数量以及每个参数的值，如：</p>\n <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">argc: 4</span><br><span class=\"line\">argv[0]: ./program</span><br><span class=\"line\">argv[1]: arg1</span><br><span class=\"line\">argv[2]: arg2</span><br><span class=\"line\">argv[3]: arg3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注释</p>\n<p> 在程序中，被两个<code>/* */</code>符号括起来的部分是程序的注释。写注释能让他人（包括自己）更容易明白你所写的程序。C 语言注释的好处之一是，可将注释放在任意的地方，甚至是与要解释的内容在同一行。较长的注释可单独放一行或多行。所有的注释都会被编译器忽略。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 这是一条C注释。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 这也是一条注释，</span></span><br><span class=\"line\"><span class=\"comment\">被分成两行。*/</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">也可以这样写注释。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">/* 这条注释无效，因为缺少了结束标记。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">// 这种注释只能写成一行</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>花括号、函数体和块</p>\n<p> 花括号把main()函数括起来。一般而言，所有的C函数都使用<code>花括号</code>标记<code>函数体的开始和结束</code>。这是规定，不能省略。只有花括号（{}）能起这种作用，圆括号（()）和方括号（[]）都不行。花括号还可用于把函数中的多条语句<code>合并</code>为一个<code>单元或块</code>。</p>\n</li>\n<li><p>声明（declaration）</p>\n<p> 声明是C语言最重要的特性之一。在该例中，声明完成了两件事。其一，在函数中有一个名为<br> num的变量（<code>variable</code>）。其二，<code>int</code>表明<code>num</code>是一个<code>整数</code>（即，没有小数点或小数部分的数）。<code>int</code>是一种数据类型。编译器使用这些信息为<code>num</code>变量在内存中分配存储空间。</p>\n</li>\n<li><p>赋值</p>\n<p> 赋值是C语言的基本操作之一。该行代码的意思是“把值1赋给变量num”。在执行int num;声明时，编译器在计算机内存中为变量num预留了空间，然后在执行这行赋值表达式语句时，把值储存在之前预留的位置。可以给num赋不同的值，这就是num之所以被称为变量（variable）的原因。</p>\n</li>\n<li><p><code>printf()</code>函数</p>\n<p> 示例代码中有3行代码都使用了C语言的一个标准函数：<code>printf()</code>。圆括号表明printf是一个函数名。圆括号中的内容是从main()函数传递给printf()函数的信息。例如，上面的第1行把<code>I am a simple</code>传递给printf()函数。该信息被称为参数。</p>\n<p> 换行符是一个转义序列（escape sequence）。转义序列用于代表难以表示或无法输入的字符。如，\\t代表Tab键，\\b代表Backspace键（退格键）。每个转义序列都以反斜杠字符（\\）开始</p>\n</li>\n<li><p><code>return</code>语句</p>\n<p> return语句是示例程序中的最后一条语句。<code>int main(void)</code>中的int表明main()函数应返回一个<code>整数</code>。C标准要求main()这样做。有返回值的C函数要有return语句。该语句以return关键字开始，后面是待返回的值，并以分号结尾。如果遗漏 main()函数中的 return 语句，程序在运行至最外面的右花括号（}）时会返回0。因此，可以省略main()函数末尾的return语句。但是，不要在其他有返回值的函数中漏掉它。</p>\n</li>\n</ol>\n<h2 id=\"C语言源程序的书写格式\"><a href=\"#C语言源程序的书写格式\" class=\"headerlink\" title=\"C语言源程序的书写格式\"></a>C语言源程序的书写格式</h2><ol>\n<li><p>缩进：使用适当的缩进来表示代码块的层次结构，常见的缩进为4个空格或一个制表符（Tab）。</p>\n</li>\n<li><p>大括号：对于控制结构、函数等代码块，使用大括号将其括起来，以表示代码块的开始和结束。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 代码块</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>空格：在运算符、逗号、分号等符号周围添加适当的空格，以提高代码的可读性。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> sum = a + b;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注释：使用注释来解释代码的功能、目的、算法等，以增加代码的可读性和可维护性。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算两个数的和</span></span><br><span class=\"line\"><span class=\"type\">int</span> sum = a + b;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命名规范：使用有意义的变量名、函数名和常量名，遵循命名规范，以提高代码的可读性和可维护性。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> numberOfStudents = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">printMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 函数体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>换行：在较长的语句中，适当地进行换行，以保持代码的可读性。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longResult = (longValue1 + longValue2 + longValue3) /</span><br><span class=\"line\">             (longValue4 - longValue5);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"C语言数据类型\"><a href=\"#C语言数据类型\" class=\"headerlink\" title=\"C语言数据类型\"></a>C语言数据类型</h2><ol>\n<li><p>整型（Integer）：</p>\n<ul>\n<li>**<code>int</code>**：表示整数类型。通常占用4个字节。</li>\n<li>**<code>short</code>**：表示短整数类型。通常占用2个字节。</li>\n<li>**<code>long</code>**：表示长整数类型。通常占用4个或8个字节，取决于编译器和操作系统。</li>\n</ul>\n<p> 示例代码：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> num1 = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">short</span> num2 = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"type\">long</span> num3 = <span class=\"number\">30L</span>;  <span class=\"comment\">// 后缀L表示长整数类型</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>浮点型（Floating-point）：</p>\n<ul>\n<li>**<code>float</code>**：表示单精度浮点数类型。通常占用4个字节。</li>\n<li>**<code>double</code>**：表示双精度浮点数类型。通常占用8个字节。</li>\n</ul>\n<p> 示例代码：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> num1 = <span class=\"number\">3.14f</span>;  <span class=\"comment\">// 后缀f表示单精度浮点数类型</span></span><br><span class=\"line\"><span class=\"type\">double</span> num2 = <span class=\"number\">2.71828</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符型（Character）：</p>\n<ul>\n<li>**<code>char</code>**：表示字符类型。通常占用1个字节。</li>\n</ul>\n<p> 示例代码：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> ch1 = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> ch2 = <span class=\"string\">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>布尔型（Boolean）：</p>\n<ul>\n<li>**<code>bool</code><strong>：表示布尔类型，只能取</strong><code>true</code><strong>（非零值）或</strong><code>false</code>**（零值）。</li>\n</ul>\n<p> 示例代码：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdbool.h&gt;</span>  <span class=\"comment\">// 需要包含stdbool.h头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> flag1 = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"type\">bool</span> flag2 = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"数据类型示例代码\"><a href=\"#数据类型示例代码\" class=\"headerlink\" title=\"数据类型示例代码\"></a>数据类型示例代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 整型示例</span></span><br><span class=\"line\">    <span class=\"type\">int</span> num1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;整数num1 = %d，整型大小: %u 字节\\n&quot;</span>, num1, <span class=\"keyword\">sizeof</span>(num1));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">short</span> num2 = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;短整数num2 = %hd，短整数大小: %u 字节\\n&quot;</span>, num2, <span class=\"keyword\">sizeof</span>(num2));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> num3 = <span class=\"number\">30L</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;长整数num3 = %ld，长整数大小: %u 字节\\n&quot;</span>, num3, <span class=\"keyword\">sizeof</span>(num3));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 浮点型示例</span></span><br><span class=\"line\">    <span class=\"type\">float</span> num4 = <span class=\"number\">3.14f</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;单精度浮点数num4 = %f，单精度浮点数大小: %u 字节\\n&quot;</span>, num4, <span class=\"keyword\">sizeof</span>(num4));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">double</span> num5 = <span class=\"number\">2.71828</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;双精度浮点数num5 = %lf，双精度浮点数大小: %u 字节\\n&quot;</span>, num5, <span class=\"keyword\">sizeof</span>(num5));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 字符型示例</span></span><br><span class=\"line\">    <span class=\"type\">char</span> ch1 = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;字符ch1 = %c，字符大小: %u 字节\\n&quot;</span>, ch1, <span class=\"keyword\">sizeof</span>(ch1));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span> ch2 = <span class=\"number\">66</span>;  <span class=\"comment\">// ASCII码值</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;字符ch2 = %c，字符大小: %u 字节\\n&quot;</span>, ch2, <span class=\"keyword\">sizeof</span>(ch2));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 布尔型示例</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> flag1 = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;布尔数flag1 = %d，布尔值大小: %u 字节\\n&quot;</span>, flag1, <span class=\"keyword\">sizeof</span>(flag1));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> flag2 = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;布尔数flag2 = %d，布尔值大小: %u 字节\\n&quot;</span>, flag2, <span class=\"keyword\">sizeof</span>(flag2));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C语言的运算符\"><a href=\"#C语言的运算符\" class=\"headerlink\" title=\"C语言的运算符\"></a>C语言的运算符</h2><p>C语言中有多种类型的运算符，用于执行各种算术、逻辑和位操作。以下是C语言中常见的运算符类型：</p>\n<ol>\n<li>算术运算符：用于执行基本的算术操作，如加法、减法、乘法、除法、取模等。<ul>\n<li>**<code>+</code>**：加法运算</li>\n<li><code>-</code>：减法运算</li>\n<li>*：乘法运算</li>\n<li>**<code>/</code>**：除法运算</li>\n<li>**<code>%</code>**：取模（取余）运算</li>\n</ul>\n</li>\n<li>关系运算符：用于比较两个值之间的关系，返回一个布尔值（1表示真，0表示假）。<ul>\n<li>**<code>==</code>**：等于</li>\n<li>**<code>!=</code>**：不等于</li>\n<li>**<code>&lt;</code>**：小于</li>\n<li>**<code>&gt;</code>**：大于</li>\n<li>**<code>&lt;=</code>**：小于等于</li>\n<li>**<code>&gt;=</code>**：大于等于</li>\n</ul>\n</li>\n<li>逻辑运算符：用于执行逻辑操作，对布尔值进行组合和求反。<ul>\n<li>**<code>&amp;&amp;</code>**：逻辑与（与）</li>\n<li>**<code>||</code>**：逻辑或（或）</li>\n<li>**<code>!</code>**：逻辑非（非）</li>\n</ul>\n</li>\n<li>位运算符：用于对二进制数据的位进行操作。<ul>\n<li>**<code>&amp;</code>**：按位与</li>\n<li>**<code>|</code>**：按位或</li>\n<li>**<code>^</code>**：按位异或</li>\n<li>**<code>~</code>**：按位取反</li>\n<li>**<code>&lt;&lt;</code>**：左移</li>\n<li>**<code>&gt;&gt;</code>**：右移</li>\n</ul>\n</li>\n<li>赋值运算符：用于给变量赋值。<ul>\n<li>**<code>=</code>**：简单赋值</li>\n<li>**<code>+=</code>**：加法赋值</li>\n<li>**<code>=</code>**：减法赋值</li>\n<li>**<code>=</code>**：乘法赋值</li>\n<li>**<code>/=</code>**：除法赋值</li>\n<li>**<code>%=</code>**：取模赋值</li>\n<li>**<code>&lt;&lt;=</code>**：左移赋值</li>\n<li>**<code>&gt;&gt;=</code>**：右移赋值</li>\n<li>**<code>&amp;=</code>**：按位与赋值</li>\n<li>**<code>|=</code>**：按位或赋值</li>\n<li>**<code>^=</code>**：按位异或赋值</li>\n</ul>\n</li>\n<li>自增和自减运算符：用于对变量进行递增或递减操作。<ul>\n<li>**<code>++</code>**：自增</li>\n<li>**<code>-</code>**：自减</li>\n</ul>\n</li>\n<li>条件运算符：用于根据条件选择不同的值。<ul>\n<li>**<code>? :</code>**：条件表达式，也称为三元运算符。</li>\n</ul>\n</li>\n<li>其他运算符：还有一些其他类型的运算符，如指针运算符、sizeof运算符、类型转换运算符等。</li>\n</ol>\n<h3 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-00.png\" alt=\"1.第一周-2023-06-09-11-36-00\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-08.png\" alt=\"1.第一周-2023-06-09-11-36-08\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-21.png\" alt=\"1.第一周-2023-06-09-11-36-21\"></p>\n<h3 id=\"运算符优先级示例代码\"><a href=\"#运算符优先级示例代码\" class=\"headerlink\" title=\"运算符优先级示例代码\"></a>运算符优先级示例代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int a = 5, b = 3, c = 7;</span><br><span class=\"line\">    int result1 = a + b * c;        // 5 + 3 * 7 = 26</span><br><span class=\"line\">    int result2 = (a + b) * c;      // (5 + 3) * 7 = 56</span><br><span class=\"line\">    int result3 = a * b / c;        // 5 * 3 / 7 = 2</span><br><span class=\"line\">    int result4 = a * (b / c);      // 5 * (3 / 7) = 0</span><br><span class=\"line\">    int result5 = a % b + c;        // 5 % 3 + 7 = 9</span><br><span class=\"line\">    int result6 = a &lt;&lt; b + c;       // 5 &lt;&lt; (3 + 7) = 512</span><br><span class=\"line\">    int result7 = (a &lt;&lt; b) + c;     // (5 &lt;&lt; 3) + 7 = 47</span><br><span class=\"line\">    int result8 = a &lt; b &amp;&amp; b &lt; c;   // 5 &lt; 3 &amp;&amp; 3 &lt; 7 = 0 (false)</span><br><span class=\"line\">    int result9 = a &lt; b || b &lt; c;   // 5 &lt; 3 || 3 &lt; 7 = 1 (true)</span><br><span class=\"line\">    int result10 = a == b ? c : a;  // 5 == 3 ? 7 : 5 = 5</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;Result 1: %d\\n&quot;, result1);</span><br><span class=\"line\">    printf(&quot;Result 2: %d\\n&quot;, result2);</span><br><span class=\"line\">    printf(&quot;Result 3: %d\\n&quot;, result3);</span><br><span class=\"line\">    printf(&quot;Result 4: %d\\n&quot;, result4);</span><br><span class=\"line\">    printf(&quot;Result 5: %d\\n&quot;, result5);</span><br><span class=\"line\">    printf(&quot;Result 6: %d\\n&quot;, result6);</span><br><span class=\"line\">    printf(&quot;Result 7: %d\\n&quot;, result7);</span><br><span class=\"line\">    printf(&quot;Result 8: %d\\n&quot;, result8);</span><br><span class=\"line\">    printf(&quot;Result 9: %d\\n&quot;, result9);</span><br><span class=\"line\">    printf(&quot;Result 10: %d\\n&quot;, result10);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}